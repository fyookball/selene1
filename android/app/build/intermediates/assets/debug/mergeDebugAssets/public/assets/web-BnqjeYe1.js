import{W as v,m as R,n as q,__tla as x}from"./index-BEjSkI0g.js";import"torboar";let w,E=Promise.all([(()=>{try{return x}catch{}})()]).then(async()=>{function g(e){const i=e.split("/").filter(r=>r!=="."),t=[];return i.forEach(r=>{r===".."&&t.length>0&&t[t.length-1]!==".."?t.pop():t.push(r)}),t.join("/")}function m(e,i){e=g(e),i=g(i);const t=e.split("/"),r=i.split("/");return e!==i&&t.every((o,s)=>o===r[s])}w=class extends v{constructor(){super(...arguments),this.DB_VERSION=1,this.DB_NAME="Disc",this._writeCmds=["add","put","delete"],this.downloadFile=async e=>{var i,t;const r=R(e,e.webFetchExtra),o=await fetch(e.url,r);let s;if(!e.progress)s=await o.blob();else if(!(o!=null&&o.body))s=new Blob;else{const n=o.body.getReader();let a=0;const c=[],d=o.headers.get("content-type"),y=parseInt(o.headers.get("content-length")||"0",10);for(;;){const{done:h,value:u}=await n.read();if(h)break;c.push(u),a+=(u==null?void 0:u.length)||0;const f={url:e.url,bytes:a,contentLength:y};this.notifyListeners("progress",f)}const p=new Uint8Array(a);let l=0;for(const h of c)typeof h>"u"||(p.set(h,l),l+=h.length);s=new Blob([p.buffer],{type:d||void 0})}return{path:(await this.writeFile({path:e.path,directory:(i=e.directory)!==null&&i!==void 0?i:void 0,recursive:(t=e.recursive)!==null&&t!==void 0?t:!1,data:s})).uri,blob:s}}}async initDb(){if(this._db!==void 0)return this._db;if(!("indexedDB"in window))throw this.unavailable("This browser doesn't support IndexedDB");return new Promise((e,i)=>{const t=indexedDB.open(this.DB_NAME,this.DB_VERSION);t.onupgradeneeded=w.doUpgrade,t.onsuccess=()=>{this._db=t.result,e(t.result)},t.onerror=()=>i(t.error),t.onblocked=()=>{console.warn("db blocked")}})}static doUpgrade(e){const i=e.target.result;switch(e.oldVersion){case 0:case 1:default:i.objectStoreNames.contains("FileStorage")&&i.deleteObjectStore("FileStorage"),i.createObjectStore("FileStorage",{keyPath:"path"}).createIndex("by_folder","folder")}}async dbRequest(e,i){const t=this._writeCmds.indexOf(e)!==-1?"readwrite":"readonly";return this.initDb().then(r=>new Promise((o,s)=>{const n=r.transaction(["FileStorage"],t).objectStore("FileStorage")[e](...i);n.onsuccess=()=>o(n.result),n.onerror=()=>s(n.error)}))}async dbIndexRequest(e,i,t){const r=this._writeCmds.indexOf(i)!==-1?"readwrite":"readonly";return this.initDb().then(o=>new Promise((s,n)=>{const a=o.transaction(["FileStorage"],r).objectStore("FileStorage").index(e)[i](...t);a.onsuccess=()=>s(a.result),a.onerror=()=>n(a.error)}))}getPath(e,i){const t=i!==void 0?i.replace(/^[/]+|[/]+$/g,""):"";let r="";return e!==void 0&&(r+="/"+e),i!==""&&(r+="/"+t),r}async clear(){(await this.initDb()).transaction(["FileStorage"],"readwrite").objectStore("FileStorage").clear()}async readFile(e){const i=this.getPath(e.directory,e.path),t=await this.dbRequest("get",[i]);if(t===void 0)throw Error("File does not exist.");return{data:t.content?t.content:""}}async writeFile(e){const i=this.getPath(e.directory,e.path);let t=e.data;const r=e.encoding,o=e.recursive,s=await this.dbRequest("get",[i]);if(s&&s.type==="directory")throw Error("The supplied path is a directory.");const n=i.substr(0,i.lastIndexOf("/"));if(await this.dbRequest("get",[n])===void 0){const d=n.indexOf("/",1);if(d!==-1){const y=n.substr(d);await this.mkdir({path:y,directory:e.directory,recursive:o})}}if(!r&&!(t instanceof Blob)&&(t=t.indexOf(",")>=0?t.split(",")[1]:t,!this.isBase64String(t)))throw Error("The supplied data is not valid base64 content.");const a=Date.now(),c={path:i,folder:n,type:"file",size:t instanceof Blob?t.size:t.length,ctime:a,mtime:a,content:t};return await this.dbRequest("put",[c]),{uri:c.path}}async appendFile(e){const i=this.getPath(e.directory,e.path);let t=e.data;const r=e.encoding,o=i.substr(0,i.lastIndexOf("/")),s=Date.now();let n=s;const a=await this.dbRequest("get",[i]);if(a&&a.type==="directory")throw Error("The supplied path is a directory.");if(await this.dbRequest("get",[o])===void 0){const d=o.indexOf("/",1);if(d!==-1){const y=o.substr(d);await this.mkdir({path:y,directory:e.directory,recursive:!0})}}if(!r&&!this.isBase64String(t))throw Error("The supplied data is not valid base64 content.");if(a!==void 0){if(a.content instanceof Blob)throw Error("The occupied entry contains a Blob object which cannot be appended to.");a.content!==void 0&&!r?t=btoa(atob(a.content)+atob(t)):t=a.content+t,n=a.ctime}const c={path:i,folder:o,type:"file",size:t.length,ctime:n,mtime:s,content:t};await this.dbRequest("put",[c])}async deleteFile(e){const i=this.getPath(e.directory,e.path);if(await this.dbRequest("get",[i])===void 0)throw Error("File does not exist.");if((await this.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(i)])).length!==0)throw Error("Folder is not empty.");await this.dbRequest("delete",[i])}async mkdir(e){const i=this.getPath(e.directory,e.path),t=e.recursive,r=i.substr(0,i.lastIndexOf("/")),o=(i.match(/\//g)||[]).length,s=await this.dbRequest("get",[r]),n=await this.dbRequest("get",[i]);if(o===1)throw Error("Cannot create Root directory");if(n!==void 0)throw Error("Current directory does already exist.");if(!t&&o!==2&&s===void 0)throw Error("Parent directory must exist");if(t&&o!==2&&s===void 0){const d=r.substr(r.indexOf("/",1));await this.mkdir({path:d,directory:e.directory,recursive:t})}const a=Date.now(),c={path:i,folder:r,type:"directory",size:0,ctime:a,mtime:a};await this.dbRequest("put",[c])}async rmdir(e){const{path:i,directory:t,recursive:r}=e,o=this.getPath(t,i),s=await this.dbRequest("get",[o]);if(s===void 0)throw Error("Folder does not exist.");if(s.type!=="directory")throw Error("Requested path is not a directory");const n=await this.readdir({path:i,directory:t});if(n.files.length!==0&&!r)throw Error("Folder is not empty");for(const a of n.files){const c=`${i}/${a.name}`;(await this.stat({path:c,directory:t})).type==="file"?await this.deleteFile({path:c,directory:t}):await this.rmdir({path:c,directory:t,recursive:r})}await this.dbRequest("delete",[o])}async readdir(e){const i=this.getPath(e.directory,e.path),t=await this.dbRequest("get",[i]);if(e.path!==""&&t===void 0)throw Error("Folder does not exist.");const r=await this.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(i)]);return{files:await Promise.all(r.map(async o=>{let s=await this.dbRequest("get",[o]);return s===void 0&&(s=await this.dbRequest("get",[o+"/"])),{name:o.substring(i.length+1),type:s.type,size:s.size,ctime:s.ctime,mtime:s.mtime,uri:s.path}}))}}async getUri(e){const i=this.getPath(e.directory,e.path);let t=await this.dbRequest("get",[i]);return t===void 0&&(t=await this.dbRequest("get",[i+"/"])),{uri:(t==null?void 0:t.path)||i}}async stat(e){const i=this.getPath(e.directory,e.path);let t=await this.dbRequest("get",[i]);if(t===void 0&&(t=await this.dbRequest("get",[i+"/"])),t===void 0)throw Error("Entry does not exist.");return{type:t.type,size:t.size,ctime:t.ctime,mtime:t.mtime,uri:t.path}}async rename(e){await this._copy(e,!0)}async copy(e){return this._copy(e,!1)}async requestPermissions(){return{publicStorage:"granted"}}async checkPermissions(){return{publicStorage:"granted"}}async _copy(e,i=!1){let{toDirectory:t}=e;const{to:r,from:o,directory:s}=e;if(!r||!o)throw Error("Both to and from must be provided");t||(t=s);const n=this.getPath(s,o),a=this.getPath(t,r);if(n===a)return{uri:a};if(m(n,a))throw Error("To path cannot contain the from path");let c;try{c=await this.stat({path:r,directory:t})}catch{const l=r.split("/");l.pop();const h=l.join("/");if(l.length>0&&(await this.stat({path:h,directory:t})).type!=="directory")throw new Error("Parent directory of the to path is a file")}if(c&&c.type==="directory")throw new Error("Cannot overwrite a directory with a file");const d=await this.stat({path:o,directory:s}),y=async(l,h,u)=>{const f=this.getPath(t,l),b=await this.dbRequest("get",[f]);b.ctime=h,b.mtime=u,await this.dbRequest("put",[b])},p=d.ctime?d.ctime:Date.now();switch(d.type){case"file":{const l=await this.readFile({path:o,directory:s});i&&await this.deleteFile({path:o,directory:s});let h;!(l.data instanceof Blob)&&!this.isBase64String(l.data)&&(h=q.UTF8);const u=await this.writeFile({path:r,directory:t,data:l.data,encoding:h});return i&&await y(r,p,d.mtime),u}case"directory":{if(c)throw Error("Cannot move a directory over an existing object");try{await this.mkdir({path:r,directory:t,recursive:!1}),i&&await y(r,p,d.mtime)}catch{}const l=(await this.readdir({path:o,directory:s})).files;for(const h of l)await this._copy({from:`${o}/${h.name}`,to:`${r}/${h.name}`,directory:s,toDirectory:t},i);i&&await this.rmdir({path:o,directory:s})}}return{uri:a}}isBase64String(e){try{return btoa(atob(e))==e}catch{return!1}}},w._debug=!0});export{w as FilesystemWeb,E as __tla};
