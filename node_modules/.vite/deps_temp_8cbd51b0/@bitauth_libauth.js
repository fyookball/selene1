import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'

globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
globalThis.global = globalThis.global || __global_polyfill
globalThis.process = globalThis.process || __process_polyfill

import {
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-UN4YHSTI.js";

// node_modules/@bitauth/libauth/build/index.js
var import_dist406 = __toESM(require_dist());
var import_dist407 = __toESM(require_dist2());
var import_dist408 = __toESM(require_dist3());

// node_modules/@bitauth/libauth/build/lib/lib.js
var import_dist403 = __toESM(require_dist(), 1);
var import_dist404 = __toESM(require_dist2(), 1);
var import_dist405 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/address/address.js
var import_dist109 = __toESM(require_dist(), 1);
var import_dist110 = __toESM(require_dist2(), 1);
var import_dist111 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/address/base58-address.js
var import_dist97 = __toESM(require_dist(), 1);
var import_dist98 = __toESM(require_dist2(), 1);
var import_dist99 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/crypto/crypto.js
var import_dist94 = __toESM(require_dist(), 1);
var import_dist95 = __toESM(require_dist2(), 1);
var import_dist96 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/crypto/combinations.js
var import_dist85 = __toESM(require_dist(), 1);
var import_dist86 = __toESM(require_dist2(), 1);
var import_dist87 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/crypto/default-crypto-instances.js
var import_dist82 = __toESM(require_dist(), 1);
var import_dist83 = __toESM(require_dist2(), 1);
var import_dist84 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/crypto/ripemd160.js
var import_dist67 = __toESM(require_dist(), 1);
var import_dist68 = __toESM(require_dist2(), 1);
var import_dist69 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/crypto/dependencies.js
var import_dist64 = __toESM(require_dist(), 1);
var import_dist65 = __toESM(require_dist2(), 1);
var import_dist66 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/format/format.js
var import_dist34 = __toESM(require_dist(), 1);
var import_dist35 = __toESM(require_dist2(), 1);
var import_dist36 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/format/base-convert.js
var import_dist = __toESM(require_dist(), 1);
var import_dist2 = __toESM(require_dist2(), 1);
var import_dist3 = __toESM(require_dist3(), 1);
var BaseConversionError;
(function(BaseConversionError2) {
  BaseConversionError2["tooLong"] = "An alphabet may be no longer than 254 characters.";
  BaseConversionError2["ambiguousCharacter"] = "A character code may only appear once in a single alphabet.";
  BaseConversionError2["unknownCharacter"] = "Encountered an unknown character for this alphabet.";
})(BaseConversionError || (BaseConversionError = {}));
var createBaseConverter = (alphabet) => {
  const undefinedValue = 255;
  const uint8ArrayBase = 256;
  if (alphabet.length >= undefinedValue)
    return BaseConversionError.tooLong;
  const alphabetMap = new Uint8Array(uint8ArrayBase).fill(undefinedValue);
  for (let index2 = 0; index2 < alphabet.length; index2++) {
    const characterCode = alphabet.charCodeAt(index2);
    if (alphabetMap[characterCode] !== undefinedValue) {
      return BaseConversionError.ambiguousCharacter;
    }
    alphabetMap[characterCode] = index2;
  }
  const base = alphabet.length;
  const paddingCharacter = alphabet.charAt(0);
  const factor = Math.log(base) / Math.log(uint8ArrayBase);
  const inverseFactor = Math.log(uint8ArrayBase) / Math.log(base);
  return {
    // eslint-disable-next-line complexity
    decode: (input) => {
      if (input.length === 0)
        return Uint8Array.of();
      const firstNonZeroIndex = input.split("").findIndex((character) => character !== paddingCharacter);
      if (firstNonZeroIndex === -1) {
        return new Uint8Array(input.length);
      }
      const requiredLength = Math.floor((input.length - firstNonZeroIndex) * factor + 1);
      const decoded = new Uint8Array(requiredLength);
      let nextByte = firstNonZeroIndex;
      let remainingBytes = 0;
      while (input[nextByte] !== void 0) {
        let carry = alphabetMap[input.charCodeAt(nextByte)];
        if (carry === undefinedValue)
          return BaseConversionError.unknownCharacter;
        let digit = 0;
        for (
          let steps = requiredLength - 1;
          (carry !== 0 || digit < remainingBytes) && steps !== -1;
          // eslint-disable-next-line no-plusplus
          steps--, digit++
        ) {
          carry += Math.floor(base * decoded[steps]);
          decoded[steps] = Math.floor(carry % uint8ArrayBase);
          carry = Math.floor(carry / uint8ArrayBase);
        }
        remainingBytes = digit;
        nextByte++;
      }
      const firstNonZeroResultDigit = decoded.findIndex((value) => value !== 0);
      const bin = new Uint8Array(firstNonZeroIndex + (requiredLength - firstNonZeroResultDigit));
      bin.set(decoded.slice(firstNonZeroResultDigit), firstNonZeroIndex);
      return bin;
    },
    // eslint-disable-next-line complexity
    encode: (input) => {
      if (input.length === 0)
        return "";
      const firstNonZeroIndex = input.findIndex((byte) => byte !== 0);
      if (firstNonZeroIndex === -1) {
        return paddingCharacter.repeat(input.length);
      }
      const requiredLength = Math.floor((input.length - firstNonZeroIndex) * inverseFactor + 1);
      const encoded = new Uint8Array(requiredLength);
      let nextByte = firstNonZeroIndex;
      let remainingBytes = 0;
      while (nextByte !== input.length) {
        let carry = input[nextByte];
        let digit = 0;
        for (
          let steps = requiredLength - 1;
          (carry !== 0 || digit < remainingBytes) && steps !== -1;
          // eslint-disable-next-line no-plusplus
          steps--, digit++
        ) {
          carry += Math.floor(uint8ArrayBase * encoded[steps]);
          encoded[steps] = Math.floor(carry % base);
          carry = Math.floor(carry / base);
        }
        remainingBytes = digit;
        nextByte++;
      }
      const firstNonZeroResultDigit = encoded.findIndex((value) => value !== 0);
      const padding = paddingCharacter.repeat(firstNonZeroIndex);
      return encoded.slice(firstNonZeroResultDigit).reduce((all, digit) => all + alphabet.charAt(digit), padding);
    }
  };
};
var bitcoinBase58Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var base58 = createBaseConverter(bitcoinBase58Alphabet);
var base58ToBin = base58.decode;
var binToBase58 = base58.encode;

// node_modules/@bitauth/libauth/build/lib/format/base64.js
var import_dist4 = __toESM(require_dist(), 1);
var import_dist5 = __toESM(require_dist2(), 1);
var import_dist6 = __toESM(require_dist3(), 1);
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var base64GroupLength = 4;
var nonBase64Chars = new RegExp(`[^${chars}=]`, "u");
var isBase64 = (maybeBase64) => maybeBase64.length % base64GroupLength === 0 && !nonBase64Chars.test(maybeBase64);
var base64ToBin = (validBase64) => {
  const lookup = new Uint8Array(123);
  for (let i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
  }
  const bufferLengthEstimate = validBase64.length * 0.75;
  const stringLength = validBase64.length;
  const bufferLength = validBase64[validBase64.length - 1] === "=" ? validBase64[validBase64.length - 2] === "=" ? bufferLengthEstimate - 2 : bufferLengthEstimate - 1 : bufferLengthEstimate;
  const buffer = new ArrayBuffer(bufferLength);
  const bytes = new Uint8Array(buffer);
  let p = 0;
  for (let i = 0; i < stringLength; i += 4) {
    const encoded1 = lookup[validBase64.charCodeAt(i)];
    const encoded2 = lookup[validBase64.charCodeAt(i + 1)];
    const encoded3 = lookup[validBase64.charCodeAt(i + 2)];
    const encoded4 = lookup[validBase64.charCodeAt(i + 3)];
    bytes[p++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return bytes;
};
var binToBase64 = (bytes) => {
  let result = "";
  for (let i = 0; i < bytes.length; i += 3) {
    result += chars[bytes[i] >> 2];
    result += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
    result += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
    result += chars[bytes[i + 2] & 63];
  }
  const padded = bytes.length % 3 === 2 ? `${result.substring(0, result.length - 1)}=` : bytes.length % 3 === 1 ? `${result.substring(0, result.length - 2)}==` : result;
  return padded;
};

// node_modules/@bitauth/libauth/build/lib/format/bin-string.js
var import_dist10 = __toESM(require_dist(), 1);
var import_dist11 = __toESM(require_dist2(), 1);
var import_dist12 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/format/hex.js
var import_dist7 = __toESM(require_dist(), 1);
var import_dist8 = __toESM(require_dist2(), 1);
var import_dist9 = __toESM(require_dist3(), 1);
var range = (length, begin = 0) => Array.from({ length }, (_2, index2) => begin + index2);
var splitEvery = (input, chunkLength) => range(Math.ceil(input.length / chunkLength)).map((index2) => index2 * chunkLength).map((begin) => input.slice(begin, begin + chunkLength));
var hexByteWidth = 2;
var hexadecimal = 16;
var hexToBin = (validHex) => Uint8Array.from(splitEvery(validHex, hexByteWidth).map((byte) => parseInt(byte, hexadecimal)));
var isHex = (maybeHex) => maybeHex.length % hexByteWidth === 0 && !/[^a-fA-F0-9]/u.test(maybeHex);
var binToHex = (bytes) => bytes.reduce((str, byte) => str + byte.toString(hexadecimal).padStart(hexByteWidth, "0"), "");
var swapEndianness = (validHex) => binToHex(hexToBin(validHex).reverse());
var flattenBinArray = (array) => {
  const totalLength = array.reduce((total, bin) => total + bin.length, 0);
  const flattened = new Uint8Array(totalLength);
  array.reduce((index2, bin) => {
    flattened.set(bin, index2);
    return index2 + bin.length;
  }, 0);
  return flattened;
};
var binsAreEqual = (a, b) => {
  if (a.length !== b.length) {
    return false;
  }
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
};

// node_modules/@bitauth/libauth/build/lib/format/bin-string.js
var binaryByteWidth = 8;
var binary = 2;
var binStringToBin = (binaryDigits) => Uint8Array.from(splitEvery(binaryDigits, binaryByteWidth).map((byteString) => parseInt(byteString, binary)));
var binToBinString = (bytes) => bytes.reduce((str, byte) => str + byte.toString(binary).padStart(binaryByteWidth, "0"), "");
var isBinString = (maybeBinString) => maybeBinString.length % binaryByteWidth === 0 && !/[^01]/u.test(maybeBinString);

// node_modules/@bitauth/libauth/build/lib/format/error.js
var import_dist13 = __toESM(require_dist(), 1);
var import_dist14 = __toESM(require_dist2(), 1);
var import_dist15 = __toESM(require_dist3(), 1);
var formatError = (errorType, errorDetails) => `${errorType}${errorDetails === void 0 ? "" : ` ${errorDetails}`}`;
var unknownValue = (value, message = `Received an unknown value: ${String(value)}. This should have been caught by TypeScript - are your types correct?`) => {
  throw new Error(message);
};

// node_modules/@bitauth/libauth/build/lib/format/log.js
var import_dist16 = __toESM(require_dist(), 1);
var import_dist17 = __toESM(require_dist2(), 1);
var import_dist18 = __toESM(require_dist3(), 1);
var defaultStringifySpacing = 2;
var stringify = (value, spacing = defaultStringifySpacing) => JSON.stringify(
  value,
  // eslint-disable-next-line complexity
  (_2, item) => {
    const type = typeof item;
    const name = typeof item === "object" && item !== null ? item.constructor.name : type;
    switch (name) {
      case "Uint8Array":
        return `<Uint8Array: 0x${binToHex(item)}>`;
      case "bigint":
        return `<bigint: ${item.toString()}n>`;
      case "function":
      case "symbol":
        return `<${name}: ${item.toString()}>`;
      default:
        return item;
    }
  },
  spacing
);
var sortObjectKeys = (objectOrArray) => {
  if (Array.isArray(objectOrArray)) {
    return objectOrArray.map(sortObjectKeys);
  }
  if (typeof objectOrArray !== "object" || objectOrArray === null || objectOrArray.constructor.name !== "Object") {
    return objectOrArray;
  }
  const keys = Object.keys(objectOrArray).sort((a, b) => a.localeCompare(b, "en"));
  return keys.reduce((all, key) => ({
    ...all,
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    [key]: sortObjectKeys(objectOrArray[key])
  }), {});
};
var uint8ArrayRegex = /"<Uint8Array: 0x(?<hex>[0-9a-f]*)>"/gu;
var bigIntRegex = /"<bigint: (?<bigint>[0-9]*)n>"/gu;
var stringifyTestVector = (value, alphabetize = true) => {
  const stringified = alphabetize ? stringify(sortObjectKeys(value)) : stringify(value);
  return stringified.replace(uint8ArrayRegex, "hexToBin('$1')").replace(bigIntRegex, "$1n");
};

// node_modules/@bitauth/libauth/build/lib/format/number.js
var import_dist19 = __toESM(require_dist(), 1);
var import_dist20 = __toESM(require_dist2(), 1);
var import_dist21 = __toESM(require_dist3(), 1);
var numberToBinUintLE = (value) => {
  const baseUint8Array = 256;
  const result = [];
  let remaining = value;
  while (remaining >= baseUint8Array) {
    result.push(remaining % baseUint8Array);
    remaining = Math.floor(remaining / baseUint8Array);
  }
  if (remaining > 0)
    result.push(remaining);
  return Uint8Array.from(result);
};
var binToFixedLength = (bin, bytes) => {
  const fixedBytes = new Uint8Array(bytes);
  const maxValue = 255;
  bin.length > bytes ? fixedBytes.fill(maxValue) : fixedBytes.set(bin);
  return fixedBytes;
};
var numberToBinUint16LEClamped = (value) => {
  const uint16 = 2;
  return binToFixedLength(numberToBinUintLE(value), uint16);
};
var numberToBinUint32LEClamped = (value) => {
  const uint32 = 4;
  return binToFixedLength(numberToBinUintLE(value), uint32);
};
var numberToBinUint16LE = (value) => {
  const uint16Length = 2;
  const bin = new Uint8Array(uint16Length);
  const writeAsLittleEndian = true;
  const view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
  view.setUint16(0, value, writeAsLittleEndian);
  return bin;
};
var numberToBinInt16LE = (value) => {
  const int16Length = 2;
  const bin = new Uint8Array(int16Length);
  const writeAsLittleEndian = true;
  const view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
  view.setInt16(0, value, writeAsLittleEndian);
  return bin;
};
var numberToBinInt32LE = (value) => {
  const int32Length = 4;
  const bin = new Uint8Array(int32Length);
  const writeAsLittleEndian = true;
  const view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
  view.setInt32(0, value, writeAsLittleEndian);
  return bin;
};
var binToNumberInt16LE = (bin) => {
  const view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
  const readAsLittleEndian = true;
  return view.getInt16(0, readAsLittleEndian);
};
var binToNumberInt32LE = (bin) => {
  const view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
  const readAsLittleEndian = true;
  return view.getInt32(0, readAsLittleEndian);
};
var numberToBinUint16BE = (value) => {
  const uint16Length = 2;
  const bin = new Uint8Array(uint16Length);
  const writeAsLittleEndian = false;
  const view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
  view.setUint16(0, value, writeAsLittleEndian);
  return bin;
};
var numberToBinUint32LE = (value) => {
  const uint32Length = 4;
  const bin = new Uint8Array(uint32Length);
  const writeAsLittleEndian = true;
  const view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
  view.setUint32(0, value, writeAsLittleEndian);
  return bin;
};
var numberToBinUint32BE = (value) => {
  const uint32Length = 4;
  const bin = new Uint8Array(uint32Length);
  const writeAsLittleEndian = false;
  const view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
  view.setUint32(0, value, writeAsLittleEndian);
  return bin;
};
var bigIntToBinUintLE = (value) => {
  const baseUint8Array = 256;
  const base = BigInt(baseUint8Array);
  const result = [];
  let remaining = value;
  while (remaining >= base) {
    result.push(Number(remaining % base));
    remaining /= base;
  }
  if (remaining > 0n)
    result.push(Number(remaining));
  return Uint8Array.from(result.length > 0 ? result : [0]);
};
var bigIntToBinUint64LEClamped = (value) => {
  const uint64 = 8;
  return binToFixedLength(bigIntToBinUintLE(value), uint64);
};
var bigIntToBinUint64LE = (value) => {
  const uint64LengthInBits = 64;
  const valueAsUint64 = BigInt.asUintN(uint64LengthInBits, value);
  const fixedLengthBin = bigIntToBinUint64LEClamped(valueAsUint64);
  return fixedLengthBin;
};
var numberToBinInt32TwosCompliment = (value) => {
  const bytes = 4;
  const bitsInAByte = 8;
  const bin = new Uint8Array(bytes);
  for (let index2 = 0; index2 < bytes; index2++) {
    bin[index2] = value;
    value >>>= bitsInAByte;
  }
  return bin;
};
var binToNumberUintLE = (bin, bytes = bin.length) => {
  const base = 2;
  const bitsInAByte = 8;
  if (bin.length !== bytes) {
    throw new TypeError(`Bin length must be ${bytes}.`);
  }
  return new Uint8Array(bin.buffer, bin.byteOffset, bin.length).reduce((accumulated, byte, i) => accumulated + byte * base ** (bitsInAByte * i), 0);
};
var binToNumberUint16LE = (bin) => {
  const view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
  const readAsLittleEndian = true;
  return view.getUint16(0, readAsLittleEndian);
};
var binToNumberUint32LE = (bin) => {
  const view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
  const readAsLittleEndian = true;
  return view.getUint32(0, readAsLittleEndian);
};
var binToBigIntUintBE = (bin, bytes = bin.length) => {
  const bitsInAByte = 8;
  const shift = BigInt(bitsInAByte);
  if (bin.length !== bytes) {
    throw new TypeError(`Bin length must be ${bytes}.`);
  }
  return new Uint8Array(bin.buffer, bin.byteOffset, bin.length).reduce(
    // eslint-disable-next-line no-bitwise
    (accumulated, byte) => accumulated << shift | BigInt(byte),
    0n
  );
};
var binToBigIntUint256BE = (bin) => {
  const uint256Bytes = 32;
  return binToBigIntUintBE(bin, uint256Bytes);
};
var bigIntToBinUint256BEClamped = (value) => {
  const uint256Bytes = 32;
  return binToFixedLength(bigIntToBinUintLE(value), uint256Bytes).reverse();
};
var binToBigIntUintLE = (bin, bytes = bin.length) => {
  const bitsInAByte = 8;
  if (bin.length !== bytes) {
    throw new TypeError(`Bin length must be ${bytes}.`);
  }
  return new Uint8Array(bin.buffer, bin.byteOffset, bin.length).reduceRight(
    // eslint-disable-next-line no-bitwise
    (accumulated, byte) => accumulated << BigInt(bitsInAByte) | BigInt(byte),
    0n
  );
};
var binToBigIntUint64LE = (bin) => {
  const uint64LengthInBytes = 8;
  const truncatedBin = bin.length > uint64LengthInBytes ? bin.slice(0, uint64LengthInBytes) : bin;
  return binToBigIntUintLE(truncatedBin, uint64LengthInBytes);
};
var binToValueSatoshis = binToBigIntUint64LE;
var valueSatoshisToBin = bigIntToBinUint64LE;
var compactSizePrefixToSize = (firstByte) => {
  switch (firstByte) {
    case 253:
      return 2 + 1;
    case 254:
      return 4 + 1;
    case 255:
      return 8 + 1;
    default:
      return 1;
  }
};
var CompactSizeError;
(function(CompactSizeError2) {
  CompactSizeError2["noPrefix"] = "Error reading CompactSize: requires at least one byte.";
  CompactSizeError2["insufficientBytes"] = "Error reading CompactSize: insufficient bytes.";
  CompactSizeError2["nonMinimal"] = "Error reading CompactSize: CompactSize is not minimally encoded.";
  CompactSizeError2["excessiveBytes"] = "Error decoding CompactSize: unexpected bytes after CompactSize.";
})(CompactSizeError || (CompactSizeError = {}));
var readCompactSize = (position) => {
  const { bin, index: index2 } = position;
  const prefix = bin[index2];
  if (prefix === void 0) {
    return formatError(CompactSizeError.noPrefix);
  }
  const bytes = compactSizePrefixToSize(prefix);
  if (bin.length - index2 < bytes) {
    return formatError(CompactSizeError.insufficientBytes, `CompactSize prefix ${prefix} requires at least ${bytes} bytes. Remaining bytes: ${bin.length - index2}`);
  }
  const hasPrefix = bytes !== 1;
  const contents = hasPrefix ? bin.subarray(index2 + 1, index2 + bytes) : bin.subarray(index2, index2 + bytes);
  return {
    position: { bin, index: index2 + bytes },
    result: binToBigIntUintLE(contents)
  };
};
var bigIntToCompactSize = (value) => value <= BigInt(
  252
  /* CompactSize.uint8MaxValue */
) ? Uint8Array.of(Number(value)) : value <= BigInt(
  65535
  /* CompactSize.uint16MaxValue */
) ? Uint8Array.from([
  253,
  ...numberToBinUint16LE(Number(value))
]) : value <= BigInt(
  4294967295
  /* CompactSize.uint32MaxValue */
) ? Uint8Array.from([
  254,
  ...numberToBinUint32LE(Number(value))
]) : Uint8Array.from([
  255,
  ...bigIntToBinUint64LE(value)
]);
var readCompactSizeMinimal = (position) => {
  const read = readCompactSize(position);
  if (typeof read === "string") {
    return read;
  }
  const readLength = read.position.index - position.index;
  const canonicalEncoding = bigIntToCompactSize(read.result);
  if (readLength !== canonicalEncoding.length) {
    return formatError(CompactSizeError.nonMinimal, `Value: ${read.result.toString()}, encoded length: ${readLength}, canonical length: ${canonicalEncoding.length}`);
  }
  return read;
};
var compactSizeToBigInt = (bin) => {
  const read = readCompactSizeMinimal({ bin, index: 0 });
  if (typeof read === "string") {
    return read;
  }
  if (read.position.index !== bin.length) {
    return formatError(CompactSizeError.excessiveBytes, `CompactSize ends at index ${read.position.index}, but input includes ${bin.length} bytes.`);
  }
  return read.result;
};
var int32SignedToUnsigned = (int32) => (
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  Uint32Array.from(Int32Array.of(int32))[0]
);
var int32UnsignedToSigned = (int32) => (
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  Int32Array.from(Uint32Array.of(int32))[0]
);

// node_modules/@bitauth/libauth/build/lib/format/read.js
var import_dist22 = __toESM(require_dist(), 1);
var import_dist23 = __toESM(require_dist2(), 1);
var import_dist24 = __toESM(require_dist3(), 1);
var readMultiple = (position, readFunctions) => {
  let nextPosition = position;
  const results = [];
  for (const readFunction of readFunctions) {
    const out = readFunction(nextPosition);
    if (typeof out === "string") {
      return out;
    }
    results.push(out.result);
    nextPosition = out.position;
  }
  return {
    position: nextPosition,
    result: results
  };
};
var ReadItemCountError;
(function(ReadItemCountError2) {
  ReadItemCountError2["itemCount"] = "Error reading item count.";
  ReadItemCountError2["item"] = "Error reading item.";
})(ReadItemCountError || (ReadItemCountError = {}));
var readItemCount = (position, readFunction) => {
  const countRead = readCompactSizeMinimal(position);
  if (typeof countRead === "string") {
    return formatError(ReadItemCountError.itemCount, countRead);
  }
  let nextPosition = countRead.position;
  const result = [];
  for (let remaining = Number(countRead.result); remaining > 0; remaining--) {
    const read = readFunction(nextPosition);
    if (typeof read === "string") {
      return formatError(ReadItemCountError.item, read);
    }
    result.push(read.result);
    nextPosition = read.position;
  }
  return { position: nextPosition, result };
};

// node_modules/@bitauth/libauth/build/lib/format/time.js
var import_dist25 = __toESM(require_dist(), 1);
var import_dist26 = __toESM(require_dist2(), 1);
var import_dist27 = __toESM(require_dist3(), 1);
var msPerLocktimeSecond = 1e3;
var minimumLocktimeTimestamp = 5e8;
var maximumLocktimeTimestamp = 4294967295;
var minimumLocktimeDate = new Date(minimumLocktimeTimestamp * msPerLocktimeSecond);
var maximumLocktimeDate = new Date(maximumLocktimeTimestamp * msPerLocktimeSecond);
var LocktimeError;
(function(LocktimeError2) {
  LocktimeError2["dateOutOfRange"] = "The provided Date is outside of the range that can be encoded in locktime.";
  LocktimeError2["locktimeOutOfRange"] = "The provided locktime is outside of the range that can be encoded as a Date (greater than or equal to 500000000 and less than or equal to 4294967295).";
  LocktimeError2["incorrectLength"] = "The provided locktime is not the correct length (4 bytes).";
})(LocktimeError || (LocktimeError = {}));
var dateToLocktime = (date) => date < minimumLocktimeDate || date > maximumLocktimeDate ? LocktimeError.dateOutOfRange : Math.round(date.getTime() / msPerLocktimeSecond);
var locktimeToDate = (locktime) => locktime < minimumLocktimeTimestamp || locktime > maximumLocktimeTimestamp ? LocktimeError.locktimeOutOfRange : new Date(locktime * msPerLocktimeSecond);
var dateToLocktimeBin = (date) => {
  const result = dateToLocktime(date);
  return typeof result === "string" ? result : numberToBinUint32LE(result);
};
var locktimeByteLength = 4;
var decodeLocktime = (bin) => {
  if (bin.length !== locktimeByteLength)
    return LocktimeError.incorrectLength;
  const parsed = binToNumberUint32LE(bin);
  return parsed >= minimumLocktimeTimestamp ? new Date(parsed * msPerLocktimeSecond) : parsed;
};

// node_modules/@bitauth/libauth/build/lib/format/type-utils.js
var import_dist28 = __toESM(require_dist(), 1);
var import_dist29 = __toESM(require_dist2(), 1);
var import_dist30 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/format/utf8.js
var import_dist31 = __toESM(require_dist(), 1);
var import_dist32 = __toESM(require_dist2(), 1);
var import_dist33 = __toESM(require_dist3(), 1);
var utf8Encoder = new TextEncoder();
var utf8ToBin = (utf8) => utf8Encoder.encode(utf8);
var utf8Decoder = new TextDecoder();
var binToUtf8 = (bytes) => utf8Decoder.decode(bytes);

// node_modules/@bitauth/libauth/build/lib/bin/bin.js
var import_dist61 = __toESM(require_dist(), 1);
var import_dist62 = __toESM(require_dist2(), 1);
var import_dist63 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/bin/hashes.js
var import_dist37 = __toESM(require_dist(), 1);
var import_dist38 = __toESM(require_dist2(), 1);
var import_dist39 = __toESM(require_dist3(), 1);
var instantiateRustWasm = async (webassemblyBytes, expectedImportModuleName, hashExportName, initExportName, updateExportName, finalExportName) => {
  const wasm = (await WebAssembly.instantiate(webassemblyBytes, {
    [expectedImportModuleName]: {
      /**
       * This would only be called in cases where a `__wbindgen_malloc` failed.
       * Since `__wbindgen_malloc` isn't exposed to consumers, this error
       * can only be encountered if the code below is broken.
       */
      // eslint-disable-next-line camelcase, @typescript-eslint/naming-convention
      __wbindgen_throw: (
        /* istanbul ignore next */
        (ptr, len) => {
          throw new Error(
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            Array.from(getUint8Memory().subarray(ptr, ptr + len)).map((num) => String.fromCharCode(num)).join("")
          );
        }
      )
    }
  })).instance.exports;
  let cachedUint8Memory;
  let cachedUint32Memory;
  let cachedGlobalArgumentPtr;
  const globalArgumentPtr = () => {
    if (cachedGlobalArgumentPtr === void 0) {
      cachedGlobalArgumentPtr = wasm.__wbindgen_global_argument_ptr();
    }
    return cachedGlobalArgumentPtr;
  };
  function getUint8Memory() {
    if (cachedUint8Memory === void 0 || cachedUint8Memory.buffer !== wasm.memory.buffer) {
      cachedUint8Memory = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8Memory;
  }
  const getUint32Memory = () => {
    if (cachedUint32Memory === void 0 || cachedUint32Memory.buffer !== wasm.memory.buffer) {
      cachedUint32Memory = new Uint32Array(wasm.memory.buffer);
    }
    return cachedUint32Memory;
  };
  const passArray8ToWasm = (array) => {
    const ptr = wasm.__wbindgen_malloc(array.length);
    getUint8Memory().set(array, ptr);
    return [ptr, array.length];
  };
  const getArrayU8FromWasm = (ptr, len) => getUint8Memory().subarray(ptr, ptr + len);
  const hash = (input) => {
    const [ptr0, len0] = passArray8ToWasm(input);
    const retPtr = globalArgumentPtr();
    try {
      wasm[hashExportName](retPtr, ptr0, len0);
      const mem = getUint32Memory();
      const ptr = mem[retPtr / 4];
      const len = mem[retPtr / 4 + 1];
      const realRet = getArrayU8FromWasm(ptr, len).slice();
      wasm.__wbindgen_free(ptr, len);
      return realRet;
    } finally {
      wasm.__wbindgen_free(ptr0, len0);
    }
  };
  const init = () => {
    const retPtr = globalArgumentPtr();
    wasm[initExportName](retPtr);
    const mem = getUint32Memory();
    const ptr = mem[retPtr / 4];
    const len = mem[retPtr / 4 + 1];
    const realRet = getArrayU8FromWasm(ptr, len).slice();
    wasm.__wbindgen_free(ptr, len);
    return realRet;
  };
  const update = (rawState, input) => {
    const [ptr0, len0] = passArray8ToWasm(rawState);
    const [ptr1, len1] = passArray8ToWasm(input);
    const retPtr = globalArgumentPtr();
    try {
      wasm[updateExportName](retPtr, ptr0, len0, ptr1, len1);
      const mem = getUint32Memory();
      const ptr = mem[retPtr / 4];
      const len = mem[retPtr / 4 + 1];
      const realRet = getArrayU8FromWasm(ptr, len).slice();
      wasm.__wbindgen_free(ptr, len);
      return realRet;
    } finally {
      rawState.set(getUint8Memory().subarray(ptr0 / 1, ptr0 / 1 + len0));
      wasm.__wbindgen_free(ptr0, len0);
      wasm.__wbindgen_free(ptr1, len1);
    }
  };
  const final = (rawState) => {
    const [ptr0, len0] = passArray8ToWasm(rawState);
    const retPtr = globalArgumentPtr();
    try {
      wasm[finalExportName](retPtr, ptr0, len0);
      const mem = getUint32Memory();
      const ptr = mem[retPtr / 4];
      const len = mem[retPtr / 4 + 1];
      const realRet = getArrayU8FromWasm(ptr, len).slice();
      wasm.__wbindgen_free(ptr, len);
      return realRet;
    } finally {
      rawState.set(getUint8Memory().subarray(ptr0 / 1, ptr0 / 1 + len0));
      wasm.__wbindgen_free(ptr0, len0);
    }
  };
  return {
    final,
    hash,
    init,
    update
  };
};

// node_modules/@bitauth/libauth/build/lib/bin/ripemd160/ripemd160.base64.js
var import_dist40 = __toESM(require_dist(), 1);
var import_dist41 = __toESM(require_dist2(), 1);
var import_dist42 = __toESM(require_dist3(), 1);
var ripemd160Base64Bytes = "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AgQMBQsgAEH8EigCACACaiICQQFyNgIEQYQTIAA2AgBB/BIgAjYCACAAIAJqIAI2AgAMBAsgAxAgDAELQewPQewPKAIAQX4gAUEDdndxNgIACyAEIAJqIQIgAyAEaiEDCyADIAMoAgRBfnE2AgQgACACQQFyNgIEIAAgAmogAjYCAAJ/AkAgAkH/AU0EQCACQQN2IgFBA3RB9A9qIQJB7A8oAgAiA0EBIAFBH3F0IgFxRQ0BIAJBCGohAyACKAIIDAILIAAgAhAhDAILQewPIAMgAXI2AgAgAkEIaiEDIAILIQEgAyAANgIAIAEgADYCDCAAIAI2AgwgACABNgIICyAFQQhqDwtBgBMgACACayIBNgIAQYgTQYgTKAIAIgAgAmoiAzYCACADIAFBAXI2AgQgACACQQNyNgIEIABBCGoLpQEBAn9BAiEFAkACQAJAAkACQCAAKAIEIgYgAWsgAk8NACABIAJqIgIgAUkhAQJAIAQEQEEAIQUgAQ0CIAZBAXQiASACIAIgAUkbIQIMAQtBACEFIAENAQsgAkEASA0AIAZFDQEgACgCACACEBMiAUUNAgwDCyAFDwsgAhAEIgENAQsgAw0BCyABBEAgACABNgIAIABBBGogAjYCAEECDwtBAQ8LAAsIAEGMFBAHAAtmAgF/A34jAEEwayIBJAAgACkCECECIAApAgghAyAAKQIAIQQgAUEUakEANgIAIAEgBDcDGCABQgE3AgQgAUH0DDYCECABIAFBGGo2AgAgASADNwMgIAEgAjcDKCABIAFBIGoQJQALuAEBAX8jAEHgAWsiAyQAIANBOGpBzAgoAgA2AgAgA0EwakHECCkCADcDACADQgA3AyAgA0G8CCkCADcDKCADQTxqQQBBxAAQKhogA0EgaiABIAIQCSADQYABaiADQSBqQeAAECgaIANBCGogA0GAAWoQCiADQSBqIANBCGpBFBADIANBiAFqIANBKGooAgA2AgAgAyADKQMgNwOAASADIANBgAFqEAsgACADKQMANwIAIANB4AFqJAALlwMBBH8jAEFAaiIDJAAgACAAKQMAIAKtfDcDACADIABBCGo2AiggAyADQShqNgIsAkACQAJAAkACQAJAIAAoAhwiBQRAQcAAIAVrIgQgAk0NASADQRhqIAUgBSACaiIEIABBIGoQFiADKAIcIAJHDQUgAygCGCABIAIQKBoMAwsgAiEEDAELIANBMGogASACIAQQFyADQTxqKAIAIQQgAygCOCEBIAMoAjAhBSADKAI0IQIgA0EgaiAAQSBqIgYgACgCHBAYIAIgAygCJEcNBCADKAIgIAUgAhAoGiAAQRxqQQA2AgAgA0EsaiAGEBkLIANBPGohAiADQThqIQUCQANAIARBP00NASADQTBqIAEgBEHAABAXIAIoAgAhBCAFKAIAIQEgA0EIakEAQcAAIAMoAjAgAygCNBAaIANBLGogAygCCBAZDAALAAsgA0EQaiAAQSBqIAQQGyADKAIUIARHDQEgAygCECABIAQQKBoLIABBHGogBDYCACADQUBrJAAPC0H0ExAHAAtB9BMQBwALQfQTEAcAC+MCAgR/AX4jAEFAaiICJAAgAiABQQhqIgU2AiQgASkDACEGIAEoAhwhAyACIAJBJGo2AigCQCADQT9NBEAgAUEgaiIEIANqQYABOgAAIAEgASgCHEEBaiIDNgIcIAJBGGogBCADEBggAigCGEEAIAIoAhwQKhpBwAAgASgCHGtBB00EQCACQShqIAQQGSACQRBqIAQgAUEcaigCABAbIAIoAhBBACACKAIUECoaCyACQQhqIARBOBAYIAIoAgxBCEcNASACKAIIIAZCA4Y3AAAgAkEoaiAEEBkgAUEcakEANgIAIAJBADYCKEEEIQECQANAIAFBGEYNASACQShqIAFqQQA6AAAgAiACKAIoQQFqNgIoIAFBAWohAQwACwALIAAgBSkAADcAACAAQRBqIAVBEGooAAA2AAAgAEEIaiAFQQhqKQAANwAAIAJBQGskAA8LQcwTIANBwAAQHQALQdwTEAcAC2MBAn8gASgCACECAkACQCABKAIEIgMgASgCCCIBRgRAIAMhAQwBCyADIAFJDQEgAQRAIAIgARATIgINAQALIAIgAxARQQEhAkEAIQELIAAgATYCBCAAIAI2AgAPC0G0ExAHAAuQAQEBfyMAQYABayIBJAAgAUEwakHECCkCADcDACABQThqQcwIKAIANgIAIAFCADcDICABQbwIKQIANwMoIAFBPGpBAEHEABAqGiABQRBqIAFBIGpB4AAQAyABQShqIAFBGGooAgA2AgAgASABKQMQNwMgIAFBCGogAUEgahALIAAgASkDCDcCACABQYABaiQAC4YBAQF/IwBB4AFrIgUkACAFQSBqIAEgAhABQeAAECkaIAVBIGogAyAEEAkgBUGAAWogBUEgakHgABAoGiAFQRBqIAVBgAFqQeAAEAMgBUGIAWogBUEYaigCADYCACAFIAUpAxA3A4ABIAVBCGogBUGAAWoQCyAAIAUpAwg3AgAgBUHgAWokAAtuAQF/IwBBkAFrIgMkACADQTBqIAEgAhABQeAAECgaIANBGGogA0EwahAKIANBCGogA0EYakEUEAMgA0E4aiADQRBqKAIANgIAIAMgAykDCDcDMCADIANBMGoQCyAAIAMpAwA3AgAgA0GQAWokAAtKAQF/IwBBEGsiASQAIAFCATcDACABQQA2AgggAUEAIABBAEEAEAVB/wFxQQJGBEAgASgCACEAIAFBEGokACAADwtBgAhBFhAAAAsIACAAIAEQEQsLACABBEAgABAUCwsFAEGQDwvHBQEIfwJAAkACQAJAAkACQCABQb9/Sw0AQRAgAUELakF4cSABQQtJGyECIABBfGoiBigCACIHQXhxIQMCQAJAAkACQCAHQQNxBEAgAEF4aiIIIANqIQUgAyACTw0BQYgTKAIAIAVGDQJBhBMoAgAgBUYNAyAFKAIEIgdBAnENBCAHQXhxIgkgA2oiAyACSQ0EIAMgAmshASAJQf8BSw0HIAUoAgwiBCAFKAIIIgVGDQggBSAENgIMIAQgBTYCCAwJCyACQYACSQ0DIAMgAkEEckkNAyADIAJrQYGACE8NAwwJCyADIAJrIgFBEEkNCCAGIAIgB0EBcXJBAnI2AgAgCCACaiIEIAFBA3I2AgQgBSAFKAIEQQFyNgIEIAQgARAiDAgLQYATKAIAIANqIgMgAk0NASAGIAIgB0EBcXJBAnI2AgBBiBMgCCACaiIBNgIAQYATIAMgAmsiBDYCACABIARBAXI2AgQMBwtB/BIoAgAgA2oiAyACTw0CCyABEAQiAkUNACACIAAgASAGKAIAIgRBeHFBBEEIIARBA3EbayIEIAQgAUsbECghASAAEBQgASEECyAEDwsCQCADIAJrIgFBEEkEQCAGIAdBAXEgA3JBAnI2AgAgCCADaiIBIAEoAgRBAXI2AgRBACEBDAELIAYgAiAHQQFxckECcjYCACAIIAJqIgQgAUEBcjYCBCAIIANqIgIgATYCACACIAIoAgRBfnE2AgQLQYQTIAQ2AgBB/BIgATYCAAwDCyAFECAMAQtB7A9B7A8oAgBBfiAHQQN2d3E2AgALIAFBD00EQCAGIAMgBigCAEEBcXJBAnI2AgAgCCADaiIBIAEoAgRBAXI2AgQMAQsgBiACIAYoAgBBAXFyQQJyNgIAIAggAmoiBCABQQNyNgIEIAggA2oiAiACKAIEQQFyNgIEIAQgARAiIAAPCyAAC+AGAQV/AkAgAEF4aiIBIABBfGooAgAiA0F4cSIAaiECAkACQCADQQFxDQAgA0EDcUUNASABKAIAIgMgAGohAAJAAkBBhBMoAgAgASADayIBRwRAIANB/wFLDQEgASgCDCIEIAEoAggiBUYNAiAFIAQ2AgwgBCAFNgIIDAMLIAIoAgQiA0EDcUEDRw0CQfwSIAA2AgAgAkEEaiADQX5xNgIADAQLIAEQIAwBC0HsD0HsDygCAEF+IANBA3Z3cTYCAAsCQAJ/AkACQAJAAkACQAJAIAIoAgQiA0ECcUUEQEGIEygCACACRg0BQYQTKAIAIAJGDQIgA0F4cSIEIABqIQAgBEH/AUsNAyACKAIMIgQgAigCCCICRg0EIAIgBDYCDCAEIAI2AggMBQsgAkEEaiADQX5xNgIAIAEgAEEBcjYCBCABIABqIAA2AgAMBwtBiBMgATYCAEGAE0GAEygCACAAaiIANgIAIAEgAEEBcjYCBCABQYQTKAIARgRAQfwSQQA2AgBBhBNBADYCAAtBpBMoAgAgAE8NBwJAIABBKUkNAEGUEyEAA0AgACgCACICIAFNBEAgAiAAKAIEaiABSw0CCyAAKAIIIgANAAsLQQAhAUGcEygCACIARQ0EA0AgAUEBaiEBIAAoAggiAA0ACyABQf8fIAFB/x9LGwwFC0GEEyABNgIAQfwSQfwSKAIAIABqIgA2AgAMBwsgAhAgDAELQewPQewPKAIAQX4gA0EDdndxNgIACyABIABBAXI2AgQgASAAaiAANgIAIAFBhBMoAgBHDQJB/BIgADYCAA8LQf8fCyEBQaQTQX82AgBBrBMgATYCAA8LQawTAn8CQAJ/AkAgAEH/AU0EQCAAQQN2IgJBA3RB9A9qIQBB7A8oAgAiA0EBIAJBH3F0IgJxRQ0BIABBCGohAyAAKAIIDAILIAEgABAhQawTQawTKAIAQX9qIgE2AgAgAQ0EQZwTKAIAIgBFDQJBACEBA0AgAUEBaiEBIAAoAggiAA0ACyABQf8fIAFB/x9LGwwDC0HsDyADIAJyNgIAIABBCGohAyAACyECIAMgATYCACACIAE2AgwgASAANgIMIAEgAjYCCA8LQf8fCyIBNgIACw8LIAEgAEEBcjYCBCABIABqIAA2AgAL+ysBIX8gACABKAAsIhkgASgAKCIPIAEoABQiESARIAEoADQiGiAPIBEgASgAHCIUIAEoACQiGyABKAAgIhIgGyABKAAYIhYgFCAZIBYgASgABCITIAAoAhAiH2ogACgCCCIgQQp3IgUgACgCBCIdcyAgIB1zIAAoAgwiBHMgACgCACIhaiABKAAAIhdqQQt3IB9qIhBzakEOdyAEaiIOQQp3IgJqIAEoABAiFSAdQQp3IgdqIAEoAAgiGCAEaiAQIAdzIA5zakEPdyAFaiIDIAJzIAEoAAwiHCAFaiAOIBBBCnciEHMgA3NqQQx3IAdqIg5zakEFdyAQaiIGIA5BCnciCHMgECARaiAOIANBCnciEHMgBnNqQQh3IAJqIg5zakEHdyAQaiICQQp3IgNqIBsgBkEKdyIGaiAQIBRqIA4gBnMgAnNqQQl3IAhqIhAgA3MgCCASaiACIA5BCnciDnMgEHNqQQt3IAZqIgJzakENdyAOaiIGIAJBCnciCHMgDiAPaiACIBBBCnciCXMgBnNqQQ53IANqIgJzakEPdyAJaiIDQQp3IgpqIAJBCnciCyABKAA8IhBqIAggGmogAyALcyAJIAEoADAiDmogAiAGQQp3IgZzIANzakEGdyAIaiICc2pBB3cgBmoiAyACQQp3IghzIAYgASgAOCIBaiACIApzIANzakEJdyALaiIGc2pBCHcgCmoiAiAGcSADQQp3IgkgAkF/c3FyakGZ84nUBWpBB3cgCGoiA0EKdyIKaiAPIAJBCnciC2ogEyAGQQp3IgZqIBogCWogFSAIaiADIAJxIAYgA0F/c3FyakGZ84nUBWpBBncgCWoiAiADcSALIAJBf3NxcmpBmfOJ1AVqQQh3IAZqIgMgAnEgCiADQX9zcXJqQZnzidQFakENdyALaiIGIANxIAJBCnciCCAGQX9zcXJqQZnzidQFakELdyAKaiICIAZxIANBCnciCSACQX9zcXJqQZnzidQFakEJdyAIaiIDQQp3IgpqIBcgAkEKdyILaiAOIAZBCnciBmogHCAJaiAQIAhqIAMgAnEgBiADQX9zcXJqQZnzidQFakEHdyAJaiICIANxIAsgAkF/c3FyakGZ84nUBWpBD3cgBmoiAyACcSAKIANBf3NxcmpBmfOJ1AVqQQd3IAtqIgYgA3EgAkEKdyIIIAZBf3NxcmpBmfOJ1AVqQQx3IApqIgIgBnEgA0EKdyIJIAJBf3NxcmpBmfOJ1AVqQQ93IAhqIgNBCnciCmogGSACQQp3IgtqIAEgBkEKdyIGaiAYIAlqIBEgCGogAyACcSAGIANBf3NxcmpBmfOJ1AVqQQl3IAlqIgIgA3EgCyACQX9zcXJqQZnzidQFakELdyAGaiIDIAJxIAogA0F/c3FyakGZ84nUBWpBB3cgC2oiBiADcSACQQp3IgIgBkF/c3FyakGZ84nUBWpBDXcgCmoiCCAGcSADQQp3IgMgCEF/cyILcXJqQZnzidQFakEMdyACaiIJQQp3IgpqIBUgCEEKdyIIaiABIAZBCnciBmogDyADaiAcIAJqIAkgC3IgBnNqQaHX5/YGakELdyADaiICIAlBf3NyIAhzakGh1+f2BmpBDXcgBmoiAyACQX9zciAKc2pBodfn9gZqQQZ3IAhqIgYgA0F/c3IgAkEKdyICc2pBodfn9gZqQQd3IApqIgggBkF/c3IgA0EKdyIDc2pBodfn9gZqQQ53IAJqIglBCnciCmogGCAIQQp3IgtqIBMgBkEKdyIGaiASIANqIBAgAmogCSAIQX9zciAGc2pBodfn9gZqQQl3IANqIgIgCUF/c3IgC3NqQaHX5/YGakENdyAGaiIDIAJBf3NyIApzakGh1+f2BmpBD3cgC2oiBiADQX9zciACQQp3IgJzakGh1+f2BmpBDncgCmoiCCAGQX9zciADQQp3IgNzakGh1+f2BmpBCHcgAmoiCUEKdyIKaiAZIAhBCnciC2ogGiAGQQp3IgZqIBYgA2ogFyACaiAJIAhBf3NyIAZzakGh1+f2BmpBDXcgA2oiAiAJQX9zciALc2pBodfn9gZqQQZ3IAZqIgMgAkF/c3IgCnNqQaHX5/YGakEFdyALaiIGIANBf3NyIAJBCnciCHNqQaHX5/YGakEMdyAKaiIJIAZBf3NyIANBCnciCnNqQaHX5/YGakEHdyAIaiILQQp3IgJqIBkgCUEKdyIDaiAbIAZBCnciBmogEyAKaiAOIAhqIAsgCUF/c3IgBnNqQaHX5/YGakEFdyAKaiIIIANxIAsgA0F/c3FyakHc+e74eGpBC3cgBmoiBiACcSAIIAJBf3NxcmpB3Pnu+HhqQQx3IANqIgkgCEEKdyIDcSAGIANBf3NxcmpB3Pnu+HhqQQ53IAJqIgogBkEKdyICcSAJIAJBf3NxcmpB3Pnu+HhqQQ93IANqIgtBCnciBmogFSAKQQp3IghqIA4gCUEKdyIJaiASIAJqIBcgA2ogCyAJcSAKIAlBf3NxcmpB3Pnu+HhqQQ53IAJqIgIgCHEgCyAIQX9zcXJqQdz57vh4akEPdyAJaiIDIAZxIAIgBkF/c3FyakHc+e74eGpBCXcgCGoiCSACQQp3IgJxIAMgAkF/c3FyakHc+e74eGpBCHcgBmoiCiADQQp3IgNxIAkgA0F/c3FyakHc+e74eGpBCXcgAmoiC0EKdyIGaiABIApBCnciCGogECAJQQp3IglqIBQgA2ogHCACaiALIAlxIAogCUF/c3FyakHc+e74eGpBDncgA2oiAiAIcSALIAhBf3NxcmpB3Pnu+HhqQQV3IAlqIgMgBnEgAiAGQX9zcXJqQdz57vh4akEGdyAIaiIIIAJBCnciAnEgAyACQX9zcXJqQdz57vh4akEIdyAGaiIJIANBCnciA3EgCCADQX9zcXJqQdz57vh4akEGdyACaiIKQQp3IgtqIBcgCUEKdyIGaiAVIAhBCnciCGogGCADaiAWIAJqIAogCHEgCSAIQX9zcXJqQdz57vh4akEFdyADaiICIAZxIAogBkF/c3FyakHc+e74eGpBDHcgCGoiAyACIAtBf3Nyc2pBzvrPynpqQQl3IAZqIgYgAyACQQp3IgJBf3Nyc2pBzvrPynpqQQ93IAtqIgggBiADQQp3IgNBf3Nyc2pBzvrPynpqQQV3IAJqIglBCnciCmogGCAIQQp3IgtqIA4gBkEKdyIGaiAUIANqIBsgAmogCSAIIAZBf3Nyc2pBzvrPynpqQQt3IANqIgIgCSALQX9zcnNqQc76z8p6akEGdyAGaiIDIAIgCkF/c3JzakHO+s/KempBCHcgC2oiBiADIAJBCnciAkF/c3JzakHO+s/KempBDXcgCmoiCCAGIANBCnciA0F/c3JzakHO+s/KempBDHcgAmoiCUEKdyIKaiASIAhBCnciC2ogHCAGQQp3IgZqIBMgA2ogASACaiAJIAggBkF/c3JzakHO+s/KempBBXcgA2oiAiAJIAtBf3Nyc2pBzvrPynpqQQx3IAZqIgMgAiAKQX9zcnNqQc76z8p6akENdyALaiIGIAMgAkEKdyIIQX9zcnNqQc76z8p6akEOdyAKaiIJIAYgA0EKdyIKQX9zcnNqQc76z8p6akELdyAIaiILQQp3IiIgBGogGyAXIBUgFyAZIBwgEyAQIBcgDiAQIBggISAgIARBf3NyIB1zaiARakHml4qFBWpBCHcgH2oiAkEKdyIDaiAHIBtqIAUgF2ogBCAUaiAfIAIgHSAFQX9zcnNqIAFqQeaXioUFakEJdyAEaiIEIAIgB0F/c3JzakHml4qFBWpBCXcgBWoiBSAEIANBf3Nyc2pB5peKhQVqQQt3IAdqIgcgBSAEQQp3IgRBf3Nyc2pB5peKhQVqQQ13IANqIgIgByAFQQp3IgVBf3Nyc2pB5peKhQVqQQ93IARqIgNBCnciDGogFiACQQp3Ig1qIBogB0EKdyIHaiAVIAVqIBkgBGogAyACIAdBf3Nyc2pB5peKhQVqQQ93IAVqIgQgAyANQX9zcnNqQeaXioUFakEFdyAHaiIFIAQgDEF/c3JzakHml4qFBWpBB3cgDWoiByAFIARBCnciBEF/c3JzakHml4qFBWpBB3cgDGoiAiAHIAVBCnciBUF/c3JzakHml4qFBWpBCHcgBGoiA0EKdyIMaiAcIAJBCnciDWogDyAHQQp3IgdqIBMgBWogEiAEaiADIAIgB0F/c3JzakHml4qFBWpBC3cgBWoiBCADIA1Bf3Nyc2pB5peKhQVqQQ53IAdqIgUgBCAMQX9zcnNqQeaXioUFakEOdyANaiIHIAUgBEEKdyICQX9zcnNqQeaXioUFakEMdyAMaiIDIAcgBUEKdyIMQX9zcnNqQeaXioUFakEGdyACaiINQQp3IgRqIBQgA0EKdyIFaiAcIAdBCnciB2ogGSAMaiAWIAJqIA0gB3EgAyAHQX9zcXJqQaSit+IFakEJdyAMaiICIAVxIA0gBUF/c3FyakGkorfiBWpBDXcgB2oiByAEcSACIARBf3NxcmpBpKK34gVqQQ93IAVqIgMgAkEKdyIFcSAHIAVBf3NxcmpBpKK34gVqQQd3IARqIgwgB0EKdyIEcSADIARBf3NxcmpBpKK34gVqQQx3IAVqIg1BCnciB2ogASAMQQp3IgJqIA8gA0EKdyIDaiARIARqIBogBWogDSADcSAMIANBf3NxcmpBpKK34gVqQQh3IARqIgQgAnEgDSACQX9zcXJqQaSit+IFakEJdyADaiIFIAdxIAQgB0F/c3FyakGkorfiBWpBC3cgAmoiAyAEQQp3IgRxIAUgBEF/c3FyakGkorfiBWpBB3cgB2oiDCAFQQp3IgVxIAMgBUF/c3FyakGkorfiBWpBB3cgBGoiDUEKdyIHaiAbIAxBCnciAmogFSADQQp3IgNqIA4gBWogEiAEaiANIANxIAwgA0F/c3FyakGkorfiBWpBDHcgBWoiBCACcSANIAJBf3NxcmpBpKK34gVqQQd3IANqIgUgB3EgBCAHQX9zcXJqQaSit+IFakEGdyACaiICIARBCnciBHEgBSAEQX9zcXJqQaSit+IFakEPdyAHaiIDIAVBCnciBXEgAiAFQX9zcXJqQaSit+IFakENdyAEaiIMQQp3Ig1qIBMgA0EKdyIeaiARIAJBCnciB2ogECAFaiAYIARqIAwgB3EgAyAHQX9zcXJqQaSit+IFakELdyAFaiIEIAxBf3NyIB5zakHz/cDrBmpBCXcgB2oiBSAEQX9zciANc2pB8/3A6wZqQQd3IB5qIgcgBUF/c3IgBEEKdyIEc2pB8/3A6wZqQQ93IA1qIgIgB0F/c3IgBUEKdyIFc2pB8/3A6wZqQQt3IARqIgNBCnciDGogGyACQQp3Ig1qIBYgB0EKdyIHaiABIAVqIBQgBGogAyACQX9zciAHc2pB8/3A6wZqQQh3IAVqIgQgA0F/c3IgDXNqQfP9wOsGakEGdyAHaiIFIARBf3NyIAxzakHz/cDrBmpBBncgDWoiByAFQX9zciAEQQp3IgRzakHz/cDrBmpBDncgDGoiAiAHQX9zciAFQQp3IgVzakHz/cDrBmpBDHcgBGoiA0EKdyIMaiAPIAJBCnciDWogGCAHQQp3IgdqIA4gBWogEiAEaiADIAJBf3NyIAdzakHz/cDrBmpBDXcgBWoiBCADQX9zciANc2pB8/3A6wZqQQV3IAdqIgUgBEF/c3IgDHNqQfP9wOsGakEOdyANaiIHIAVBf3NyIARBCnciBHNqQfP9wOsGakENdyAMaiICIAdBf3NyIAVBCnciBXNqQfP9wOsGakENdyAEaiIDQQp3IgxqIBYgAkEKdyINaiASIAdBCnciB2ogGiAFaiAVIARqIAMgAkF/c3IgB3NqQfP9wOsGakEHdyAFaiICIANBf3NyIA1zakHz/cDrBmpBBXcgB2oiBCACcSAMIARBf3NxcmpB6e210wdqQQ93IA1qIgUgBHEgAkEKdyICIAVBf3NxcmpB6e210wdqQQV3IAxqIgcgBXEgBEEKdyIDIAdBf3NxcmpB6e210wdqQQh3IAJqIgRBCnciDGogECAHQQp3Ig1qIBkgBUEKdyIeaiAcIANqIBMgAmogBCAHcSAeIARBf3NxcmpB6e210wdqQQt3IANqIgUgBHEgDSAFQX9zcXJqQenttdMHakEOdyAeaiIEIAVxIAwgBEF/c3FyakHp7bXTB2pBDncgDWoiByAEcSAFQQp3IgIgB0F/c3FyakHp7bXTB2pBBncgDGoiBSAHcSAEQQp3IgMgBUF/c3FyakHp7bXTB2pBDncgAmoiBEEKdyIMaiAaIAVBCnciDWogGCAHQQp3IgdqIA4gA2ogESACaiAEIAVxIAcgBEF/c3FyakHp7bXTB2pBBncgA2oiBSAEcSANIAVBf3NxcmpB6e210wdqQQl3IAdqIgQgBXEgDCAEQX9zcXJqQenttdMHakEMdyANaiIHIARxIAVBCnciAiAHQX9zcXJqQenttdMHakEJdyAMaiIFIAdxIARBCnciAyAFQX9zcXJqQenttdMHakEMdyACaiIEQQp3IgwgEGogASAHQQp3Ig1qIA8gA2ogFCACaiAEIAVxIA0gBEF/c3FyakHp7bXTB2pBBXcgA2oiByAEcSAFQQp3IgUgB0F/c3FyakHp7bXTB2pBD3cgDWoiBCAHcSAMIARBf3NxcmpB6e210wdqQQh3IAVqIgIgBEEKdyIDcyAFIA5qIAQgB0EKdyIOcyACc2pBCHcgDGoiBHNqQQV3IA5qIgVBCnciByASaiACQQp3IhIgE2ogDiAPaiAEIBJzIAVzakEMdyADaiIPIAdzIAMgFWogBSAEQQp3IhNzIA9zakEJdyASaiISc2pBDHcgE2oiFSASQQp3Ig5zIBMgEWogEiAPQQp3Ig9zIBVzakEFdyAHaiIRc2pBDncgD2oiEkEKdyITIAFqIBVBCnciASAYaiAPIBRqIBEgAXMgEnNqQQZ3IA5qIg8gE3MgDiAWaiASIBFBCnciEXMgD3NqQQh3IAFqIgFzakENdyARaiIUIAFBCnciEnMgESAaaiABIA9BCnciD3MgFHNqQQZ3IBNqIgFzakEFdyAPaiIRQQp3IhNqNgIIIAAgICAWIAhqIAsgCSAGQQp3IhZBf3Nyc2pBzvrPynpqQQh3IApqIhVBCndqIA8gF2ogASAUQQp3Ig9zIBFzakEPdyASaiIUQQp3IhhqNgIEIAAgHSAQIApqIBUgCyAJQQp3IhdBf3Nyc2pBzvrPynpqQQV3IBZqIhBqIBIgHGogESABQQp3IgFzIBRzakENdyAPaiIRQQp3ajYCACAAIBcgIWogGiAWaiAQIBUgIkF/c3JzakHO+s/KempBBndqIA8gG2ogFCATcyARc2pBC3cgAWoiD2o2AhAgACAXIB9qIBNqIAEgGWogESAYcyAPc2pBC3dqNgIMCzkAAkAgAiABTwRAIAJBwQBPDQEgACACIAFrNgIEIAAgAyABajYCAA8LIAEgAhAcAAsgAkHAABACAAtNAgF/An4jAEEQayIEJAAgBEEIakEAIAMgASACEBogBCkDCCEFIAQgAyACIAEgAhAaIAQpAwAhBiAAIAU3AgAgACAGNwIIIARBEGokAAssAQF/IwBBEGsiAyQAIANBCGogAkHAACABEBYgACADKQMINwIAIANBEGokAAsOACAAKAIAKAIAIAEQFQs3AAJAIAIgAU8EQCAEIAJJDQEgACACIAFrNgIEIAAgAyABajYCAA8LIAEgAhAcAAsgAiAEEAIACysBAX8jAEEQayIDJAAgA0EIakEAIAIgARAWIAAgAykDCDcCACADQRBqJAALfQEBfyMAQTBrIgIkACACIAE2AgQgAiAANgIAIAJBLGpBATYCACACQRRqQQI2AgAgAkEcakECNgIAIAJBATYCJCACQfwUNgIIIAJBAjYCDCACQbwNNgIQIAIgAjYCICACIAJBBGo2AiggAiACQSBqNgIYIAJBCGpBjBUQJQALfAEBfyMAQTBrIgMkACADIAI2AgQgAyABNgIAIANBLGpBATYCACADQRRqQQI2AgAgA0EcakECNgIAIANBATYCJCADQcwUNgIIIANBAjYCDCADQbwNNgIQIAMgA0EEajYCICADIAM2AiggAyADQSBqNgIYIANBCGogABAlAAtQAAJAAkBB2A8oAgBBAUYEQEHcD0HcDygCAEEBaiIANgIAIABBA0kNAQwCC0HYD0KBgICAEDcDAAtB5A8oAgAiAEF/TA0AQeQPIAA2AgALAAs/AQJ/IwBBEGsiASQAAn8gACgCCCICIAINABpBpBQQBwALGiABIAApAgw3AwAgASAAQRRqKQIANwMIIAEQHgALswIBBX8gACgCGCEDAkACQAJAIAAoAgwiAiAARwRAIAAoAggiASACNgIMIAIgATYCCCADDQEMAgsgAEEUaiIBIABBEGogASgCABsiBCgCACIBBEACQANAIAQhBSABIgJBFGoiBCgCACIBBEAgAQ0BDAILIAJBEGohBCACKAIQIgENAAsLIAVBADYCACADDQEMAgtBACECIANFDQELAkAgACgCHCIEQQJ0QfwRaiIBKAIAIABHBEAgA0EQaiADQRRqIAMoAhAgAEYbIAI2AgAgAg0BDAILIAEgAjYCACACRQ0CCyACIAM2AhggACgCECIBBEAgAiABNgIQIAEgAjYCGAsgAEEUaigCACIBRQ0AIAJBFGogATYCACABIAI2AhgLDwtB8A9B8A8oAgBBfiAEd3E2AgALxQIBBH8gAAJ/QQAgAUEIdiIDRQ0AGkEfIgIgAUH///8HSw0AGiABQSYgA2ciAmtBH3F2QQFxQR8gAmtBAXRyCyICNgIcIABCADcCECACQQJ0QfwRaiEDAkACQAJAQfAPKAIAIgRBASACQR9xdCIFcQRAIAMoAgAiBCgCBEF4cSABRw0BIAQhAgwCCyADIAA2AgBB8A8gBCAFcjYCACAAIAM2AhggACAANgIIIAAgADYCDA8LIAFBAEEZIAJBAXZrQR9xIAJBH0YbdCEDA0AgBCADQR12QQRxakEQaiIFKAIAIgJFDQIgA0EBdCEDIAIhBCACKAIEQXhxIAFHDQALCyACKAIIIgMgADYCDCACIAA2AgggACACNgIMIAAgAzYCCCAAQQA2AhgPCyAFIAA2AgAgACAENgIYIAAgADYCDCAAIAA2AggL9QQBBH8gACABaiECAkACQAJAAkACQAJAAkACQCAAKAIEIgNBAXENACADQQNxRQ0BIAAoAgAiAyABaiEBAkACQEGEEygCACAAIANrIgBHBEAgA0H/AUsNASAAKAIMIgQgACgCCCIFRg0CIAUgBDYCDCAEIAU2AggMAwsgAigCBCIDQQNxQQNHDQJB/BIgATYCACACQQRqIANBfnE2AgAgACABQQFyNgIEIAIgATYCAA8LIAAQIAwBC0HsD0HsDygCAEF+IANBA3Z3cTYCAAsCQCACKAIEIgNBAnFFBEBBiBMoAgAgAkYNAUGEEygCACACRg0DIANBeHEiBCABaiEBIARB/wFLDQQgAigCDCIEIAIoAggiAkYNBiACIAQ2AgwgBCACNgIIDAcLIAJBBGogA0F+cTYCACAAIAFBAXI2AgQgACABaiABNgIADAcLQYgTIAA2AgBBgBNBgBMoAgAgAWoiATYCACAAIAFBAXI2AgQgAEGEEygCAEYNAwsPC0GEEyAANgIAQfwSQfwSKAIAIAFqIgE2AgAgACABQQFyNgIEIAAgAWogATYCAA8LIAIQIAwCC0H8EkEANgIAQYQTQQA2AgAPC0HsD0HsDygCAEF+IANBA3Z3cTYCAAsgACABQQFyNgIEIAAgAWogATYCACAAQYQTKAIARw0AQfwSIAE2AgAPCwJ/AkAgAUH/AU0EQCABQQN2IgJBA3RB9A9qIQFB7A8oAgAiA0EBIAJBH3F0IgJxRQ0BIAEoAggMAgsgACABECEPC0HsDyADIAJyNgIAIAELIQIgAUEIaiAANgIAIAIgADYCDCAAIAE2AgwgACACNgIIC9ICAQV/IwBBEGsiAyQAAn8gACgCACgCACICQYCAxABHBEAgAUEcaigCACEEIAEoAhghBSADQQA2AgwCfyACQf8ATQRAIAMgAjoADEEBDAELIAJB/w9NBEAgAyACQT9xQYABcjoADSADIAJBBnZBH3FBwAFyOgAMQQIMAQsgAkH//wNNBEAgAyACQT9xQYABcjoADiADIAJBBnZBP3FBgAFyOgANIAMgAkEMdkEPcUHgAXI6AAxBAwwBCyADIAJBEnZB8AFyOgAMIAMgAkE/cUGAAXI6AA8gAyACQQx2QT9xQYABcjoADSADIAJBBnZBP3FBgAFyOgAOQQQLIQZBASICIAUgA0EMaiAGIAQoAgwRBQANARoLIAAoAgQtAAAEQCABKAIYIAAoAggiACgCACAAKAIEIAFBHGooAgAoAgwRBQAMAQtBAAshAiADQRBqJAAgAguqCAEJfyMAQdAAayICJABBJyEDAkAgACgCACIAQZDOAE8EQANAIAJBCWogA2oiBUF8aiAAIABBkM4AbiIEQfCxf2xqIgdB5ABuIgZBAXRBqgtqLwAAOwAAIAVBfmogByAGQZx/bGpBAXRBqgtqLwAAOwAAIANBfGohAyAAQf/B1y9LIQUgBCEAIAUNAAsMAQsgACEECwJAIARB5ABOBEAgAkEJaiADQX5qIgNqIAQgBEHkAG4iAEGcf2xqQQF0QaoLai8AADsAAAwBCyAEIQALAkAgAEEJTARAIAJBCWogA0F/aiIDaiIIIABBMGo6AAAMAQsgAkEJaiADQX5qIgNqIgggAEEBdEGqC2ovAAA7AAALIAJBADYCNCACQfQMNgIwIAJBgIDEADYCOEEnIANrIgYhAyABKAIAIgBBAXEEQCACQSs2AjggBkEBaiEDCyACIABBAnZBAXE6AD8gASgCCCEEIAIgAkE/ajYCRCACIAJBOGo2AkAgAiACQTBqNgJIAn8CQAJAAn8CQAJAAkACQAJAAkACQCAEQQFGBEAgAUEMaigCACIEIANNDQEgAEEIcQ0CIAQgA2shBUEBIAEtADAiACAAQQNGG0EDcSIARQ0DIABBAkYNBAwFCyACQUBrIAEQIw0IIAEoAhggCCAGIAFBHGooAgAoAgwRBQAMCgsgAkFAayABECMNByABKAIYIAggBiABQRxqKAIAKAIMEQUADAkLIAFBAToAMCABQTA2AgQgAkFAayABECMNBiACQTA2AkwgBCADayEDIAEoAhghBEF/IQAgAUEcaigCACIHQQxqIQUDQCAAQQFqIgAgA08NBCAEIAJBzABqQQEgBSgCABEFAEUNAAsMBgsgBSEJQQAhBQwBCyAFQQFqQQF2IQkgBUEBdiEFCyACQQA2AkwgASgCBCIAQf8ATQRAIAIgADoATEEBDAMLIABB/w9LDQEgAiAAQT9xQYABcjoATSACIABBBnZBH3FBwAFyOgBMQQIMAgsgBCAIIAYgB0EMaigCABEFAA0CDAMLIABB//8DTQRAIAIgAEE/cUGAAXI6AE4gAiAAQQZ2QT9xQYABcjoATSACIABBDHZBD3FB4AFyOgBMQQMMAQsgAiAAQRJ2QfABcjoATCACIABBP3FBgAFyOgBPIAIgAEEMdkE/cUGAAXI6AE0gAiAAQQZ2QT9xQYABcjoATkEECyEEIAEoAhghA0F/IQAgAUEcaigCACIKQQxqIQcCQANAIABBAWoiACAFTw0BIAMgAkHMAGogBCAHKAIAEQUARQ0ACwwBCyACQUBrIAEQIw0AIAMgCCAGIApBDGooAgAiBREFAA0AQX8hAANAIABBAWoiACAJTw0CIAMgAkHMAGogBCAFEQUARQ0ACwtBAQwBC0EACyEAIAJB0ABqJAAgAAtGAgF/AX4jAEEgayICJAAgASkCACEDIAJBFGogASkCCDcCACACQbwUNgIEIAJB9Aw2AgAgAiAANgIIIAIgAzcCDCACEB8ACwMAAQsNAEKIspSTmIGVjP8ACzMBAX8gAgRAIAAhAwNAIAMgAS0AADoAACABQQFqIQEgA0EBaiEDIAJBf2oiAg0ACwsgAAtnAQF/AkAgASAASQRAIAJFDQEDQCAAIAJqQX9qIAEgAmpBf2otAAA6AAAgAkF/aiICDQALDAELIAJFDQAgACEDA0AgAyABLQAAOgAAIAFBAWohASADQQFqIQMgAkF/aiICDQALCyAACykBAX8gAgRAIAAhAwNAIAMgAToAACADQQFqIQMgAkF/aiICDQALCyAACwuWCQIAQYAIC4oHaW52YWxpZCBtYWxsb2MgcmVxdWVzdFRyaWVkIHRvIHNocmluayB0byBhIGxhcmdlciBjYXBhY2l0eQAAASNFZ4mrze/+3LqYdlQyEPDh0sNhc3NlcnRpb24gZmFpbGVkOiA4ID09IGRzdC5sZW4oKS9yb290Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2J5dGUtdG9vbHMtMC4yLjAvc3JjL3dyaXRlX3NpbmdsZS5ycwAAAAAAAC9yb290Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2Jsb2NrLWJ1ZmZlci0wLjMuMy9zcmMvbGliLnJzZGVzdGluYXRpb24gYW5kIHNvdXJjZSBzbGljZXMgaGF2ZSBkaWZmZXJlbnQgbGVuZ3RocwAAAAAAAGNhcGFjaXR5IG92ZXJmbG93Y2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZWxpYmNvcmUvb3B0aW9uLnJzMDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTkAAABpbmRleCBvdXQgb2YgYm91bmRzOiB0aGUgbGVuIGlzICBidXQgdGhlIGluZGV4IGlzIGxpYmNvcmUvc2xpY2UvbW9kLnJzAAEAAAAAAAAAIAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAwAAAAEAAAABAAAAIAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAwAAAGluZGV4ICBvdXQgb2YgcmFuZ2UgZm9yIHNsaWNlIG9mIGxlbmd0aCBzbGljZSBpbmRleCBzdGFydHMgYXQgIGJ1dCBlbmRzIGF0IGludGVybmFsIGVycm9yOiBlbnRlcmVkIHVucmVhY2hhYmxlIGNvZGVsaWJhbGxvYy9yYXdfdmVjLnJzAEG0Ewv9ARYEAAAkAAAAdwcAABMAAABIAgAACQAAANAEAABTAAAASwAAABEAAABQBAAAIAAAAHAEAABaAAAAHwAAAAUAAAAjBQAANAAAAKcGAAAUAAAAbQYAAAkAAABdBQAAEQAAAHcHAAATAAAA8gIAAAUAAABuBQAAKwAAAJkFAAARAAAAWQEAABUAAAACAAAAAAAAAAEAAAADAAAAdQYAACAAAACVBgAAEgAAAAQHAAAGAAAACgcAACIAAACnBgAAFAAAAK0HAAAFAAAALAcAABYAAABCBwAADQAAAKcGAAAUAAAAswcAAAUAAABPBwAAKAAAAHcHAAATAAAA9QEAAB4ADAdsaW5raW5nAwK0DQ==";

// node_modules/@bitauth/libauth/build/lib/bin/secp256k1/secp256k1-wasm.js
var import_dist49 = __toESM(require_dist(), 1);
var import_dist50 = __toESM(require_dist2(), 1);
var import_dist51 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/bin/secp256k1/secp256k1-wasm-types.js
var import_dist43 = __toESM(require_dist(), 1);
var import_dist44 = __toESM(require_dist2(), 1);
var import_dist45 = __toESM(require_dist3(), 1);
var SECP256K1_FLAGS_TYPE_CONTEXT = 1 << 0;
var SECP256K1_FLAGS_TYPE_COMPRESSION = 1 << 1;
var SECP256K1_FLAGS_BIT_CONTEXT_VERIFY = 1 << 8;
var SECP256K1_FLAGS_BIT_CONTEXT_SIGN = 1 << 9;
var SECP256K1_FLAGS_BIT_COMPRESSION = 1 << 8;
var SECP256K1_CONTEXT_VERIFY = SECP256K1_FLAGS_TYPE_CONTEXT | SECP256K1_FLAGS_BIT_CONTEXT_VERIFY;
var SECP256K1_CONTEXT_SIGN = SECP256K1_FLAGS_TYPE_CONTEXT | SECP256K1_FLAGS_BIT_CONTEXT_SIGN;
var SECP256K1_CONTEXT_NONE = SECP256K1_FLAGS_TYPE_CONTEXT;
var SECP256K1_EC_COMPRESSED = SECP256K1_FLAGS_TYPE_COMPRESSION | SECP256K1_FLAGS_BIT_COMPRESSION;
var SECP256K1_EC_UNCOMPRESSED = SECP256K1_FLAGS_TYPE_COMPRESSION;
var ContextFlag;
(function(ContextFlag2) {
  ContextFlag2[ContextFlag2["NONE"] = SECP256K1_CONTEXT_NONE] = "NONE";
  ContextFlag2[ContextFlag2["VERIFY"] = SECP256K1_CONTEXT_VERIFY] = "VERIFY";
  ContextFlag2[ContextFlag2["SIGN"] = SECP256K1_CONTEXT_SIGN] = "SIGN";
  ContextFlag2[ContextFlag2["BOTH"] = SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY] = "BOTH";
})(ContextFlag || (ContextFlag = {}));
var CompressionFlag;
(function(CompressionFlag2) {
  CompressionFlag2[CompressionFlag2["COMPRESSED"] = SECP256K1_EC_COMPRESSED] = "COMPRESSED";
  CompressionFlag2[CompressionFlag2["UNCOMPRESSED"] = SECP256K1_EC_UNCOMPRESSED] = "UNCOMPRESSED";
})(CompressionFlag || (CompressionFlag = {}));

// node_modules/@bitauth/libauth/build/lib/bin/secp256k1/secp256k1.base64.js
var import_dist46 = __toESM(require_dist(), 1);
var import_dist47 = __toESM(require_dist2(), 1);
var import_dist48 = __toESM(require_dist3(), 1);
var secp256k1Base64Bytes = "AGFzbQEAAAABXg5gAn9/AGAGf39/f39/AX9gAX8AYAABf2AAAGADf39/AX9gAX8Bf2ACf38Bf2AEf39/fwF/YAV/f39/fwF/YAN/f38AYAd/f39/f39/AX9gBH9/f38AYAV/f39/fwAC5wEMA2VudgZtZW1vcnkCAYACgAIDZW52BXRhYmxlAXABBgYDZW52CXRhYmxlQmFzZQN/AANlbnYORFlOQU1JQ1RPUF9QVFIDfwADZW52CFNUQUNLVE9QA38AA2VudgVhYm9ydAACA2Vudg1lbmxhcmdlTWVtb3J5AAMDZW52DmdldFRvdGFsTWVtb3J5AAMDZW52F2Fib3J0T25DYW5ub3RHcm93TWVtb3J5AAMDZW52C19fX3NldEVyck5vAAIDZW52Bl9hYm9ydAAEA2VudhZfZW1zY3JpcHRlbl9tZW1jcHlfYmlnAAUDSUgAAAYKBQAKCgIMAAYABwACBgUNCgAKAAoAAAcHAAAAAgYMCgoFAAUFAAULAQYFAwcBCAgBCAgKBwUFBQUHAQEIBQUFCAUICQgGCwJ/ASMBC38BIwILB/QGGxFfX19lcnJub19sb2NhdGlvbgA1BV9mcmVlACYHX21hbGxvYwAnGV9zZWNwMjU2azFfY29udGV4dF9jcmVhdGUAMxxfc2VjcDI1NmsxX2NvbnRleHRfcmFuZG9taXplAD4fX3NlY3AyNTZrMV9lY19wcml2a2V5X3R3ZWFrX2FkZABCH19zZWNwMjU2azFfZWNfcHJpdmtleV90d2Vha19tdWwAQBtfc2VjcDI1NmsxX2VjX3B1YmtleV9jcmVhdGUAMBpfc2VjcDI1NmsxX2VjX3B1YmtleV9wYXJzZQBOHl9zZWNwMjU2azFfZWNfcHVia2V5X3NlcmlhbGl6ZQBNHl9zZWNwMjU2azFfZWNfcHVia2V5X3R3ZWFrX2FkZABBHl9zZWNwMjU2azFfZWNfcHVia2V5X3R3ZWFrX211bAA/G19zZWNwMjU2azFfZWNfc2Vja2V5X3ZlcmlmeQBDGF9zZWNwMjU2azFfZWNkc2FfcmVjb3ZlcgA5NF9zZWNwMjU2azFfZWNkc2FfcmVjb3ZlcmFibGVfc2lnbmF0dXJlX3BhcnNlX2NvbXBhY3QAPDhfc2VjcDI1NmsxX2VjZHNhX3JlY292ZXJhYmxlX3NpZ25h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iCEuIAogLadJIAkgLKdJaiALICinSWogISAbRXFqIBkgE0VxaiAaIBRFcWogDiAbSWogByATSWogBSAUSWogECAISWogESAGSSAqQgGGpyIJciAiaiITaiIOIBIgBEkgK0IBhqciCnIgF2oiFGoiByAMIANJICVCAYanIgtyIBVqIhBqIgUgDSACSSAkQgGGpyIIciAWaiIRaiIGICOnIgRBAXQiEmoiASASSSEZIB8oAgCtICd+IiNCIIghLCABICOnIgNBAXQiDGoiASAMSSEaIBgoAgCtICZ+IiNCIIghKCABICOnIgJBAXQiDWoiASANSSEbIAogK6dJIAkgKqdJaiALICWnSWogCCAkp0lqICIgE0VxaiAOIBNJaiAXIBRFcWogByAUSWogFSAQRXFqIAUgEElqIBYgEUVxaiAGIBFJaiASIARJIC5CAYanIg5yIBlqIhVqIgogDCADSSAsQgGGpyIHciAaaiIWaiILIA0gAkkgKEIBhqciBXIgG2oiEGoiCCABIB4oAgCtIiQgJH4iI6ciAmoiASACSSAjQiCIp2oiBmohESAPIAE2AiAgICgCAK0iKSAcKAIArX4iI0IgiCEtIBEgI6ciBEEBdCIMaiIBIAxJIRMgHygCAK0iJyAdKAIArSImfiIjQiCIISogASAjpyIDQQF0Ig1qIgEgDUkhFCAYKAIArSIlICR+IiNCIIghJCABICOnIgJBAXQiCWoiASAJSSESIA8gATYCJCApICZ+IiNCIIghKyAHICynSSAOIC6nSWogBSAop0lqIBkgFUVxaiAaIBZFcWogGyAQRXFqIAogFUlqIAsgFklqIAggEElqIBEgBklqIAwgBEkgLUIBhqciB3IgE2oiDGoiCyANIANJICpCAYanIgVyIBRqIg1qIgggCSACSSAkQgGGpyIGciASaiIJaiIEICOnIgNBAXQiDmoiASAOSSEQICcgHigCAK0iJn4iI0IgiCEoIAEgI6ciAkEBdCIKaiIBIApJIREgBSAqp0kgByAtp0lqIAYgJKdJaiATIAxFcWogCyAMSWogFCANRXFqIAggDUlqIBIgCUVxaiAEIAlJaiAOIANJICtCAYanIgtyIBBqIhJqIgUgCiACSSAoQgGGpyIIciARaiIMaiIGIAEgJSAlfiIjpyICaiIBIAJJICNCIIinaiIEaiENIA8g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QUBrIAJB////H3EiAkHRB2pBGnZqQf///x9LIAYgAXEgB3EgCHEgBEH///8fcSIEcSAJcSALcUH///8fRiAFQf///wFGcXFyIgprQdEHcSACaiECIApBBnQgA2ogAkEadmoiA0EadiABQf///x9xaiIKQRp2IAZB////H3FqIgZBGnYgB0H///8fcWoiB0EadiAIQf///x9xaiIIQRp2IARqIgRBGnYgCUH///8fcWoiCUEadiALQf///x9xaiEBIAAgAkH///8fcTYCACANIANB////H3E2AgAgDiAKQf///x9xNgIAIA8gBkH///8fcTYCACAQIAdB////H3E2AgAgESAIQf///x9xNgIAIBIgBEH///8fcTYCACATIAlB////H3E2AgAgFCABQf///x9xNgIAIAwgAUEadiAFakH///8BcTYCAAuhFwEnfyMEIQQjBEHAA2okBCACKAJQIQYgASgCeARAIAAgBjYCeCAAIAIpAgA3AgAgACACKQIINwIIIAAgAikCEDcCECAAIAIpAhg3AhggACACKQIgNwIgIABBKGoiAyACQShqIgEpAgA3AgAgAyABKQIINwIIIAMgASkCEDcCECADIAEpAhg3AhggAyABKQIgNwIgIABBATYCUCAAQdQAaiIAQgA3AgAgAEIANwIIIABCADcCECAAQgA3AhggAEEANgIgIAQkBA8LIAYEQCADBEAgA0EBNgIAIANBBGoiAkIANwIAIAJCADcCCCACQgA3AhAgAkIANwIYIAJBADYCIAsgACABKQIANwIAIAAgASkCCDcCCCAAIAEpAhA3AhAgACABKQIYNwIYIAAgASkCIDcCICAAIAEpAig3AiggACABKQIwNwIwIAAgASkCODcCOCAAQUBrIAFBQGspAgA3AgAgACABKQJINwJIIAAgASkCUDcCUCAAIAEpAlg3AlggACABKQJgNwJgIAAgASkCaDcCaCAAIAEpAnA3AnAgACABKAJ4NgJ4IAQkBA8LIARB+ABqIQwgBEHQAGohJCAEQShqIQogAEH4AGoiKUEANgIAIARBkANqIiUgAUHQAGoiJhAHIARB6AJqIgggASkCADcCACAIIAEpAgg3AgggCCABKQIQNwIQIAggASkCGDcCGCAIIAEpAiA3AiAgCEEkaiIdKAIAIhNBFnYiBkHRB2wgCCgCAGohGyAGQQZ0IAhBBGoiFygCAGogG0EadmoiGEEadiAIQQhqIhkoAgBqIhpBGnYgCEEMaiIFKAIAaiIHQRp2IAhBEGoiDSgCAGoiFEEadiAIQRRqIhUoAgBqIg5BGnYgCEEYaiIPKAIAaiIQQRp2IAhBHGoiESgCAGoiEkEadiAIQSBqIgYoAgBqIRwgCCAbQf///x9xIio2AgAgFyAYQf///x9xIgs2AgAgGSAaQf///x9xIh42AgAgBSAHQf///x9xIh82AgAgDSAUQf///x9xIiA2AgAgFSAOQf///x9xIiE2AgAgDyAQQf///x9xIiI2AgAgESASQf///x9xIiM2AgAgBiAcQf///x9xIhs2AgAgHSAcQRp2IBNB////AXFqIhw2AgAgBEHAAmoiFiACICUQCiAEQZgCaiIJIAFBKGoiBikCADcCACAJIAYpAgg3AgggCSAGKQIQNwIQIAkgBikCGDcCGCAJIAYpAiA3AiAgCUEkaiInKAIAIh1BFnYiBkHRB2wgCSgCAGohDSAGQQZ0IAlBBGoiEygCAGogDUEadmoiFEEadiAJQQhqIhcoAgBqIhVBGnYgCUEMaiIYKAIAaiIOQRp2IAlBEGoiGSgCAGoiD0EadiAJQRRqIhooAgBqIhBBGnYgCUEYaiIFKAIAaiIRQRp2IAlBHGoiBygCAGoiEkEadiAJQSBqIgYoAgBqISggCSANQf///x9xIg02AgAgEyAUQf///x9xIhQ2AgAgFyAVQf///x9xIhU2AgAgGCAOQf///x9xIg42AgAgGSAPQf///x9xIg82AgAgGiAQQf///x9xIhA2AgAgBSARQf///x9xIhE2AgAgByASQf///x9xIhI2AgAgBiAoQf///x9xIgY2AgAgJyAoQRp2IB1B////AXFqNgIAIARB8AFqIgcgAkEoaiAlEAogByAHICYQCiAEQcgBaiIFQbzh//8AICprIBYoAgBqNgIAIAVB/P3//wAgC2sgFigCBGo2AgQgBUH8////ACAeayAWKAIIajYCCCAFQfz///8AIB9rIBYoAgxqNgIMIAVB/P///wAgIGsgFigCEGo2AhAgBUH8////ACAhayAWKAIUajYCFCAFQfz///8AICJrIBYoAhhqNgIYIAVB/P///wAgI2sgFigCHGo2AhwgBUH8////ACAbayAWKAIgajYCICAFQfz//wcgHGsgFigCJGo2AiRB/P//ByAnKAIAayECIARBoAFqIgtBvOH//wAgDWsgBygCAGo2AgAgC0H8/f//ACAUayAHKAIEajYCBCALQfz///8AIBVrIAcoAghqNgIIIAtB/P///wAgDmsgBygCDGo2AgwgC0H8////ACAPayAHKAIQajYCECALQfz///8AIBBrIAcoAhRqNgIUIAtB/P///wAgEWsgBygCGGo2AhggC0H8////ACASayAHKAIcajYCHCALQfz///8AIAZrIAcoAiBqNgIgIAsgAiAHKAIkajYCJCAFEBdFBEAgDCALEAcgJCAFEAcgCiAFICQQCiADBEAgAyAFKQIANwIAIAMgBSkCCDcCCCADIAUpAhA3AhAgAyAFKQIYNwIYIAMgBSkCIDcCIAsgAEHQAGogJiAFEAogBCAIICQQCiAAIAQpAgA3AgAgACAEKQIINwIIIAAgBCkCEDcCECAAIAQpAhg3AhggACAEKQIgNwIgQfj7//8BIABBBGoiEygCAEEBdCAKQQRqIh4oAgBqayEOQfj///8BIABBCGoiFygCAEEBdCAKQQhqIh8oAgBqayEPQfj///8BIABBDGoiGCgCAEEBdCAKQQxqIiAoAgBqayEQQfj///8BIABBEGoiGSgCAEEBdCAKQRBqIiEoAgBqayERQfj///8BIABBFGoiGigCAEEBdCAKQRRqIiIoAgBqayESQfj///8BIABBGGoiBSgCAEEBdCAKQRhqIiMoAgBqayEGQfj///8BIABBHGoiBygCAEEBdCAKQRxqIhsoAgBqayEDQfj///8BIABBIGoiDSgCAEEBdCAKQSBqIhwoAgBqayECQfj//w8gAEEkaiIUKAIAQQF0IApBJGoiHSgCAGprIQEgAEH4wv//ASAAKAIAQQF0IAooAgBqayAMKAIAaiIVNgIAIBMgDiAMKAIEaiIONgIAIBcgDyAMKAIIaiIPNgIAIBggECAMKAIMaiIQNgIAIBkgESAMKAIQaiIRNgIAIBogEiAMKAIUaiISNgIAIAUgBiAMKAIYaiIGNgIAIAcgAyAMKAIcaiIDNgIAIA0gAiAMKAIgaiICNgIAIBQgASAMKAIkaiIBNgIAIABBKGoiE0G0pP//AiAVayAEKAIAajYCACAAQSxqIhdB9Pn//wIgDmsgBCgCBGo2AgAgAEEwaiIYQfT///8CIA9rIAQoAghqNgIAIABBNGoiGUH0////AiAQayAEKAIMajYCACAAQThqIhpB9P///wIgEWsgBCgCEGo2AgAgAEE8aiIFQfT///8CIBJrIAQoAhRqNgIAIABBQGsiB0H0////AiAGayAEKAIYajYCACAAQcQAaiINQfT///8CIANrIAQoAhxqNgIAIABByABqIhRB9P///wIgAmsgBCgCIGo2AgAgAEHMAGoiFUH0//8XIAFrIAQoAiRqNgIAIBMgEyALEAogCiAKIAkQCiAKQbzh//8AIAooAgBrIg42AgAgHkH8/f//ACAeKAIAayIPNgIAIB9B/P///wAgHygCAGsiEDYCACAgQfz///8AICAoAgBrIhE2AgAgIUH8////ACAhKAIAayISNgIAICJB/P///wAgIigCAGsiBjYCACAjQfz///8AICMoAgBrIgM2AgAgG0H8////ACAbKAIAayICNgIAIBxB/P///wAgHCgCAGsiATYCACAdQfz//wcgHSgCAGsiADYCACATIBMoAgAgDmo2AgAgFyAXKAIAIA9qNgIAIBggGCgCACAQajYCACAZIBkoAgAgEWo2AgAgGiAaKAIAIBJqNgIAIAUgBSgCACAGajYCACAHIAcoAgAgA2o2AgAgDSANKAIAIAJqNgIAIBQgFCgCACABajYCACAVIBUoAgAgAGo2AgAgBCQEDwsgCxAXBEAgACABIAMQGiAEJAQPCyADBEAgA0IANwIAIANCADcCCCADQgA3AhAgA0IANwIYIANCADcCIAsgKUEBNgIAIAQkBAuvAwEBfyAAIAFBHGoiAigCAEEYdjoAACAAIAIoAgBBEHY6AAEgACACKAIAQQh2OgACIAAgAigCADoAAyAAIAFBGGoiAigCAEEYdjoABCAAIAIoAgBBEHY6AAUgACACKAIAQQh2OgAGIAAgAigCADoAByAAIAFBFGoiAigCAEEYdjoACCAAIAIoAgBBEHY6AAkgACACKAIAQQh2OgAKIAAgAigCADoACyAAIAFBEGoiAigCAEEYdjoADCAAIAIoAgBBEHY6AA0gACACKAIAQQh2OgAOIAAgAigCADoADyAAIAFBDGoiAigCAEEYdjoAECAAIAIoAgBBEHY6ABEgACACKAIAQQh2OgASIAAgAigCADoAEyAAIAFBCGoiAigCAEEYdjoA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BxAHIAcgBxAHIAcgBxAHIAcgBxAHIAcgBxAHIAcgByAGEAogBEHIAWoiBSAHKQIANwIAIAUgBykCCDcCCCAFIAcpAhA3AhAgBSAHKQIYNwIYIAUgBykCIDcCICAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUgBxAKIARBoAFqIgIgBSkCADcCACACIAUpAgg3AgggAiAFKQIQNwIQIAIgBSkCGDcCGCACIAUpAiA3AiAgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACIAUQCiAEQfgAaiIJIAIpAgA3AgAgCSACKQIINwIIIAkgAikCEDcCECAJIAIpAhg3AhggCSACKQIgNwIgQQAhBgNAIAkgCRAHIAZBAWoiBkHYAEcNAAsgCSAJIAIQCiADIAkpAgA3AgAgAyAJKQIINwIIIAMgCSkCEDcCECADIAkpAhg3AhggAyAJKQIgNwIgIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAyAFEAogCCADKQIANwIAIAggAykCCDcCCCAIIAMpAhA3AhAgCCADKQIYNwIYIAggAykCIDcCICAIIAgQByAIIAgQByAIIAgQByAIIAggChAKIAQgCCkCADcCACAEIAgpAgg3AgggBCAIKQIQNwIQIAQgCCkCGDcCGCAEIAgpAiA3AiAgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEIAcQCiAEIAQQByAEIAQQByAEIAQQByAEIAQQByAEIAQQByAEIAQgARAKIAQgBBAHIAQgBBAHIAQgBBAHIAQgBCALEAogBCAEEAcgBCAEEAcgACABIAQQCiAEJAQL7gQBG38gAEEkaiILKAIAIgJBFnYiAUHRB2wgACgCAGohBCABQQZ0IABBBGoiDCgCAGogBEEadmoiBUEadiAAQQhqIg0oAgBqIgZB////H3EhByAGQRp2IABBDGoiDigCAGoiCEEadiAAQRBqIg8oAgBqIQEgCEH///8fcSEJIAFB////H3EhCiABQRp2IABBFGoiECgCAGoiEUEadiAAQRhqIhIoAgBqIRMgEUH///8fcSEUIBNBGnYgAEEcaiIVKAIAaiIWQRp2IABBIGoiFygCAGohAyAWQf///x9xIRggA0H///8fcSEZIANBGnYgAkH///8BcWoiAkEWdiAFQf///x9xIgVBQGsgBEH///8fcSIEQdEHaiIaQRp2IhtqQf///x9LIAggBnEgAXEgEXEgE0H///8fcSIBcSAWcSADcUH///8fRiACQf///wFGcXFyIgNFBEAgACAENgIAIAwgBTYCACANIAc2AgAgDiAJNgIAIA8gCjYCACAQIBQ2AgAgEiABNgIAIBUgGDYCACAXIBk2AgAgCyACNgIADwsgGyAFaiADQQZ0aiIDQRp2IAdqIgRBGnYgCWoiBkEadiAKaiIHQRp2IBRqIghBGnYgAWoiAUEadiAYaiIJQRp2IBlqIgpBGnYgAmpB////AXEhAiAAIBpB////H3E2AgAgDCADQf///x9xNgIAIA0gBEH///8fcTYCACAOIAZB////H3E2AgAgDyAHQf///x9xNgIAIBAgCEH///8fcTYCACASIAFB////H3E2AgAgFSAJQf///x9xNgIAIBcgCkH///8fcTYCACALIAI2AgALsAIBCn8gACgCJCIBQRZ2IgJB0QdsIAAoAgBqIgNB////H3EiBEHQB3MhBSAEQQBHIAVB////H0dxBEBBAA8LIANBGnYgAkEGdHIgACgCBGoiAkEadiAAKAIIaiIDQRp2IAAoAgxqIgZBGnYgACgCEGoiB0EadiAAKAIUaiIIQRp2IAAoAhhqIglBGnYgACgCHGoiCkEadiAAKAIgaiIAQRp2IAFB////AXFqIQEgAkHAAHMgBXEgA3EgBnEgB3EgCHEgCXEgCnEgAHEgAUGAgIAec3FB////H0YEf0EBBSACQf///x9xIARyIANB////H3FyIAZB////H3FyIAdB////H3FyIAhB////H3FyIAlB////H3FyIApB////H3FyIABB////H3FyIAFyRQtBAXELmAIBBH8gACACaiEEIAFB/wFxIQEgAkHDAE4EQANAIABBA3EEQCAAIAE6AAAgAEEBaiEADAELCyAEQXxxIgVBQGohBiABIAFBCHRyIAFBEHRyIAFBGHRyIQMDQCAAIAZMBEAgACADNgIAIAAgAzYCBCAAIAM2AgggACADNgIMIAAgAzYCECAAIAM2AhQgACADNgIYIAAgAzYCHCAAIAM2AiAgACADNgIkIAAgAzYCKCAAIAM2AiwgACADNgIwIAAgAzYCNCAAIAM2AjggACADNgI8IABBQGshAAwBCwsDQCAAIAVIBEAgACADNgIAIABBBGohAAwBCwsLA0AgACAESARAIAAgAToAACAAQQFqIQAMAQsLIAQgAmsLqy8BnwF/IwQhDSMEQbAmaiQEIA1BgCZqIQ4gDUHYJWohESANQdgkaiEGIA1BhCRqIRIgDUGwI2ohDCANQcgfaiEWIA1ByBdqIUkgDUHoD2ohBSANQagNaiEJIA1BiAhqIQsCfwJAIAMoAgQgAygCAHIgAygCCHIgAygCDHIgAygCEHIgAygCFHIgAygCGHIgAygCHHJFDQAgAigCeA0AIA1BhAhqIgpBADYCACANQYAIaiANIANBBRArIgM2AgAgBiACIAooAgAiD0H8AGxqIhBBABAaIAwgBikCADcCACAMIAYpAgg3AgggDCAGKQIQNwIQIAwgBikCGDcCGCAMIAYpAiA3AiAgDEEoaiIKIAZBKGoiCCkCADcCACAKIAgpAgg3AgggCiAIKQIQNwIQIAogCCkCGDcCGCAKIAgpAiA3AiAgDEEANgJQIA4gBkHQAGoiChAHIBEgDiAKEAogEiAQIA4QCiASQShqIgggAiAPQfwAbGpBKGogERAKIBIgAiAPQfwAbGooAng2AlAgBSASKQIANwIAIAUgEikCCDcCCCAFIBIpAhA3AhAgBSASKQIYNwIYIAUgEikCIDcCICAFQShqIhAgCCkCADcCACAQIAgpAgg3AgggECAIKQIQNwIQIBAgCCkCGDcCGCAQIAgpAiA3AiAgBUHQAGoiCCACIA9B/ABsakHQAGoiAikCADcCACAIIAIpAgg3AgggCCACKQIQNwIQIAggAikCGDcCGCAIIAIpAiA3AiAgBUH4AGoiE0EANgIAIAkgCikCADcCACAJIAopAgg3AgggCSAKKQIQNwIQIAkgCikCGDcCGCAJIAopAiA3AiAgBUH8AGoiAiAFIAwgCUEoaiIUEBAgBUH4AWoiCCACIAwgCUHQAGoiBxAQIAVB9AJqIgIgCCAMIAlB+ABqIh0QECAFQfADaiIIIAIgDCAJQaABaiIeEBAgBUHsBGoiAiAIIAwgCUHIAWoiHxAQIAVB6AVqIg8gAiAMIAlB8AFqIiEQECAFQeQGaiIIIA8gDCAJQZgCaiIPEBAgBUG0B2oiAiACIAoQCiALQcwEaiIJIAgpAgA3AgAgCSAIKQIINwIIIAkgCCkCEDcCECAJIAgpAhg3AhggCSAIKQIgNwIgIAtB9ARqIgkgBUGMB2oiCikCADcCACAJIAopAgg3AgggCSAKKQIQNwIQIAkgCikCGDcCGCAJIAopAiA3AiAgC0GYBWoiIigCACIjQRZ2IghB0QdsIAkoAgBqIQogCEEGdCALQfgEaiIkKAIAaiAKQRp2aiIlQRp2IAtB/ARqIiYoAgBqIidBGnYgC0GABWoiKCgCAGoiKUEadiALQYQFaiIqKAIAaiIrQRp2IAtBiAVqIiwoAgBqIi1BGnYgC0GMBWoiLigCAGoiL0EadiALQZAFaiIwKAIAaiIxQRp2IAtBlAVqIjIoAgBqIQggCSAKQf///x9xNgIAICQgJUH///8fcTYCACAmICdB////H3E2AgAgKCApQf///x9xNgIAICogK0H///8fcTYCACAsIC1B////H3E2AgAgLiAvQf///x9xNgIAIDAgMUH///8fcTYCACAyIAhB////H3E2AgAgIiAIQRp2ICNB////AXFqNgIAIBYgAikCADcCACAWIAIpAgg3AgggFiACKQIQNwIQIBYgAikCGDcCGCAWIAIpAiA3AiAgC0EANgKcBSAGIA8pAgA3AgAgBiAPKQIINwIIIAYgDykCEDcCECAGIA8pAhg3AhggBiAPKQIgNwIgIA4gBhAHIBEgDiAGEAogC0H4A2ogBUHoBWogDhAKIAtBoARqIAVBkAZqIBEQCiALIAUoAuAGNgLIBCAGIAYgIRAKIA4gBhAHIBEgDiAGEAogC0GkA2ogBUHsBGogDhAKIAtBzANqIAVBlAVqIBEQCiALIAUoAuQFNgL0AyAGIAYgHxAKIA4gBhAHIBEgDiAGEAogC0HQAmogBUHwA2ogDhAKIAtB+AJqIAVBmARqIBEQCiALIAUoAugENgKgAyAGIAYgHhAKIA4gBhAHIBEgDiAGEAogC0H8AWogBUH0AmogDhAKIAtBpAJqIAVBnANqIBEQCiALIAUoAuwDNgLMAiAGIAYgHRAKIA4gBhAHIBEgDiAGEAogC0GoAWogBUH4AWogDhAKIAtB0AFqIAVBoAJqIBEQCiALIAUoAvACNgL4ASAGIAYgBxAKIA4gBhAHIBEgDiAGEAogC0HUAGogBUH8AGogDhAKIAtB/ABqIAVBpAFqIBEQCiALIAUoAvQBNgKkASAGIAYgFBAKIA4gBhAHIBEgDiAGEAogCyAFIA4QCiALQShqIBAgERAKIAsgEygCADYCUEEBIUogA0EASgR/IAMFQQALDAELIBZBATYCACAWQQRqIgJCADcCACACQgA3AgggAkIANwIQIAJCADcCGCACQQA2AiBBASFLQQALIQIgBARAIEkgBEEPECsiAyFMIAMgAkoEQCADIQILCyABQfgAaiIdQQE2AgAgAUIANwIAIAFCADcCCCABQgA3AhAgAUIANwIYIAFCADcCICABQgA3AiggAUIANwIwIAFCADcCOCABQUBrQgA3AgAgAUIANwJIIAFCADcCUCABQgA3AlggAUIANwJgIAFCADcCaCABQgA3AnAgAkEATARAIA0kBA8LIA1B6CFqISsgDUHwIGohLCANQcggaiFNIA1B8B9qIgVB0ABqIWogAUHQAGohHiAGQQRqIU4gBkEIaiFPIAZBDGohUCAGQRBqIVEgBkEUaiFSIAZBGGohUyAGQRxqIVQgBkEgaiFVIAZBJGohViABQShqIRMgDEEEaiFXIAxBCGohWCAMQQxqIVkgDEEQaiFaIAxBFGohWyAMQRhqIVwgDEEcaiFdIAxBIGohXiAMQSRqIV8gBUEoaiFgIA1B4CJqIghBBGohayAIQQhqIWwgCEEMaiFtIAhBEGohbiAIQRRqIW8gCEEYaiFwIAhBHGohcSAIQSBqIXIgCEEkaiFzIBJBBGohdCASQQhqIXUgEkEMaiF2IBJBEGohdyASQRRqIXggEkEYaiF5IBJBHGoheiASQSBqIXsgEkEkaiF8IA1BuCJqIhBBBGohfSAQQQhqIX4gEEEMaiF/IBBBEGohgAEgEEEUaiGBASAQQRhqIYIBIBBBHGohgwEgEEEgaiGEASAQQSRqIYUBIA1BiCNqIg9BBGohhgEgD0EIaiGHASAPQQxqIYgBIA9BEGohiQEgD0EUaiGKASAPQRhqIYsBIA9BHGohjAEgD0EgaiGNASAPQSRqIY4BIAFBBGohYSABQQhqIWIgAUEMaiFjIAFBEGohZCABQRRqIWUgAUEYaiFmIAFBHGohZyABQSBqIWggAUEkaiFpIA1BwCFqIgpBBGohLSAKQQhqIS4gCkEMaiEvIApBEGohMCAKQRRqITEgCkEYaiEyIApBHGohOSAKQSBqITogCkEkaiE7IA1BkCJqIhRBBGohjwEgFEEIaiGQASAUQQxqIZEBIBRBEGohkgEgFEEUaiGTASAUQRhqIZQBIBRBHGohlQEgFEEgaiGWASAUQSRqIZcBIAFBLGohPCABQTBqIT0gAUE0aiE+IAFBOGohPyABQTxqIUAgAUFAayFBIAFBxABqIUIgAUHIAGohQyABQcwAaiFEIA1BmCFqIglBBGohmAEgCUEIaiGZASAJQQxqIZoBIAlBEGohmwEgCUEUaiGcASAJQRhqIZ0BIAlBHGohngEgCUEgaiGfASAJQSRqIaABIAFB0ABqIaEBIAFB1ABqIR8gBUEoaiEhIAVBLGohIiAFQTBqISMgBUE0aiEkIAVBOGohJSAFQTxqISYgBUFAayEnIAVBxABqISggBUHIAGohKSAFQcwAaiEqIA1BgAhqKAIAIaIBA0AgAkF/aiEEIAEgAUEAEBogSyACIKIBSnJFBEBBACEDA0AgDSADQYgIbGogBEECdGooAgAiBwRAIAsgA0EDdEHUAGxqIRUgB0EASgRAIAUgFSAHQX9qQQJtQdQAbGoiBykCADcCACAFIAcpAgg3AgggBSAHKQIQNwIQIAUgBykCGDcCGCAFIAcpAiA3AiAgBSAHKQIoNwIoIAUgBykCMDcCMCAFIAcpAjg3AjggBUFAayAHQUBrKQIANwIAIAUgBykCSDcCSCAFIAcoAlA2AlAFIAUgFSAHQX9zQQJtQdQAbGoiBykCADcCACAFIAcpAgg3AgggBSAHKQIQNwIQIAUgBykCGDcCGCAFIAcpAiA3AiAgBSAHKQIoNwIoIAUgBykCMDcCMCAFIAcpAjg3AjggBUFAayAHQUBrKQIANwIAIAUgBykCSDcCSCAFIAcoAlA2AlAgIUG84f//ACAhKAIAazYCACAiQfz9//8AICIoAgBrNgIAICNB/P///wAgIygCAGs2AgAgJEH8////ACAkKAIAazYCACAlQfz///8AICUoAgBrNgIAICZB/P///wAgJigCAGs2AgAgJ0H8////ACAnKAIAazYCACAoQfz///8AICgoAgBrNgIAIClB/P///wAgKSgCAGs2AgAgKkH8//8HICooAgBrNgIACyABIAEgBUEAEBALIANBAWoiAyBKRw0ACwsgAiBMTARAIEkgBEECdGooAgAiAwRAIAAoAgAhByADQQBKBEAgBSAHIANBf2pBAm1BBnRqECMFIAUgByADQX9zQQJtQQZ0ahAjICFBvOH//wAgISgCAGs2AgAgIkH8/f//ACAiKAIAazYCACAjQfz///8AICMoAgBrNgIAICRB/P///wAgJCgCAGs2AgAgJUH8////ACAlKAIAazYCACAmQfz///8AICYoAgBrNgIAICdB/P///wAgJygCAGs2AgAgKEH8////ACAoKAIAazYCACApQfz///8AICkoAgBrNgIAICpB/P//ByAqKAIAazYCAAsCQCBqKAIARQRAIB0oAgAEQCAdQQA2AgAgLCAWEAcgTSAsIBYQCiABIAUgLBAKIBMgYCBNEAogoQFBATYCACAfQgA3AgAgH0IANwIIIB9CADcCECAfQgA3AhggH0EANgIgDAILIB1BADYCACAOIB4gFhAKIBEgDhAHIAYgASkCADcCACAGIAEpAgg3AgggBiABKQIQNwIQIAYgASkCGDcCGCAGIAEpAiA3AiAgVigCACIVQRZ2IgdB0QdsIAYoAgBqIQMgB0EGdCBOKAIAaiADQRp2aiIXQRp2IE8oAgBqIhhBGnYgUCgCAGoiGUEadiBRKAIAaiIaQRp2IFIoAgBqIhtBGnYgUygCAGoiHEEadiBUKAIAaiIgQRp2IFUoAgBqIQcgBiADQf///x9xIkU2AgAgTiAXQf///x9xIhc2AgAgTyAYQf///x9xIhg2AgAgUCAZQf///x9xIhk2AgAgUSAaQf///x9xIho2AgAgUiAbQf///x9xIhs2AgAgUyAcQf///x9xIhw2AgAgVCAgQf///x9xIiA2AgAgVSAHQf///x9xIkY2AgAgViAHQRp2IBVB////AXFqIhU2AgAgEiAFIBEQCiAMIBMpAgA3AgAgDCATKQIINwIIIAwgEykCEDcCECAMIBMpAhg3AhggDCATKQIgNwIgIF8oAgAiR0EWdiIHQdEHbCAMKAIAaiEDIAdBBnQgVygCAGogA0EadmoiM0EadiBYKAIAaiI0QRp2IFkoAgBqIjVBGnYgWigCAGoiNkEadiBbKAIAaiI3QRp2IFwoAgBqIjhBGnYgXSgCAGoiSEEadiBeKAIAaiEHIAwgA0H///8fcSIDNgIAIFcgM0H///8fcSIzNgIAIFggNEH///8fcSI0NgIAIFkgNUH///8fcSI1NgIAIFogNkH///8fcSI2NgIAIFsgN0H///8fcSI3NgIAIFwgOEH///8fcSI4NgIAIF0gSEH///8fcSJINgIAIF4gB0H///8fcSKjATYCACBfIAdBGnYgR0H///8BcWoiBzYCACAPIGAgERAKIA8gDyAOEAogCEG84f//ACBFayASKAIAajYCACBrQfz9//8AIBdrIHQoAgBqNgIAIGxB/P///wAgGGsgdSgCAGo2AgAgbUH8////ACAZayB2KAIAajYCACBuQfz///8AIBprIHcoAgBqNgIAIG9B/P///wAgG2sgeCgCAGo2AgAgcEH8////ACAcayB5KAIAajYCACBxQfz///8AICBrIHooAgBqNgIAIHJB/P///wAgRmsgeygCAGo2AgAgc0H8//8HIBVrIHwoAgBqNgIAIBBBvOH//wAgA2sgDygCAGo2AgAgfUH8/f//ACAzayCGASgCAGo2AgAgfkH8////ACA0ayCHASgCAGo2AgAgf0H8////ACA1ayCIASgCAGo2AgAggAFB/P///wAgNmsgiQEoAgBqNgIAIIEBQfz///8AIDdrIIoBKAIAajYCACCCAUH8////ACA4ayCLASgCAGo2AgAggwFB/P///wAgSGsgjAEoAgBqNgIAIIQBQfz///8AIKMBayCNASgCAGo2AgAghQFB/P//ByAHayCOASgCAGo2AgAgCBAXRQRAIBQgEBAHICsgCBAHIAogCCArEAogHiAeIAgQCiAJIAYgKxAKIAEgCSkCADcCACABIAkpAgg3AgggASAJKQIQNwIQIAEgCSkCGDcCGCABIAkpAiA3AiAgLSgCACEDIC4oAgAhByAvKAIAIRUgMCgCACEXIDEoAgAhGCAyKAIAIRkgOSgCACEaIDooAgAhGyA7KAIAIRwgYSgCAEF+bCEgIGIoAgBBfmwhRSBjKAIAQX5sIUYgZCgCAEF+bCFHIGUoAgBBfmwhMyBmKAIAQX5sITQgZygCAEF+bCE1IGgoAgBBfmwhNiBpKAIAQX5sITcgASABKAIAQX5sQfjC//8BaiAKKAIAayAUKAIAaiI4NgIAIGEgIEH4+///AWogA2sgjwEoAgBqIgM2AgAgYiBFQfj///8BaiAHayCQASgCAGoiBzYCACBjIEZB+P///wFqIBVrIJEBKAIAaiIVNgIAIGQgR0H4////AWogF2sgkgEoAgBqIhc2AgAgZSAzQfj///8BaiAYayCTASgCAGoiGDYCACBmIDRB+P///wFqIBlrIJQBKAIAaiIZNgIAIGcgNUH4////AWogGmsglQEoAgBqIho2AgAgaCA2Qfj///8BaiAbayCWASgCAGoiGzYCACBpIDdB+P//D2ogHGsglwEoAgBqIhw2AgAgE0G0pP//AiA4ayAJKAIAajYCACA8QfT5//8CIANrIJgBKAIAajYCACA9QfT///8CIAdrIJkBKAIAajYCACA+QfT///8CIBVrIJoBKAIAajYCACA/QfT///8CIBdrIJsBKAIAajYCACBAQfT/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NwIIIAAgAykCEDcCECAAIAMpAhg3AhggACADKQIgNwIgQfb6/78CIABBBGoiASgCAEECdGshD0H2//+/AiAAQQhqIhAoAgBBAnRrIRFB9v//vwIgAEEMaiIbKAIAQQJ0ayEcQfb//78CIABBEGoiHSgCAEECdGshHkH2//+/AiAAQRRqIh8oAgBBAnRrISBB9v//vwIgAEEYaiIhKAIAQQJ0ayEiQfb//78CIABBHGoiIygCAEECdGshJEH2//+/AiAAQSBqIiUoAgBBAnRrISZB9v//EyAAQSRqIicoAgBBAnRrISggAEHWs/+/AiAAKAIAQQJ0ayAHKAIAIilqNgIAIAEgDyAHQQRqIg8oAgAiAWo2AgAgECARIAdBCGoiECgCACIRajYCACAbIBwgB0EMaiIbKAIAIhxqNgIAIB0gHiAHQRBqIh0oAgAiHmo2AgAgHyAgIAdBFGoiHygCACIgajYCACAhICIgB0EYaiIhKAIAIiJqNgIAICMgJCAHQRxqIiMoAgAiJGo2AgAgJSAmIAdBIGoiJSgCACImajYCACAnICggB0EkaiInKAIAIihqNgIAIAIoAgBBBmwhKiAGKAIAQQZsISsgCCgCAEEGbCEsIAkoAgBBBmwhLSAKKAIAQQZsIS4gCygCAEEGbCEvIAwoAgBBBmwhMCANKAIAQQZsITEgDigCAEEGbCEyIAMgAygCAEEGbEG84f//ACApa2o2AgAgAiAqQfz9//8AIAFrajYCACAGICtB/P///wAgEWtqNgIAIAggLEH8////ACAca2o2AgAgCSAtQfz///8AIB5rajYCACAKIC5B/P///wAgIGtqNgIAIAsgL0H8////ACAia2o2AgAgDCAwQfz///8AICRrajYCACANIDFB/P///wAgJmtqNgIAIA4gMkH8//8HIChrajYCACAAQShqIgEgBSADEAogB0Ga0v+/ASAEKAIAayICNgIAIA9B+vz/vwEgEigCAGsiAzYCACAQQfr//78BIBMoAgBrIgU2AgAgG0H6//+/ASAUKAIAayIHNgIAIB1B+v//vwEgFSgCAGsiBjYCACAfQfr//78BIBYoAgBrIgg2AgAgIUH6//+/ASAXKAIAayIJNgIAICNB+v//vwEgGCgCAGsiCjYCACAlQfr//78BIBkoAgBrIgs2AgAgJ0H6//8LIBooAgBr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BGohBCAGIAgQDEEBIANrIgNBwABJBH8gBAUgAkGBf2oiDUFAcSIOIAJrQcSSBGohBSADIQIgBCEDA0AgCCADKQAANwAAIAggAykACDcACCAIIAMpABA3ABAgCCADKQAYNwAYIAggAykAIDcAICAIIAMpACg3ACggCCADKQAwNwAwIAggAykAODcAOCADQUBrIQMgBiAIEAwgAkFAaiICQcAATw0ACyANIA5rIQMgBQshAiADBEAgAiEEQQAhAgwCCwsMAQsgCCACaiAEIAMQCxoLIAogECgCACICQR12QRh0NgIAIAogAkELdEGAgPwHcSACQRt0ciACQQV2QYD+A3FyIAJBFXZB/wFxcjYCBCAQIAJBNyACa0E/cUEBaiIDajYCACAGQSBqIQUCQAJAIANBwAAgAkE/cSICayIESQRAQfmMBCEEDAEFIAUgAmpB+YwEIAQQCxogBEH5jARqIQIgBiAFEAwgAyAEayIDQcAATwRAA0AgBSACKQAANwAAIAUgAikACDcACCAFIAIpABA3ABAgBSACKQAYNwAYIAUgAikAIDcAICAFIAIpACg3ACggBSACKQAwNwAwIAUgAikAODcAOCACQUBrIQIgBiAFEAwgA0FAaiIDQcAATw0ACwsgAwRAIAIhBEEAIQIMAgsLDAELIAUgAmogBCADEAsaCyAQKAIAIgJBP3EhBCAQIAJBCGo2AgAgBkEgaiEFAkACQEHAACAEayIDQQhLBEAgCiECQQghAwwBBSAFIARqIAogAxALGiAKIANqIQIgBiAFEAxBCCADayIDQcAATwRAA0AgBSACKQAANwAAIAUgAikACDcACCAFIAIpABA3ABAgBSACKQAYNwAYIAUgAikAIDcAICAFIAIpACg3ACggBSACKQAwNwAwIAUgAikAODcAOCACQUBrIQIgBiAFEAwgA0FAaiIDQcAATw0ACwsgAwRAQQAhBAwCCwsMAQsgBSAEaiACIAMQCxoLIAYoAgAQCSESIAZBADYCACAGQQRqIh4oAgAQCSEIIB5BADYCACAGQQhqIh8oAgAQCSENIB9BADYCACAGQQxqIiAoAgAQCSEOICBBADYCACAGQRBqIiEoAgAQCSEFICFBADYCACAGQRRqIiMoAgAQCSEEICNBADYCACAGQRhqIhMoAgAQCSEDIBNBADYCACAGQRxqIh0oAgAQ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EAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADIAIQDSAEQaABaiICIAMQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIgBRANIAIgAhAIIAIgAhAIIAIgAhAIIAIgAiAJEA0gAiACEAggAiACEAggAiACEAggAiACEAggAiACIAYQDSACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIgCRANIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAiAKEA0gAiACEAggAiACEAggAiACEAggAiACEAggAiACIAoQDSACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIgBhANIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAiAGEA0gAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACIAQQDSACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIgCRANIAIgAhAIIAIgAhAIIAIgAhAIIAIgAiAGEA0gAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACIAsQDSACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIgCRANIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAiAGEA0gAiACEAggAiACEAggAiACEAggAiACEAggAiACIAYQDSACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIgCBANIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAiALEA0gAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACIAoQDSACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIgBBANIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAiAMEA0gAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACIAQQDSACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIgBBANIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAiALEA0gAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACIAEQDSACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCAAIAIgBxANIAQkBAvYAwETfyMEIQIjBEHQAGokBCACIAFB0ABqEAcgAiACIAAQCiABKAIkIgZBFnYiAEHRB2wgASgCAGohBCAAQQZ0IAEoAgRqIARBGnZqIgdBGnYgASgCCGoiCEEadiABKAIMaiIJQRp2IAEoAhBqIgpBGnYgASgCFGoiC0EadiABKAIYaiIMQRp2IAEoAhxqIg1BGnYgASgCIGohBUH8/f//ACACKAIEayEOQfz///8AIAIoAghrIQ9B/P///wAgAigCDGshEEH8////ACACKAIQayERQfz///8AIAIoAhRrIRJB/P///wAgAigCGGshE0H8////ACACKAIcayEUQfz///8AIAIoAiBrIQEgAigCJCEAIAJBKGoiA0G84f//ACACKAIAayAEQf///x9xajYCACADIA4gB0H///8fcWo2AgQgAyAPIAhB////H3FqNgIIIAMgECAJQf///x9xajYCDCADIBEgCkH///8fcWo2AhAgAyASIAtB////H3FqNgIUIAMgEyAMQf///x9xajYCGCADIBQgDUH///8fcWo2AhwgAyABIAVB////H3FqNgIgIAMgBkH///8BcUH8//8HaiAAayAFQRp2ajYCJCADEBchACACJAQgAAuXEAEKfyMEIQQjBEHgA2okBCAEQdAAaiEDIARBKGohCCAEQbgDaiILIAEQByALIAsgARAKIARBkANqIgogCxAHIAogCiABEAogBEHoAmoiBiAKKQIANwIAIAYgCikCCDcCCCAGIAopAhA3AhAgBiAKKQIYNwIYIAYgCikCIDcCICAGIAYQByAGIAYQByAGIAYQByAGIAYgChAKIARBwAJqIgIgBikCADcCACACIAYpAgg3AgggAiAGKQIQNwIQIAIgBikCGDcCGCACIAYpAiA3AiAgAiACEAcgAiACEAcgAiACEAcgAiACIAoQCiAEQZgCaiIGIAIpAgA3AgAgBiACKQIINwIIIAYgAikCEDcCECAGIAIpAhg3AhggBiACKQIgNwIgIAYgBhAHIAYgBhAHIAYgBiALEAogBEHwAWoiByAGKQIANwIAIAcgBikCCDcCCCAHIAYpAhA3AhAgByAGKQIYNwIYIAcgBikCIDcCICAHIAcQByAHIAcQByAHIAcQByAHIAcQByAHIAcQByAHIAcQByAHIAcQByAHIAcQByAHIAcQByAHIAcQByAHIAcQByAHIAcgBhAKIARByAFqIgUgBykCADcCACAFIAcpAgg3AgggBSAHKQIQNwIQIAUgBykCGDcCGCAFIAcpAiA3AiAgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFIAcQCiAEQaABaiICIAUpAgA3AgAgAiAFKQIINwIIIAIgBSkCEDcCECACIAUpAhg3AhggAiAFKQIgNwIgIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAiAFEAogBEH4AGoiCSACKQIANwIAIAkgAikCCDcCCCAJIAIpAhA3AhAgCSACKQIYNwIYIAkgAikCIDcCIEEAIQYDQCAJIAkQByAGQQFqIgZB2ABHDQALIAkgCSACEAogAyAJKQIANwIAIAMgCSkCCDcCCCADIAkpAhA3AhAgAyAJKQIYNwIYIAMgCSkCIDcCICADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMgBRAKIAggAykCADcCACAIIAMpAgg3AgggCCADKQIQNwIQIAggAykCGDcCGCAIIAMpAiA3AiAgCCAIEAcgCCAIEAcgCCAIEAcgCCAIIAoQCiAEIAgpAgA3AgAgBCAIKQIINwIIIAQgCCkCEDcCECAEIAgpAhg3AhggBCAIKQIgNwIgIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBCAHEAogBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEIAsQCiAEIAQQByAAIAQQByAEIAAQB0G84f//ACAEKAIAayABKAIAaiABKAIkQfz//wcgBCgCJGtqIgpBFnYiBkHRB2xqIQBB/P///wAgBCgCIGsgASgC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ACggBCABKQAwNwAwIAQgASkAODcAOCABQUBrIQEgBiAEEAwgAkFAaiICQcAATw0ACwsgAgRAQQAhAwwCCwsMAQsgBCADaiABIAIQCxoLIAYoAgAQCSEIIAZBADYCACAKKAIAEAkhCSAKQQA2AgAgCygCABAJIQogC0EANgIAIAwoAgAQCSELIAxBADYCACANKAIAEAkhByANQQA2AgAgDigCABAJIQMgDkEANgIAIA8oAgAQCSECIA9BADYCACARKAIAEAkhASAFIAg2AgAgBSAJNgIEIAUgCjYCCCAFIAs2AgwgBSAHNgIQIAUgAzYCFCAFIAI2AhggBSABNgIcIAAgBSAQEA4gBSQEC+YBAQN/IABB4ABqIgMoAgAiBEE/cSEFIAMgBCACajYCAEHAACAFayIEIAJNBEAgAEEgaiIDIAVqIAEgBBALGiABIARqIQEgACADEAwgAiAEayICQcAASQRAQQAhBQUDQCADIAEpAAA3AAAgAyABKQAINwAIIAMgASkAEDcAECADIAEpABg3ABggAyABKQAgNwAgIAMgASkAKDcAKCADIAEpADA3ADAgAyABKQA4NwA4IAFBQGshASAAIAMQDCACQUBqIgJBwABPDQBBACEFCwsLIAJFBEAPCyAAQSBqIAVqIAEgAhALGgvASwEzfyMEIQkjBEHwAWokBCAAQoGChIiQoMCAATcCACAAQoGChIiQoMCAATcCCCAAQoGChIiQoMCAATcCECAAQoGChIiQoMCAATcCGCAAQSBqIhlCADcCACAZQgA3AgggGUIANwIQIBlCADcCGCAJIgogGRATIApB4ABqIg0oAgAiCUE/cSEEIA0gCUEgajYCACAKQSBqIQsCQAJAQcAAIARrIglBIEsEQCAAIQkgBCEDQSAhCAwBBSALIARqIAAgCRALGiAAIAlqIQMgCiALEAxBICAJayIIQcAASQR/IAMFIABB5ABqIARBoH9qIgdBQHEiBkEcciAEa2ohBCAIIQkgAyEIA0AgCyAIKQAANwAAIAsgCCkACDcACCALIAgpABA3ABAgCyAIKQAYNwAYIAsgCCkAIDcAICALIAgpACg3ACggCyAIKQAwNwAwIAsgCCkAODcAOCAIQUBrIQggCiALEAwgCUFAaiIJQcAATw0ACyAHIAZrIQggBAshCSAIBEBBACEDDAILCwwBCyALIANqIAkgCBALGgsgDSgCACIIQT9xIQkgDSAIQQFqNgIAIApBIGohCwJAAkBBwAAgCWsiCEEBSwRAQcSRBCEDQQEhCAwBBSALIAlqQQAgCBAYGiAIQcSRBGohAyAKIAsQDEEBIAhrIghBwABJBH8gAwUgCUGBf2oiB0FAcSIGIAlrQcSSBGohBCAIIQkgAyEIA0AgCyAIKQAANwAAIAsgCCkACDcACCALIAgpABA3ABAgCyAIKQAYNwAYIAsgCCkAIDcAICALIAgpACg3ACggCyAIKQAwNwAwIAsgCCkAODcAOCAIQUBrIQggCiALEAwgCUFAaiIJQcAATw0ACyAHIAZrIQggBAshCSAIBEAgCSEDQQAhCQwCCwsMAQsgCyAJaiADIAgQCxoLIA0oAgAiCUE/cSEDIA0gCSACajYCAEHAACADayIJIAJLBEAgASEIIAIhCQUgCkEgaiIHIANqIAEgCRALGiABIAlqIQggCiAHEAwgAiAJayIJQcAASQR/QQAFIAMgAmpBgH9qIgZBQHEiBEGAAWogA2shAwNAIAcgCCkAADcAACAHIAgpAAg3AAggByAIKQAQNwAQIAcgCCkAGDcAGCAHIAgpACA3ACAgByAIKQAoNwAoIAcgCCkAMDcAMCAHIAgpADg3ADggCEFAayEIIAogBxAMIAlBQGoiCUHAAE8NAAsgASADaiEIIAYgBGshCUEACyEDCyAJBEAgCkEgaiADaiAIIAkQCxoLIApByAFqIQggCkHoAWoiCSANKAIAIgNBHXZBGHQ2AgAgCSADQQt0QYCA/AdxIANBG3RyIANBBXZBgP4DcXIgA0EVdkH/AXFyNgIEIA0gA0E3IANrQT9xQQFqIgRqNgIAIApBIGohBwJAAkAgBEHAACADQT9xIgNrIgZJBEBB+YwEIQYMAQUgByADakH5jAQgBhALGiAGQfmMBGohAyAKIAcQDCAEIAZrIgRBwABPBEADQCAHIAMpAAA3AAAgByADKQAINwAIIAcgAykAEDcAECAHIAMpABg3ABggByADKQAgNwAgIAcgAykAKDcAKCAHIAMpADA3ADAgByADKQA4NwA4IANBQGshAyAKIAcQDCAEQUBqIgRBwABPDQALCyAEBEAgAyEGQQAhAwwCCwsMAQsgByADaiAGIAQQCxoLIA0oAgAiA0E/cSEGIA0gA0EIajYCACAKQSBqIQcCQAJAQcAAIAZrIgRBCEsEQCAJIQNBCCEEDAEFIAcgBmogCSAEEAsaIAkgBGohAyAKIAcQDEEIIARrIgRBwABPBEADQCAHIAMpAAA3AAAgByADKQAINwAIIAcgAykAEDcAECAHIAMpABg3ABggByADKQAgNwAgIAcgAykAKDcAKCAHIAMpADA3ADAgByADKQA4NwA4IANBQGshAyAKIAcQDCAEQUBqIgRBwABPDQALCyAEBEBBACEGDAILCwwBCyAHIAZqIAMgBBALGgsgCigCABAJIRIgCkEANgIAIApBBGoiGigCABAJIRAgGkEANgIAIApBCGoiGygCABAJIQ4gG0EANgIAIApBDGoiHCgCABAJIQsgHEEANgIAIApBEGoiHSgCABAJIQcgHUEANgIAIApBFGoiHigCABAJIQYgHkEANgIAIApBGGoiHygCABAJIQQgH0EANgIAIApBHGoiICgCABAJIQMgIEEANgIAIAggEjYCACAIQQRqIiIgEDYCACAIQQhqIiMgDjYCACAIQQxqIiQgCzYCACAIQRBqIiUgBzYCACAIQRRqIiYgBjYCACAIQRhqIicgBDYCACAIQRxqIiggAzYCACAKQeQAaiEMIApBxAFqIhEoAgAiA0E/cSEGIBEgA0EgajYCACAKQYQBaiEFAkACQEHAACAGayIHQSBLBEAgCCEDIAYhBEEgIQYMAQUgBSAGaiAIIAcQCxogCCAHaiEEIAwgBRAMQSAgB2siA0HAAEkEfyADIQYgBAUgBkGgf2oiBkEGdkEBdCELIAdBQGohBwNAIAUgBCkAADcAACAFIAQpAAg3AAggBSAEKQAQNwAQIAUgBCkAGDcAGCAFIAQpACA3ACAgBSAEKQAoNwAoIAUgBCkAMDcAMCAFIAQpADg3ADggBEFAayEEIAwgBRAMIANBQGoiA0HAAE8NAAsgBkE/cSEGIAggC0EEakEFdGogB2oLIQMgBgRAQQAhBAwCCwsMAQsgBSAEaiADIAYQCxoLIAkgESgCACIDQR12QRh0NgIAIAkgA0ELdEGAgPwHcSADQRt0ciADQQV2QYD+A3FyIANBFXZB/wFxcjYCBCARIANBNyADa0E/cUEBaiIEajYCAAJAAkAgBEHAACADQT9xIgNrIgZJBEBB+YwEIQYMAQUgBSADakH5jAQgBhALGiAGQfmMBGohAyAMIAUQDCAEIAZrIgRBwABPBEADQCAFIAMpAAA3AAAgBSADKQAINwAIIAUgAykAEDcAECAFIAMpABg3ABggBSADKQAgNwAgIAUgAykAKDcAKCAFIAMpADA3ADAgBSADKQA4NwA4IANBQGshAyAMIAUQDCAEQUBqIgRBwABPDQALCyAEBEAgAyEGQQAhAwwCCwsMAQsgBSADaiAGIAQQCxoLIBEoAgAiA0E/cSEGIBEgA0EIajYCAAJAAkBBwAAgBmsiBEEISwRAIAkhA0EIIQQMAQUgBSAGaiAJIAQQCxogCSAEaiEDIAwgBRAMQQggBGsiBEHAAE8EQANAIAUgAykAADcAACAFIAMpAAg3AAggBSADKQAQNwAQIAUgAykAGDcAGCAFIAMpACA3ACAgBSADKQAoNwAoIAUgAykAMDcAMCAFIAMpADg3ADggA0FAayEDIAwgBRAMIARBQGoiBEHAAE8NAAsLIAQEQEEAIQYMAgsLDAELIAUgBmogAyAEEAsaCyAMKAIAEAkhEiAMQQA2AgAgCkHoAGoiEygCABAJIRAgE0EANgIAIApB7ABqIhQoAgAQCSEOIBRBADYCACAKQfAAaiIVKAIAEAkhCyAVQQA2AgAgCkH0AGoiFigCABAJIQcgFkEANgIAIApB+ABqIhcoAgAQCSEGIBdBADYCACAKQfwAaiIYKAIAEAkhBCAYQQA2AgAgCkGAAWoiISgCABAJIQMgIUEANgIAIABBIGoiLiASNgAAIABBJGoiLyAQNgAAIABBKGoiMCAONgAAIABBLGoiMSALNgAAIABBMGoiMiAHNgAAIABBNGoiMyAGNgAAIABBOGoiNCAENgAAIABBPGoiNSADNgAAIAogGRATIA0oAgAiA0E/cSEHIA0gA0EgajYCACAKQSBqIRACQAJAQcAAIAdrIgNBIEsEQCAAIQMgByEGQSAhBAwBBSAQIAdqIAAgAxALGiAAIANqIQYgCiAQEAxBICADayIEQcAASQR/IAYFIABB5ABqIAdBoH9qIg5BQHEiC0EcciAHa2ohByAEIQMgBiEEA0AgECAEKQAANwAAIBAgBCkACDcACCAQIAQpABA3ABAgECAEKQAYNwAYIBAgBCkAIDcAICAQIAQpACg3ACggECAEKQAwNwAwIBAgBCkAODcAOCAEQUBrIQQgCiAQEAwgA0FAaiIDQcAATw0ACyAOIAtrIQQgBwshAyAEBEBBACEGDAILCwwBCyAQIAZqIAMgBBALGgsgCSANKAIAIgNBHXZBGHQ2AgAgCSADQQt0QYCA/AdxIANBG3RyIANBBXZBgP4DcXIgA0EVdkH/AXFyNgIEIA0gA0E3IANrQT9xQQFqIgRqNgIAIApBIGohBwJAAkAgBEHAACADQT9xIgNrIgZJBEBB+YwEIQYMAQUgByADakH5jAQgBhALGiAGQfmMBGohAyAKIAcQDCAEIAZrIgRBwABPBEADQCAHIAMpAAA3AAAgByADKQAINwAIIAcgAykAEDcAECAHIAMpABg3ABggByADKQAgNwAgIAcgAykAKDcAKCAHIAMpADA3ADAgByADKQA4NwA4IANBQGshAyAKIAcQDCAEQUBqIgRBwABPDQALCyAEBEAgAyEGQQAhAwwCCwsMAQsgByADaiAGIAQQCxoLIA0oAgAiA0E/cSEGIA0gA0EIajYCACAKQSBqIQcCQAJAQcAAIAZrIgRBCEsEQCAJIQNBCCEEDAEFIAcgBmogCSAEEAsaIAkgBGohAyAKIAcQDEEIIARrIgRBwABPBEADQCAHIAMpAAA3AAAgByADKQAINwAIIAcgAykAEDcAECAHIAMpABg3ABggByADKQAgNwAgIAcgAykAKDcAKCAHIAMpADA3ADAgByADKQA4NwA4IANBQGshAyAKIAcQDCAEQUBqIgRBwABPDQALCyAEBEBBACEGDAILCwwBCyAHIAZqIAMgBBALGgsgCigCABAJIRIgCkEANgIAIBooAgAQCSEQIBpBADYCACAbKAIAEAkhDiAbQQA2AgAgHCgCABAJIQsgHEEANgIAIB0oAgAQCSEHIB1BADYCACAeKAIAEAkhBiAeQQA2AgAgHygCABAJIQQgH0EANgIAICAoAgAQCSEDICBBADYCACAIIBI2AgAgIiAQNgIAICMgDjYCACAkIAs2AgAgJSAHNgIAICYgBjYCACAnIAQ2AgAgKCADNgIAIBEoAgAiA0E/cSEGIBEgA0EgajYCAAJAAkBBwAAgBmsiB0EgSwRAIAghAyAGIQRBICEGDAEFIAUgBmogCCAHEAsaIAggB2ohBCAMIAUQDEEgIAdrIgNBwABJBH8gAyEGIAQFIAZBoH9qIgZBBnZBAXQhCyAHQUBqIQcDQCAFIAQpAAA3AAAgBSAEKQAINwAIIAUgBCkAEDcAECAFIAQpABg3ABggBSAEKQAgNwAgIAUgBCkAKDcAKCAFIAQpADA3ADAgBSAEKQA4NwA4IARBQGshBCAMIAUQDCADQUBqIgNBwABPDQALIAZBP3EhBiAIIAtBBGpBBXRqIAdqCyEDIAYEQEEAIQQMAgsLDAELIAUgBGogAyAGEAsaCyAJIBEoAgAiA0EddkEYdDYCACAJIANBC3RBgID8B3EgA0EbdHIgA0EFdkGA/gNxciADQRV2Qf8BcXI2AgQgESADQTcgA2tBP3FBAWoiBGo2AgACQAJAIARBwAAgA0E/cSIDayIGSQRAQfmMBCEGDAEFIAUgA2pB+YwEIAYQCxogBkH5jARqIQMgDCAFEAwgBCAGayIEQcAATwRAA0AgBSADKQAANwAAIAUgAykACDcACCAFIAMpABA3ABAgBSADKQAYNwAYIAUgAykAIDcAICAFIAMpACg3ACggBSADKQAwNwAwIAUgAykAODcAOCADQUBrIQMgDCAFEAwgBEFAaiIEQcAATw0ACwsgBARAIAMhBkEAIQMMAgsLDAELIAUgA2ogBiAEEAsaCyARKAIAIgNBP3EhBiARIANBCGo2AgACQAJAQcAAIAZrIgRBCEsEQCAJIQNBCCEEDAEFIAUgBmogCSAEEAsaIAkgBGohAyAMIAUQDEEIIARrIgRBwABPBEADQCAFIAMpAAA3AAAgBSADKQAINwAIIAUgAykAEDcAECAFIAMpABg3ABggBSADKQAgNwAgIAUgAykAKDcAKCAFIAMpADA3ADAgBSADKQA4NwA4IANBQGshAyAMIAUQDCAEQUBqIgRBwABPDQALCyAEBEBBACEGDAILCwwBCyAFIAZqIAMgBBALGgsgDCgCABAJIRIgDEEANgIAIBMoAgAQCSEQIBNBADYCACAUKAIAEAkhDiAUQQA2AgAgFSgCABAJIQsgFUEANgIAIBYoAgAQCSEHIBZBADYCACAXKAIAEAkhBiAXQQA2AgAgGCgCABAJIQQgGEEANgIAICEoAgAQCSEDICFBADYCACAAIBI2AAAgAEEEaiIpIBA2AAAgAEEIaiIqIA42AAAgAEEMaiIrIAs2AAAgAEEQaiIsIAc2AAAgAEEUaiItIAY2AAAgAEEYaiISIAQ2AAAgAEEcaiIQIAM2AAAgCiAZEBMgDSgCACIDQT9xIQcgDSADQSBqNgIAIApBIGohDwJAAkBBwAAgB2siA0EgSwRAIAAhAyAHIQZBICEEDAEFIA8gB2ogACADEAsaIAAgA2ohBiAKIA8QDEEgIANrIgRBwABJBH8gBgUgAEHkAGogB0Ggf2oiDkFAcSILQRxyIAdraiEHIAQhAyAGIQQDQCAPIAQpAAA3AAAgDyAEKQAINwAIIA8gBCkAEDcAECAPIAQpABg3ABggDyAEKQAgNwAgIA8gBCkAKDcAKCAPIAQpADA3ADAgDyAEKQA4NwA4IARBQGshBCAKIA8QDCADQUBqIgNBwABPDQALIA4gC2shBCAHCyEDIAQEQEEAIQYMAgsLDAELIA8gBmogAyAEEAsaCyANKAIAIgRBP3EhAyANIARBAWo2AgAgCkEgaiEPAkACQEHAACADayIEQQFLBEBB+IwEIQZBASEEDAEFIA8gA2pBASAEEBgaIARB+IwEaiEGIAogDxAMQQEgBGsiBEHAAEkEfyAGBSADQYF/aiIOQUBxIgsgA2tB+I0EaiEHIAQhAyAGIQQDQCAPIAQpAAA3AAAgDyAEKQAINwAIIA8gBCkAEDcAECAPIAQpABg3ABggDyAEKQAgNwAgIA8gBCkAKDcAKCAPIAQpADA3ADAgDyAEKQA4NwA4IARBQGshBCAKIA8QDCADQUBqIgNBwABPDQALIA4gC2shBCAHCyEDIAQEQCADIQZBACEDDAILCwwBCyAPIANqIAYgBBALGgsgDSgCACIDQT9xIQYgDSADIAJqNgIAQcAAIAZrIgMgAksEQCAGIQQFIApBIGoiDiAGaiABIAMQCxogASADaiEEIAogDhAMIAIgA2siA0HAAEkEfyAEIQFBACEEIAMFIAYgAmpBgH9qIgtBQHEiB0GAAWogBmshBiADIQIgBCEDA0AgDiADKQAANwAAIA4gAykACDcACCAOIAMpABA3ABAgDiADKQAYNwAYIA4gAykAIDcAICAOIAMpACg3ACggDiADKQAwNwAwIA4gAykAODcAOCADQUBrIQMgCiAOEAwgAkFAaiICQcAATw0ACyABIAZqIQFBACEEIAsgB2sLIQILIAIEQCAKQSBqIARqIAEgAhALGgsgCSANKAIAIgFBHXZBGHQ2AgAgCSABQQt0QYCA/AdxIAFBG3RyIAFBBXZBgP4DcXIgAUEVdkH/AXFyNgIEIA0gAUE3IAFrQT9xQQFqIgJqNgIAIApBIGohBAJAAkAgAkHAACABQT9xIgFrIgNJBEBB+YwEIQMMAQUgBCABakH5jAQgAxALGiADQfmMBGohASAKIAQQDCACIANrIgJBwABPBEADQCAEIAEpAAA3AAAgBCABKQAINwAIIAQgASkAEDcAECAEIAEpABg3ABggBCABKQAgNwAgIAQgASkAKDcAKCAEIAEpADA3ADAgBCABKQA4NwA4IAFBQGshASAKIAQQDCACQUBqIgJBwABPDQALCyACBEAgASEDQQAhAQwCCwsMAQsgBCABaiADIAIQCxoLIA0oAgAiAUE/cSEDIA0gAUEIajYCACAKQSBqIQQCQAJAQcAAIANrIgJBCEsEQCAJIQFBCCECDAEFIAQgA2ogCSACEAsaIAkgAmohASAKIAQQDEEIIAJrIgJBwABPBEADQCAEIAEpAAA3AAAgBCABKQAINwAIIAQgASkAEDcAECAEIAEpABg3ABggBCABKQAgNwAgIAQgASkAKDcAKCAEIAEpADA3ADAgBCABKQA4NwA4IAFBQGshASAKIAQQDCACQUBqIgJBwABPDQALCyACBEBBACEDDAILCwwBCyAEIANqIAEgAhALGgsgCigCABAJIQ4gCkEANgIAIBooAgAQCSELIBpBADYCACAbKAIAEAkhByAbQQA2AgAgHCgCABAJIQYgHEEANgIAIB0oAgAQCSEEIB1BADYCACAeKAIAEAkhAyAeQQA2AgAgHygCABAJIQIgH0EANgIAICAoAgAQCSEBICBBADYCACAIIA42AgAgIiALNgIAICMgBzYCACAkIAY2AgAgJSAENgIAICYgAzYCACAnIAI2AgAgKCABNgIAIBEoAgAiAUE/cSEDIBEgAUEgajYCAAJAAkBBwAAgA2siBEEgSwRAIAghASADIQJBICEDDAEFIAUgA2ogCCAEEAsaIAggBGohAiAMIAUQDEEgIARrIgFBwABJBH8gASEDIAIFIANBoH9qIgNBBnZBAXQhBiAEQUBqIQQDQCAFIAIpAAA3AAAgBSACKQAINwAIIAUgAikAEDcAECAFIAIpABg3ABggBSACKQAgNwAgIAUgAikAKDcAKCAFIAIpADA3ADAgBSACKQA4NwA4IAJBQGshAiAMIAUQDCABQUBqIgFBwABPDQALIANBP3EhAyAIIAZBBGpBBXRqIARqCyEBIAMEQEEAIQIMAgsLDAELIAUgAmogASADEAsaCyAJIBEoAgAiAUEddkEYdDYCACAJIAFBC3RBgID8B3EgAUEbdHIgAUEFdkGA/gNxciABQRV2Qf8BcXI2AgQgESABQTcgAWtBP3FBAWoiAmo2AgACQAJAIAJBwAAgAUE/cSIBayIDSQRAQfmMBCEDDAEFIAUgAWpB+YwEIAMQCxogA0H5jARqIQEgDCAFEAwgAiADayICQcAATwRAA0AgBSABKQAANwAAIAUgASkACDcACCAFIAEpABA3ABAgBSABKQAYNwAYIAUgASkAIDcAICAFIAEpACg3ACggBSABKQAwNwAwIAUgASkAODcAOCABQUBrIQEgDCAFEAwgAkFAaiICQcAATw0ACwsgAgRAIAEhA0EAIQEMAgsLDAELIAUgAWogAyACEAsaCyARKAIAIgFBP3EhAyARIAFBCGo2AgACQAJAQcAAIANrIgJBCEsEQCAJIQFBCCECDAEFIAUgA2ogCSACEAsaIAkgAmohASAMIAUQDEEIIAJrIgJBwABPBEADQCAFIAEpAAA3AAAgBSABKQAINwAIIAUgASkAEDcAECAFIAEpABg3ABggBSABKQAgNwAgIAUgASkAKDcAKCAFIAEpADA3ADAgBSABKQA4NwA4IAFBQGshASAMIAUQDCACQUBqIgJBwABPDQALCyACBEBBACEDDAILCwwBCyAFIANqIAEgAhALGgsgDCgCABAJIQ4gDEEANgIAIBMoAgAQCSELIBNBADYCACAUKAIAEAkhByAUQQA2AgAgFSgCABAJIQYgFUEANgIAIBYoAgAQCSEEIBZBADYCACAXKAIAEAkhAyAXQQA2AgAgGCgCABAJIQIgGEEANgIAICEoAgAQCSEBICFBADYCACAuIA42AAAgLyALNgAAIDAgBzYAACAxIAY2AAAgMiAENgAAIDMgAzYAACA0IAI2AAAgNSABNgAAIAogGRATIA0oAgAiAUE/cSEEIA0gAUEgajYCACAKQSBqIQsCQAJAQcAAIARrIgFBIEsEQCAAIQEgBCEDQSAhAgwBBSALIARqIAAgARALGiAAIAFqIQMgCiALEAxBICABayICQcAASQR/IAMFIABB5ABqIARBoH9qIgdBQHEiBkEcciAEa2ohBCACIQEgAyECA0AgCyACKQAANwAAIAsgAikACDcACCALIAIpABA3ABAgCyACKQAYNwAYIAsgAikAIDcAICALIAIpACg3ACggCyACKQAwNwAwIAsgAikAODcAOCACQUBrIQIgCiALEAwgAUFAaiIBQcAATw0ACyAHIAZrIQIgBAshASACBEBBACEDDAILCwwBCyALIANqIAEgAhALGgsgCSANKAIAIgFBHXZBGHQ2AgAgCSABQQt0QYCA/AdxIAFBG3RyIAFBBXZBgP4DcXIgAUEVdkH/AXFyNgIEIA0gAUE3IAFrQT9xQQFqIgJqNgIAIApBIGohBAJAAkAgAkHAACABQT9xIgFrIgNJBEBB+YwEIQMMAQUgBCABakH5jAQgAxALGiADQfmMBGohASAKIAQQDCACIANrIgJBwABPBEADQCAEIAEpAAA3AAAgBCABKQAINwAIIAQgASkAEDcAECAEIAEpABg3ABggBCABKQAgNwAgIAQgASkAKDcAKCAEIAEpADA3ADAgBCABKQA4NwA4IAFBQGshASAKIAQQDCACQUBqIgJBwABPDQALCyACBEAgASEDQQAhAQwCCwsMAQsgBCABaiADIAIQCxoLIA0oAgAiAUE/cSEDIA0gAUEIajYCACAKQSBqIQQCQAJAQcAAIANrIgJBCEsEQCAJIQFBCCECDAEFIAQgA2ogCSACEAsaIAkgAmohASAKIAQQDEEIIAJrIgJBwABPBEADQCAEIAEpAAA3AAAgBCABKQAINwAIIAQgASkAEDcAECAEIAEpABg3ABggBCABKQAgNwAgIAQgASkAKDcAKCAEIAEpADA3ADAgBCABKQA4NwA4IAFBQGshASAKIAQQDCACQUBqIgJBwABPDQALCyACBEBBACEDDAILCwwBCyAEIANqIAEgAhALGgsgCigCABAJIQ4gCkEANgIAIBooAgAQCSELIBpBADYCACAbKAIAEAkhByAbQQA2AgAgHCgCABAJIQYgHEEANgIAIB0oAgAQCSEEIB1BADYCACAeKAIAEAkhAyAeQQA2AgAgHygCABAJIQIgH0EANgIAICAoAgAQCSEBICBBADYCACAIIA42AgAgIiALNgIAICMgBzYCACAkIAY2AgAgJSAENgIAICYgAzYCACAnIAI2AgAgKCABNgIAIBEoAgAiAUE/cSEDIBEgAUEgajYC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AEIANwIQIABCADcCGAsgASABKAIAIARqNgIAIAMkBEEBC9YDAQN/IwQhAyMEQYABaiQEIAAgASkCADcCACAAIAEpAgg3AgggACABKQIQNwIQIAAgASkCGDcCGCAAIAEpAiA3AiAgA0HQAGoiBSABEAcgA0EoaiIEIAEgBRAKIABBADYCUCADIAQoAgBBB2o2AgAgAyAEKAIENgIEIAMgBCgCCDYCCCADIAQoAgw2AgwgAyAEKAIQNgIQIAMgBCgCFDYCFCADIAQoAhg2AhggAyAEKAIcNgIcIAMgBCgCIDYCICADIAQoAiQ2AiQgAEEoaiIFIAMQIkUEQCADJARBAA8LIAUQFiAFKAIAIgFBAXEgAkYEQCADJARBAQ8LIAVBvOH//wAgAWs2AgAgAEEsaiIBQfz9//8AIAEoAgBrNgIAIABBMGoiAUH8////ACABKAIAazYCACAAQTRqIgFB/P///wAgASgCAGs2AgAgAEE4aiIBQfz///8AIAEoAgBrNgIAIABBPGoiAUH8////ACABKAIAazYCACAAQUBrIgFB/P///wAgASgCAGs2AgAgAEHEAGoiAUH8////ACABKAIAazYCACAAQcgAaiIBQfz///8AIAEoAgBrNgIAIABBzABqIgBB/P//ByAAKAIAazYCACADJARBAQv2CwIRfwJ+IwQhBSMEQaADaiQEIAVBuAJqIgJCADcAACACQgA3AAggAkIANwAQIAJCADcAGCACQgA3ACAgAkIANwAoIAJCADcAMCACQgA3ADggAUUEQCAAQQA2ApwBIABBJGoiA0GQiAQpAgA3AgAgA0GYiAQpAgA3AgggA0GgiAQpAgA3AhAgA0GoiAQpAgA3AhggA0GwiAQpAgA3AiAgAEEBNgJ0IABB+ABqIgNCADcCACADQgA3AgggA0IANwIQIANCADcCGCADQQA2AiAgAEGEuLznADYCTCAAQf61r/AANgJQIABBuMz59QA2AlQgAEHny/X2ADYCWCAAQcjQi/gANgJcIABB0vvu4wA2AmAgAEG8gMHtADYCZCAAQYbVuecANgJoIABB2bKj7AA2AmwgAEHG4rcHNgJwIABBATYCBCAAQQhqIgNCADcCACADQgA3AgggA0IANwIQIANBADYCGAsgBUH4AmoiBiAAQQRqIg8QESACIAYpAAA3AAAgAiAGKQAINwAIIAIgBikAEDcAECACIAYpABg3ABggAUEARyIHBEAgAkEgaiIDIAEpAAA3AAAgAyABKQAINwAIIAMgASkAEDcAECADIAEpABg3ABgLIAVBkAJqIQggBUHwAWohBCAFQfAAaiEDIAVByABqIQEgBUEEaiIQIAIgBwR/QcAABUEgCxAqIAJCADcAACACQgA3AAggAkIANwAQIAJCADcAGCACQgA3ACAgAkIANwAoIAJCADcAMCACQgA3ADggAUEEaiECIAFBCGohByABQQxqIQkgAUEQaiEKIAFBFGohCyABQRhqIQwgAUEcaiENIAFBIGohESABQSRqIRIDQCAQIAYQHyAFIAEgBhAURSIONgIAIA4EQCAFQQE2AgAMAQUgBSACKAIAIAEoAgByIAcoAgByIAkoAgByIAooAgByIAsoAgByIAwoAgByIA0oAgByIBEoAgByIBIoAgByRSIONgIAIA4NAQsLIAggARAHIABBJGoiAiACIAgQCiAAQcwAaiIHIAcgCBAKIAcgByABEAogAEH0AGoiCCAIIAEQCiABQgA3AgAgAUIANwIIIAFCADcCECABQgA3AhggAUIANwIgIARBBGohASAEQQhqIQggBEEMaiEHIARBEGohCSAEQRRqIQogBEEYaiELIARBHGohDANAIBAgBhAfIAQgBiAFEA4gBSgCAARAIAVBATYCAAwBBSAFIAEoAgAgBCgCAHIgCCgCAHIgBygCAHIgCSgCAHIgCigCAHIgCygCAHIgDCgCAHJFIg02AgAgDQ0BCwsgBkIANwAAIAZCADcACCAGQgA3ABAgBkIANwAYIAAgAyAEEB4gBCAEKAIAIgBBf3OtQsKC2YENfCITIAEoAgAiBiAAciAIKAIAIgByIAcoAgAiEHIgCSgCACINciAKKAIAIhFyIAsoAgAiEnIgDCgCACIOckEAR0EfdEEfda0iFIM+AgAgASATQiCIQoy9yf4LhCAGQX9zrXwiEyAUgz4CACAIIABBf3OtQrvAovoKfCATQiCIfCITIBSDPgIAIAcgEEF/c61C5rm71Qt8IBNCIIh8IhMgFIM+AgAgCSANQX9zrUL+////D3wgE0IgiHwiEyAUgz4CACAKIBFBf3OtQv////8PfCATQiCIfCITIBSDPgIAIAsgEkF/c61C/////w98IBNCIIh8IhMgFIM+AgAgDCAO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KSAGQQhqISogBkEMaiErIAZBEGohLCAGQRRqIS0gBkEYaiEuIAZBHGohLyAGQSBqITAgBkEkaiExIANBBGohMiADQQhqITMgA0EMaiE0IANBEGohNSADQRRqITYgA0EYaiE3IANBHGohOCADQSBqITkgA0EkaiE6IARBBGohOyAEQQhqIQkgBEEMaiEMIARBEGohDiAEQRRqIQ8gBEEYaiERIARBHGohEiAEQSBqIRMgBEEkaiEVIA0oAgBBvOH//wBqIRYgDSgCBEH8/f//AGohFyANKAIIQfz///8AaiEYIA0oAgxB/P///wBqIRkgDSgCEEH8////AGohGiANKAIUQfz///8AaiEbIA0oAhhB/P///wBqIRwgDSgCHEH8////AGohHSANKAIgQfz///8AaiEeIA0oAiRB/P//B2ohH0H/PyEBA0AgBiAHIAFBf2oiAkEGdGoiIBAjIBAgECAGEAogFCAQEAcgKCAUIBAQCiAGIAYgFBAKICkoAgAhISAqKAIAISIgKygCACEjICwoAgAhJCAtKAIAISUgLigCACEmIC8oAgAhJyAwKAIAIQsgMSgCACEFIAYgFiAGKAIAazYCACApIBcgIWs2AgAgKiAYICJrNgIAICsgGSAjazYCACAsIBogJGs2AgAgLSAbICVrNgIAIC4gHCAmazYCACAvIB0gJ2s2AgAgMCAeIAtrNgIAIDEgHyAFazYCACAKIAogKBAKIAMgBikCADcCACADIAYpAgg3AgggAyAGKQIQNwIQIAMgBikCGDcCGCADIAYpAiA3AiAgAxAPIAQgCikCADcCACAEIAopAgg3AgggBCAKKQIQNwIQIAQgCikCGDcCGCAEIAopAiA3AiAgBBAPICAgMigCACILQRp0IAMoAgByNgIAIAcgAkEGdGogMygCACIFQRR0IAtBBnZyNgIEIAcgAkEGdGogNCgCACILQQ50IAVBDHZyNgIIIAcgAkEGdGogNSgCACIFQQh0IAtBEnZyNgIMIAcgAkEGdGogNigCAEECdCAFQRh2ciA3KAIAIgVBHHRyNgIQIAcgAkEGdGogOCgCACILQRZ0IAVBBHZyNgIUIAcgAkEGdGogOSgCACIFQRB0IAtBCnZyNgIYIAcgAkEGdGogOigCAEEKdCAFQRB2cjYCHCAHIAJBBnRqIDsoAgAiC0EadCAEKAIA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IAYoAgBFBEAgBygCBCAHKAIAciAHKAIIciAHKAIMciAHKAIQciAHKAIUciAHKAIYciAHKAIccgRAIAkgAkEAEA4CQCAMIAIgA0EAIAVBACAOQQFxEQEAIgAEQCAIQQRqIRAgCEEIaiERIAhBDGohEiAIQRBqIRMgCEEUaiEUIAhBGGohFSAIQRxqIRZBACEEA0AgCCAMIAYQDiAGKAIARQRAIBAoAgAgCCgCAHIgESgCAHIgEigCAHIgEygCAHIgFCgCAHIgFSgCAHIgFigCAHIEQCAPIAogCyAHIAkgCCANEDENBAsLIAwgAiADQQAgBSAEQQFqIgQgDkEBcREBACIADQBBACEACwVBACEACwsgCUIANwIAIAlCADcCCCAJQgA3AhAgCUIANwIYIAhCADcCACAIQgA3AgggCEIANwIQIAhCADcCGCAHQgA3AgAgB0IANwIIIAdCADcCECAHQgA3AhggAARAIA0oAgAhAyABIAopAAA3AAAgASAKKQAINwAIIAEgCikAEDcAECABIAopABg3ABggAUEgaiICIAspAAA3AAAgAiALKQAINwAIIAIgCykAEDcAECACIAspABg3ABggAUFAayADOgAAIAYkBCAADwsLCyABQgA3AAAgAUIANwAIIAFCADcAECABQgA3ABggAUIANwAgIAFCADcAKCABQgA3ADAgAUIANwA4IAFBQGtBADoAACAGJARBAAv+AQECfyMEIQQjBEFAayQEIAFFBEBByooEIAAoAqgBIAAoAqQBQQNxQQJqEQAAIAQkBEEADwsgA0UEQEGuigQgACgCqAEgACgCpAFBA3FBAmoRAAAgBCQEQQAPCyAEQSBqIQUgAgR/IAUgAykAADcAACAFIAMpAAg3AAggBSADKQAQNwAQIAUgAykAGDcAGCAEIANBIGoiACkAADcAACAEIAApAAg3AAggBCAAKQAQNwAQIAQgACkAGDcAGCACIANBQGstAAA2AgAgASAFEBEgAUEgaiAEEBEgBCQEQQEFQb6MBCAAKAKoASAAKAKkAUEDcUECahEAACAEJARBAAsL7wIBA38jBCEEIwRB0ABqJAQgBEEANgIAIAFFBEBBrooEIAAoAqgBIAAoAqQBQQNxQQJqEQAAIAQkBEEADwsgAkUEQEG6igQgACgCqAEgACgCpAFBA3FBAmoRAAAgBCQEQQAPCyADQQNLBEBBpYwEIAAoAqgBIAAoAqQBQQNxQQJqEQAAIAQkBEEADwsgBEEoaiIFIAIgBBAOIAQoAgAhACAEQQhqIgYgAkEgaiAEEA4gBCgCACAAckUiACECIAAEfyABIAUpAAA3AAAgASAFKQAINwAIIAEgBSkAEDcAECABIAUpABg3ABggAUEgaiIAIAYpAAA3AAAgACAGKQAINwAIIAAgBikAEDcAECAAIAYpABg3ABggAUFAayADOgAAIAQkBCACBSABQgA3AAAgAUIANwAIIAFCADcAECABQgA3ABggAUIANwAgIAFCADcAKCABQgA3ADAgAUIANwA4IAFBQGtBADoAACAEJAQgAgsLlCoBX38jBCEHIwRBwANqJAQgB0GgAWohCCAHQfgAaiEKIAFB+ABqIUAgB0GQA2oiBiABQdAAaiI9EAcgB0HoAmoiAyABKQIANwIAIAMgASkCCDcCCCADIAEpAhA3AhAgAyABKQIYNwIYIAMgASkCIDcCICADQSRqIiUoAgAiFEEWdiIEQdEHbCADKAIAaiEFIARBBnQgA0EEaiImKAIAaiAFQRp2aiIVQRp2IANBCGoiJygCAGoiFkEadiADQQxqIhwoAgBqIhdBGnYgA0EQaiIdKAIAaiIYQRp2IANBFGoiMSgCAGoiDkEadiADQRhqIjIoAgBqIiBBGnYgA0EcaiIzKAIAaiIhQRp2IANBIGoiNCgCAGohBCADIAVB////H3E2AgAgJiAVQf///x9xNgIAICcgFkH///8fcTYCACAcIBdB////H3E2AgAgHSAYQf///x9xNgIAIDEgDkH///8fcTYCACAyICBB////H3E2AgAgMyAhQf///x9xNgIAIDQgBEH///8fcTYCACAlIARBGnYgFEH///8BcWo2AgAgB0HAAmoiBCACIAYQCiABKAJMIhlBFnYiBUHRB2wgASgCKGohGiAFQQZ0IAEoAixqIBpBGnZqIihBGnYgASgCMGoiKUEadiABKAI0aiIqQRp2IAEoAjhqIitBGnYgASgCPGoiLEEadiABQUBrKAIAaiItQRp2IAEoAkRqIiJBGnYgASgCSGohHiAHQZgCaiIFIAJBKGoiWCAGEAogBSAFID0QCiAHQfABaiIBIAMpAgA3AgAgASADKQIINwIIIAEgAykCEDcCECABIAMpAhg3AhggASAD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aiI6KAIAayETIDogEzYCAEH8////ACAKQSBqIjsoAgBrIR8gOyAfNgIAQfz//wcgCkEkaiI/KAIAayEbID8gGzYCACAuKAIAIBtqIkJBFnYiPEHRB2wgASgCACAkamohGyA8QQZ0IBQoAgAgCWpqIBtBGnZqIiRBGnYgFSgCACALamoiC0EadiAWKAIAIA9qaiIPQRp2IBcoAgAgDGpqIgxBGnYgGCgCACANamoiDUEadiAOKAIAIBJqaiISQRp2ICAoAgAgE2pqIhNBGnYgISgCACAfamohCSABIBtB////H3EiHzYCACAUICRB////H3EiGzYCACAVIAtB////H3EiCzYCACAWIA9B////H3EiDzYCACAXIAxB////H3EiDDYCACAYIA1B////H3EiDTYCACAOIBJB////H3EiEjYCACAgIBNB////H3EiEzYCACAhIAlB////H3EiJDYCACAuIAlBGnYgQkH///8BcWoiCTYCACAAIAEpAgA3AgAgACABKQIINwIIIAAgASkCEDcCECAAIAEpAhg3AhggACABKQIgNwIgIAEgH0EBdCAKKAIAajYCACAUIBtBAXQgAygCAGo2AgAgFSALQQF0IBAoAgBqNgIAIBYgD0EBdCARKAIAajYCACAXIAxBAXQgIygCAGo2AgAgGCANQQF0IDAoAgBqNgIAIA4gEkEBdCA5KAIAajYCACAgIBNBAXQgOigCAGo2AgAgISAkQQF0IDsoAgBqNgIAIC4gCUEBdCA/KAIAajYCACABIAEgBxAKIAEgASgCACAIKAIAaiIBNgIAIBQgFCgCACAeKAIAaiIDNgIAIBUgFSgCACAZKAIAaiIINgIAIBYgFigCACAlKAIAaiIKNgIAIBcgFygCACAmKAIAaiIUNgIAIBggGCgCACAnKAIAaiIVNgIAIA4gDigCACAcKAIAaiIWNgIAICAgICgCACAdKAIAaiIXNgIAICEgISgCACAiKAIAaiIYNgIAIC4gLigCACAvKAIAaiIONgIAQfj//w8gDmsiD0EWdiIOQdEHbEH4wv//ASABa2ohASAOQQZ0Qfj7//8BIANraiABQRp2aiIcQRp2Qfj///8BIAhraiIdQRp2Qfj///8BIApraiIJQRp2Qfj///8BIBRraiIQQRp2Qfj///8BIBVraiILQRp2Qfj///8BIBZraiIR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FHZyNgIwIAIgEUESdEGAgPAfcSAQQQ52cjYCNCACIAVBGHRBgICAGHEgEUEIdnI2AjggAiAFQQJ2Qf///x9xNgI8IAJBQGsgEkEEdEHw//8fcSAFQRx2cjYCACACIBNBCnRBgPj/H3EgEkEWdnI2AkQgAiAUQRB0QYCA/B9xIBNBEHZyNgJIIAIgFEEKdjYCTCACQdAAaiINQQA2AgAgDiACKAIAciAGciAHciAIciAVciADciAKciALciAMckUEQEHajAQgACgCqAEgACgCpAFBA3FBAmoRAAAgAUIANwAAIAFCADcACCABQgA3ABAgAUIANwAYIAFCADcAICABQgA3ACggAUIANwAwIAFCADcAOCAEJARBAA8LIARBwAJqIQogBEGYAmohCyAEQfgBaiEIIARB/ABqIQMgAUIANwAAIAFCADcACCABQgA3ABAgAUIANwAYIAFCADcAICABQgA3ACggAUIANwAwIAFCADcAOCAJKAIEIAkoAgByIAkoAghyIAkoAgxyIAkoAhByIAkoAhRyIAkoAhhyIAkoAhxyBH8gCEIANwIAIAhCADcCCCAIQgA3AhAgCEIANwIYIANB+ABqIgxBADYCACADIAIpAgA3AgAgAyACKQIINwIIIAMgAikCEDcCECADIAIpAhg3AhggAyACKQIgNwIgIANBKGoiBSACQShqIgYpAgA3AgAgBSAGKQIINwIIIAUgBikCEDcCECAFIAYpAhg3AhggBSAGKQIgNwIgIANBATYCUCADQdQAaiIHQgA3AgAgB0IANwIIIAdCADcCECAHQgA3AhggB0EANgIgIAAgAyADIAkgCBAZIA0gDCgCADYCACADQdAAaiIAIAAQFSAKIAAQByALIAAgChAKIAMgAyAKEAogBSAFIAsQCiAAQQE2AgAgB0IANwIAIAdCADcCCCAHQgA3AhAgB0IANwIYIAdBADYCICACIAMpAgA3AgAgAiADKQIINwIIIAIgAykCEDcCECACIAMpAhg3AhggAiADKQIgNwIgIAYgBSkCADcCACAGIAUpAgg3AgggBiAFKQIQNwIQIAYgBSkCGDcCGCAGIAUpAiA3AiAgASACEBsgBCQEQQEFIAQkBEEACwvhAgEBfyMEIQMjBEHQAGokBCADQQA2AgAgAUUEQEGIjAQgACgCqAEgACgCpAFBA3FBAmoRAAAgAyQEQQAPCyACRQRAQZeMBCAAKAKoASAAKAKkAUEDcUECahEAACADJARBAA8LIANBKGoiACACIAMQDiADQQhqIgIgAUEAEA4gAygCAAR/IAFCADcAACABQgA3AAggAUIANwAQIAFCADcAGEEABSAAKAIEIAAoAgByIAAoAghyIAAoAgxyIAAoAhByIAAoAhRyIAAoAhhyIAAoAhxyBH8gAiACIAAQDSABQgA3AAAgAUIANwAIIAFCADcAECABQgA3ABggASACEBFBAQUgAUIANwAAIAFCADcACCABQgA3ABAgAUIANwAYQQALCyEBIAJCADcCACACQgA3AgggAkIANwIQIAJCADcCGCAAQgA3AgAgAEIANwIIIABCADcCECAAQgA3AhggAyQEIAELgAsBE38jBCEEIwRB8AJqJAQgBEEANgIAIAAoAgBFBEBB+IoEIAAoAqgBIAAoAqQBQQNxQQJqEQAAIAQkBEEADwsgAUUEQEHkiAQgACgCqAEgACgCpAFBA3FBAmoRAAAgBCQEQQAPCyACRQRAQZeMBCAAKAKoASAAKAKkAUEDcUECahEAACAEJARBAA8LIARBCGoiFCACIAQQDiAEKAIABEAgAUIANwAAIAFCADcACCABQgA3ABAgAUIANwAYIAFCADcAICABQgA3ACggAUIANwAwIAFCADcAOCAEJARBAA8LIAEoAAQhBiABKAAIIQcgASgADCEIIAEoABAhAyABKAAUIQkgASgAGCEKIAEoABwhCyABKAAgIQwgASgAJCENIAEoACghDyABKAAsIRAgASgAMCEFIAEoADQhESABKAA4IRIgASgAPCETIARBKGoiAiABKAAAIg5B////H3E2AgAgAiAGQQZ0QcD//x9xIA5BGnZyIg42AgQgAiAHQQx0QYDg/x9xIAZBFHZyIgY2AgggAiAIQRJ0QYCA8B9xIAdBDnZyIgc2AgwgAiADQRh0QYCAgBhxIAhBCHZyIgg2AhAgAiADQQJ2Qf///x9xIhU2AhQgAiAJQQR0QfD//x9xIANBHHZyIgM2AhggAiAKQQp0QYD4/x9xIAlBFnZyIgk2AhwgAiALQRB0QYCA/B9xIApBEHZyIgo2AiAgAiALQQp2Igs2AiQgAiAMQf///x9xNgIoIAIgDUEGdEHA//8fcSAMQRp2cjYCLCACIA9BDHRBgOD/H3Eg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AWoiBCANQQFxEQEAIgANAEEAIQALBUEAIQALCyAJQgA3AgAgCUIANwIIIAlCADcCECAJQgA3AhggCEIANwIAIAhCADcCCCAIQgA3AhAgCEIANwIYIAdCADcCACAHQgA3AgggB0IANwIQIAdCADcCGCAABEAgASAKKQAANwAAIAEgCikACDcACCABIAopABA3ABAgASAKKQAYNwAYIAFBIGoiASALKQAANwAAIAEgCykACDcACCABIAspABA3ABAgASALKQAYNwAYIAYkBCAADwsLCyABQgA3AAAgAUIANwAIIAFCADcAECABQgA3ABggAUIANwAgIAFCADcAKCABQgA3ADAgAUIANwA4IAYkBEEAC9cCAQJ/IwQhByMEQcABaiQEIAdByABqIgYgAikAADcAACAGIAIpAAg3AAggBiACKQAQNwAQIAYgAikAGDcAGCAGQSBqIgIgASkAADcAACACIAEpAAg3AAggAiABKQAQNwAQIAIgASkAGDcAGCAEBH8gBkFAayIBIAQpAAA3AAAgASAEKQAINwAIIAEgBCkAEDcAECABIAQpABg3ABhB4AAFQcAACyEBIAMEQCAGIAFqIgIgAykAADcAACACIAMpAAg3AAggAUEQciEBCyAHIAYgARAqIAZCADcAACAGQgA3AAggBkIANwAQIAZCADcAGCAGQgA3ACAgBkIANwAoIAZCADcAMCAGQgA3ADggBkFAa0IANwAAIAZCADcASCAGQgA3AFAgBkIANwBYIAZCADcAYCAGQgA3AGhBACEBA0AgByAAEB8gAUEBaiIBIAVNDQALIAckBEEBC90QASl/IwQhBSMEQYAEaiQEIAAoAgBFBEBB+IoEIAAoAqgBIAAoAqQBQQNxQQJqEQAAIAUkBEEADwsgAkUEQEGsiwQgACgCqAEgACgCpAFBA3FBAmoRAAAgBSQEQQAPCyABRQRAQa6KBCAAKAKoASAAKAKkAUEDcUECahEAACAFJARBAA8LIANFBEBB5IgEIAAoAqgBIAAoAqQBQQNxQQJqEQAAIAUkBEEADwsgBSACQQAQDiAFQUBrIgYgASkAADcAACAGIAEpAAg3AAggBiABKQAQNwAQIAYgASkAGDcAGCAFQSBqIgQgAUEgaiIBKQAANwAAIAQgASkACDcACCAEIAEpABA3ABAgBCABKQAYNwAYIARBGGoi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////HzYCACAGQf///x82AgAgAkH///8BNgIAIAMgBxAhQQBHCwsLCwsLCwsFQQALBUEACwshACAFJAQgAAuYBQIJfwd+IwQhBCMEQSBqJAQgAkUEQEHbigQgACgCqAEgACgCpAFBA3FBAmoRAAAgBCQEQQAPCyAEIgAgAikAADcAACAAIAIpAAg3AAggACACKQAQNwAQIAAgAikAGDcAGCACKAA4IghBf0cgAigAPCIEQR92IgVBf3MiA3EgBEH/////B0lyIAMgAigANCIJQX9HcXIgAyACKAAwIgpBf0dxciADIAIoACwiA0Hz3N3qBUlxciIGQQFzIANB89zd6gVLcSAFciIHQQFzIAIoACgiBUGdoJG9BUlxIAZyIgtBAXMgBUGdoJG9BUtxIAdyIgdBAXMgAigAJCIGQcbepP99SXEgC3JBf3MiCyAGQcbepP99S3EgB3IgCyACKAAgIgJBoMHswAZLcXIhByABRQRAIAAkBCAHDwsgBwRAIAhBf3OtQv////8PfCAJQX9zrUL/////D3wgCkF/c61C/v///w98IANBf3OtQua5u9ULfCAFQX9zrUK7wKL6CnwgBkF/c61CjL3J/gt8IAJBf3OtQsKC2YENfCIMQiCIfCIOQiCIfCIPQiCIfCIQQiCIfCIRQiCIfCISQiCIfCENIAwgBiACciAFciADciAKciAJciAIciAEckEAR0EfdEEfda0iDIOnIQIgDyAMg6chBSAQIAyDpyEDIBEgDIOnIQogEiAMg6chCSANIAyDpyEIIARBf3OtQv////8PfCANQiCIfCAMg6chBCAOIAyDpyEGCyABIAApAAA3AAAgASAAKQAINwAIIAEgACkAEDcAECABIAApABg3ABggASACNgAgIAEgBjYAJCABIAU2ACggASADNgAsIAEgCjYAMCABIAk2ADQgASAINgA4IAEgBDYAPCAAJAQgBwuDAwIGfwh+IAJFBEBB24oEIAAoAqgBIAAoAqQBQQNxQQJqEQAAQQAPCyABBH8gAigAICIAQX9zrULCgtmBDXwhCiACKAAkIgMgAHIgAigAKCIAciACKAAsIgRyIAIoADAiBXIgAigANCIGciACKAA4IgdyIAIoADwiCHJBAEdBH3RBH3WtIQkgB0F/c61C/////w98IAZBf3OtQv////8PfCAFQX9zrUL+////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";

// node_modules/@bitauth/libauth/build/lib/bin/secp256k1/secp256k1-wasm.js
var wrapSecp256k1Wasm = (instance, heapU8, heapU32) => ({
  contextCreate: (context) => instance.exports._secp256k1_context_create(context),
  contextRandomize: (contextPtr, seedPtr) => instance.exports._secp256k1_context_randomize(contextPtr, seedPtr),
  free: (pointer) => instance.exports._free(pointer),
  heapU32,
  heapU8,
  instance,
  malloc: (bytes) => instance.exports._malloc(bytes),
  mallocSizeT: (num) => {
    const pointer = instance.exports._malloc(4);
    const pointerView32 = pointer >> 2;
    heapU32.set([num], pointerView32);
    return pointer;
  },
  mallocUint8Array: (array) => {
    const pointer = instance.exports._malloc(array.length);
    heapU8.set(array, pointer);
    return pointer;
  },
  privkeyTweakAdd: (contextPtr, secretKeyPtr, tweakNum256Ptr) => instance.exports._secp256k1_ec_privkey_tweak_add(contextPtr, secretKeyPtr, tweakNum256Ptr),
  privkeyTweakMul: (contextPtr, secretKeyPtr, tweakNum256Ptr) => instance.exports._secp256k1_ec_privkey_tweak_mul(contextPtr, secretKeyPtr, tweakNum256Ptr),
  pubkeyCreate: (contextPtr, publicKeyPtr, secretKeyPtr) => instance.exports._secp256k1_ec_pubkey_create(contextPtr, publicKeyPtr, secretKeyPtr),
  pubkeyParse: (contextPtr, publicKeyOutPtr, publicKeyInPtr, publicKeyInLength) => instance.exports._secp256k1_ec_pubkey_parse(contextPtr, publicKeyOutPtr, publicKeyInPtr, publicKeyInLength),
  pubkeySerialize: (contextPtr, outputPtr, outputLengthPtr, publicKeyPtr, compression) => instance.exports._secp256k1_ec_pubkey_serialize(contextPtr, outputPtr, outputLengthPtr, publicKeyPtr, compression),
  pubkeyTweakAdd: (contextPtr, publicKeyPtr, tweakNum256Ptr) => instance.exports._secp256k1_ec_pubkey_tweak_add(contextPtr, publicKeyPtr, tweakNum256Ptr),
  pubkeyTweakMul: (contextPtr, publicKeyPtr, tweakNum256Ptr) => instance.exports._secp256k1_ec_pubkey_tweak_mul(contextPtr, publicKeyPtr, tweakNum256Ptr),
  readHeapU8: (pointer, bytes) => new Uint8Array(heapU8.buffer, pointer, bytes),
  readSizeT: (pointer) => {
    const pointerView32 = pointer >> 2;
    return heapU32[pointerView32];
  },
  recover: (contextPtr, outputPubkeyPointer, rSigPtr, msg32Ptr) => instance.exports._secp256k1_ecdsa_recover(contextPtr, outputPubkeyPointer, rSigPtr, msg32Ptr),
  recoverableSignatureParse: (contextPtr, outputRSigPtr, inputSigPtr, rid) => instance.exports._secp256k1_ecdsa_recoverable_signature_parse_compact(contextPtr, outputRSigPtr, inputSigPtr, rid),
  recoverableSignatureSerialize: (contextPtr, sigOutPtr, recIDOutPtr, rSigPtr) => instance.exports._secp256k1_ecdsa_recoverable_signature_serialize_compact(contextPtr, sigOutPtr, recIDOutPtr, rSigPtr),
  schnorrSign: (contextPtr, outputSigPtr, msg32Ptr, secretKeyPtr) => instance.exports._secp256k1_schnorr_sign(contextPtr, outputSigPtr, msg32Ptr, secretKeyPtr),
  schnorrVerify: (contextPtr, sigPtr, msg32Ptr, publicKeyPtr) => instance.exports._secp256k1_schnorr_verify(contextPtr, sigPtr, msg32Ptr, publicKeyPtr),
  seckeyVerify: (contextPtr, secretKeyPtr) => instance.exports._secp256k1_ec_seckey_verify(contextPtr, secretKeyPtr),
  sign: (contextPtr, outputSigPtr, msg32Ptr, secretKeyPtr) => instance.exports._secp256k1_ecdsa_sign(contextPtr, outputSigPtr, msg32Ptr, secretKeyPtr),
  signRecoverable: (contextPtr, outputRSigPtr, msg32Ptr, secretKeyPtr) => instance.exports._secp256k1_ecdsa_sign_recoverable(contextPtr, outputRSigPtr, msg32Ptr, secretKeyPtr),
  signatureMalleate: (contextPtr, outputSigPtr, inputSigPtr) => instance.exports._secp256k1_ecdsa_signature_malleate(contextPtr, outputSigPtr, inputSigPtr),
  signatureNormalize: (contextPtr, outputSigPtr, inputSigPtr) => instance.exports._secp256k1_ecdsa_signature_normalize(contextPtr, outputSigPtr, inputSigPtr),
  signatureParseCompact: (contextPtr, sigOutPtr, compactSigInPtr) => instance.exports._secp256k1_ecdsa_signature_parse_compact(contextPtr, sigOutPtr, compactSigInPtr),
  signatureParseDER: (contextPtr, sigOutPtr, sigDERInPtr, sigDERInLength) => instance.exports._secp256k1_ecdsa_signature_parse_der(contextPtr, sigOutPtr, sigDERInPtr, sigDERInLength),
  signatureSerializeCompact: (contextPtr, outputCompactSigPtr, inputSigPtr) => instance.exports._secp256k1_ecdsa_signature_serialize_compact(contextPtr, outputCompactSigPtr, inputSigPtr),
  signatureSerializeDER: (contextPtr, outputDERSigPtr, outputDERSigLengthPtr, inputSigPtr) => instance.exports._secp256k1_ecdsa_signature_serialize_der(contextPtr, outputDERSigPtr, outputDERSigLengthPtr, inputSigPtr),
  verify: (contextPtr, sigPtr, msg32Ptr, pubkeyPtr) => instance.exports._secp256k1_ecdsa_verify(contextPtr, sigPtr, msg32Ptr, pubkeyPtr)
});
var isLittleEndian = (buffer) => {
  const littleEndian = true;
  const notLittleEndian = false;
  const heap16 = new Int16Array(buffer);
  const heap32 = new Int32Array(buffer);
  const heapU8 = new Uint8Array(buffer);
  heap32[0] = 1668509029;
  heap16[1] = 25459;
  return heapU8[2] !== 115 || heapU8[3] !== 99 ? (
    /* istanbul ignore next */
    notLittleEndian
  ) : littleEndian;
};
var alignMemory = (factor, size) => Math.ceil(size / factor) * factor;
var instantiateSecp256k1WasmBytes = async (webassemblyBytes) => {
  const STACK_ALIGN = 16;
  const GLOBAL_BASE = 1024;
  const WASM_PAGE_SIZE = 65536;
  const TOTAL_STACK = 5242880;
  const TOTAL_MEMORY = 16777216;
  const wasmMemory = new WebAssembly.Memory({
    initial: TOTAL_MEMORY / WASM_PAGE_SIZE,
    maximum: TOTAL_MEMORY / WASM_PAGE_SIZE
  });
  if (!isLittleEndian(wasmMemory.buffer)) {
    throw new Error("Runtime error: expected the system to be little-endian.");
  }
  const STATIC_BASE = GLOBAL_BASE;
  const STATICTOP_INITIAL = STATIC_BASE + 67696 + 16;
  const DYNAMICTOP_PTR = STATICTOP_INITIAL;
  const DYNAMICTOP_PTR_SIZE = 4;
  const STATICTOP = STATICTOP_INITIAL + DYNAMICTOP_PTR_SIZE + 15 & -16;
  const STACKTOP = alignMemory(STACK_ALIGN, STATICTOP);
  const STACK_BASE = STACKTOP;
  const STACK_MAX = STACK_BASE + TOTAL_STACK;
  const DYNAMIC_BASE = alignMemory(STACK_ALIGN, STACK_MAX);
  const heapU8 = new Uint8Array(wasmMemory.buffer);
  const heap32 = new Int32Array(wasmMemory.buffer);
  const heapU32 = new Uint32Array(wasmMemory.buffer);
  heap32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;
  const TABLE_SIZE = 6;
  const MAX_TABLE_SIZE = 6;
  let getErrNoLocation;
  const env = {
    DYNAMICTOP_PTR,
    STACKTOP,
    ___setErrNo: (
      /* istanbul ignore next */
      (value) => {
        if (getErrNoLocation !== void 0) {
          heap32[getErrNoLocation() >> 2] = value;
        }
        return value;
      }
    ),
    _abort: (
      /* istanbul ignore next */
      (err = "Secp256k1 Error") => {
        throw new Error(err);
      }
    ),
    // eslint-disable-next-line camelcase
    _emscripten_memcpy_big: (
      /* istanbul ignore next */
      (dest, src, num) => {
        heapU8.set(heapU8.subarray(src, src + num), dest);
        return dest;
      }
    ),
    abort: (
      /* istanbul ignore next */
      (err = "Secp256k1 Error") => {
        throw new Error(err);
      }
    ),
    abortOnCannotGrowMemory: (
      /* istanbul ignore next */
      () => {
        throw new Error("Secp256k1 Error: abortOnCannotGrowMemory was called.");
      }
    ),
    enlargeMemory: (
      /* istanbul ignore next */
      () => {
        throw new Error("Secp256k1 Error: enlargeMemory was called.");
      }
    ),
    getTotalMemory: () => TOTAL_MEMORY
  };
  const info = {
    env: {
      ...env,
      memory: wasmMemory,
      memoryBase: STATIC_BASE,
      table: new WebAssembly.Table({
        element: "anyfunc",
        initial: TABLE_SIZE,
        maximum: MAX_TABLE_SIZE
      }),
      tableBase: 0
    },
    global: { Infinity: Infinity, NaN: NaN }
  };
  return WebAssembly.instantiate(webassemblyBytes, info).then((result) => {
    getErrNoLocation = result.instance.exports["___errno_location"];
    return wrapSecp256k1Wasm(result.instance, heapU8, heapU32);
  });
};
var getEmbeddedSecp256k1Binary = () => base64ToBin(secp256k1Base64Bytes).buffer;
var instantiateSecp256k1Wasm = async () => instantiateSecp256k1WasmBytes(getEmbeddedSecp256k1Binary());

// node_modules/@bitauth/libauth/build/lib/bin/sha1/sha1.base64.js
var import_dist52 = __toESM(require_dist(), 1);
var import_dist53 = __toESM(require_dist2(), 1);
var import_dist54 = __toESM(require_dist3(), 1);
var sha1Base64Bytes = "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cjYCBEG8FCAANgIAQbQUIAI2AgAgACACaiACNgIADAQLIAMQJQwBC0GkEUGkESgCAEF+IAFBA3Z3cTYCAAsgBCACaiECIAMgBGohAwsgAyADKAIEQX5xNgIEIAAgAkEBcjYCBCAAIAJqIAI2AgACfwJAIAJB/wFNBEAgAkEDdiIBQQN0QawRaiECQaQRKAIAIgNBASABQR9xdCIBcUUNASACQQhqIQMgAigCCAwCCyAAIAIQJgwCC0GkESADIAFyNgIAIAJBCGohAyACCyEBIAMgADYCACABIAA2AgwgACACNgIMIAAgATYCCAsgBUEIag8LQbgUIAAgAmsiATYCAEHAFEHAFCgCACIAIAJqIgM2AgAgAyABQQFyNgIEIAAgAkEDcjYCBCAAQQhqC6UBAQJ/QQIhBQJAAkACQAJAAkAgACgCBCIGIAFrIAJPDQAgASACaiICIAFJIQECQCAEBEBBACEFIAENAiAGQQF0IgEgAiACIAFJGyECDAELQQAhBSABDQELIAJBAEgNACAGRQ0BIAAoAgAgAhATIgFFDQIMAwsgBQ8LIAIQBCIBDQELIAMNAQsgAQRAIAAgATYCACAAQQRqIAI2AgBBAg8LQQEPCwALCABB5BUQBwALZgIBfwN+IwBBMGsiASQAIAApAhAhAiAAKQIIIQMgACkCACEEIAFBFGpBADYCACABIAQ3AxggAUIBNwIEIAFBrA42AhAgASABQRhqNgIAIAEgAzcDICABIAI3AyggASABQSBqECIAC7gBAQF/IwBB4AFrIgMkACADQThqQcwIKAIANgIAIANBMGpBxAgpAgA3AwAgA0IANwMgIANBvAgpAgA3AyggA0E8akEAQcQAEC4aIANBIGogASACEAkgA0GAAWogA0EgakHgABAsGiADQQhqIANBgAFqEAogA0EgaiADQQhqQRQQAyADQYgBaiADQShqKAIANgIAIAMgAykDIDcDgAEgAyADQYABahALIAAgAykDADcCACADQeABaiQAC5cDAQR/IwBBQGoiAyQAIAAgACkDACACrXw3AwAgAyAAQQhqNgIoIAMgA0EoajYCLAJAAkACQAJAAkACQCAAKAIcIgUEQEHAACAFayIEIAJNDQEgA0EYaiAFIAUgAmoiBCAAQSBqEBUgAygCHCACRw0FIAMoAhggASACECwaDAMLIAIhBAwB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QcgAaiICKQMANwMAIAEgASkDQDcDcCABIAw2AoQBIAEgFCAZQR53ajYCgAEgASAPNgKIASABIAY2AowBIAFB4ABqIAFB8ABqIAFBgAFqQQAQHiABKAJsIRYgASkCZCEfIAEoAiAhDSABKAIsIRAgASgCKCEKIAEoAiQhESABIAEoAmAiDjYCcCABIB83AnQgASAWNgJ8IAEgETYChAEgASAKNgKIASABIBA2AowBIAEgDSABKAJAQR53ajYCgAEgAUHgAGogAUHwAGogAUGAAWpBABAeIAIgAUHoAGoiFikDADcDACABIAEpA2A3A0AgASgCPCEHIAEoAjghCCABKAIwIRIgASgCNCEJIBMgAikDADcDACABIAEpA0A3A3AgASAJNgKEASABIBIgDkEed2o2AoABIAEgCDYCiAEgASAHNgKMASABQeAAaiABQfAAaiABQYABakEAEB4gASgCbCEOIAEpAmQhHyABKAJgIRcgASARIAQgC3NzNgKEASABIA0gBSADc3M2AoABIAEgCiAUIAVzczYCiAEgASAQIAwgBHNzNgKMASABQdAAaiABQYABaiAJIAggBxAfIAEgFzYCcCABIB83AnQgASAONgJ8IAEgASgCVCIDNgKEASABIAEoAlgiCzYCiAEgASABKAJcIg42AowBIAEgASgCQEEedyABKAJQIhVqNgKAASABQeAAaiABQfAAaiABQYABakEAEB4gAiAWKQMANwMAIAEgASkDYDcDQCABIAkgBiAMc3M2AoQBIAEgEiAPIBRzczYCgAEgASAIIA0gD3NzNgKIASABIAcgESAGc3M2AowBIAFB8ABqIAFBgAFqIAMgCyAOEB8gASgCfCEEIAEoAnghBSABKAJwIQ8gASgCdCEGIBMgAikDADcDACABIAEpA0A3A3AgASAGNgKEASABIA8gF0Eed2o2AoABIAEgBTYCiAEgASAENgKMASABQeAAaiABQfAAaiABQYABakEBEB4gASgCbCEMIAEpAmQhHyABKAJgIRcgASADIBAgEXNzNgKEASABIBUgCiANc3M2AoABIAEgCyASIApzczYCiAEgASAOIAkgEHNzNgKMASABQfAAaiABQYABaiAGIAUgBBAfIAEoAnAhFCABKAJ8IQ0gASgCeCEQIAEoAnQhCiABIBc2AnAgASAfNwJ0IAEgDDYCfCABIAo2AoQBIAEgEDYCiAEgASANNgKMASABIBQgASgCQEEed2o2AoABIAFB4ABqIAFB8ABqIAFBgAFqQQEQHiACIBYpAwA3AwAgASABKQNgNwNAIAEgBiAHIAlzczYChAEgASAPIAggEnNzNgKAASABIAUgFSAIc3M2AogBIAEgBCADIAdzczYCjAEgAUHwAGogAUGAAWogCiAQIA0QHyABKAJ8IQcgASgCeCEIIAEoAnAhDCABKAJ0IQkgEyACKQMANwMAIAEgASkDQDcDcCABIAk2AoQBIAEgDCAXQR53ajYCgAEgASAINgKIASABIAc2AowBIAFB4ABqIAFB8ABqIAFBgAFqQQEQHiABKAJsIRcgASkCZCEfIAEoAmAhGCABIAogDiADc3M2AoQBIAEgFCALIBVzczYCgAEgASAQIA8gC3NzNgKIASABIA0gBiAOc3M2AowBIAFB8ABqIAFBgAFqIAkgCCAHEB8gASgCcCELIAEoAnwhESABKAJ4IRIgASgCdCEDIAEgGDYCcCABIB83AnQgASAXNgJ8IAEgAzYChAEgASASNgKIASABIBE2AowBIAEgCyABKAJAQR53ajYCgAEgAUHgAGogAUHwAGogAUGAAWpBARAeIAIgFikDADcDACABIAEpA2A3A0AgASAJIAQgBnNzNgKEASABIAwgBSAPc3M2AoABIAEgCCAUIAVzczYCiAEgASAHIAogBHNzNgKMASABQdAAaiABQYABaiADIBIgERAfIBMgAikDADcDACABIAEpA0A3A3AgASABKAJUIg42AoQBIAEgASgCWCIPNgKIASABIAEoAlwiFTYCjAEgASABKAJQIhcgGEEed2o2AoABIAFB4ABqIAFB8ABqIAFBgAFqQQEQHiABKAJsIRogASkCZCEfIAEoAmAhGCABIAMgDSAKc3M2AoQBIAEgCyAQIBRzczYCgAEgASASIAwgEHNzNgKIASABIBEgCSANc3M2AowBIAFB8ABqIAFBgAFqIA4gDyAVEB8gASgCcCEUIAEoAnwhBCABKAJ4IQUgASgCdCEGIAEgGDYCcCABIB83AnQgASAaNgJ8IAEgBjYChAEgASAFNgKIASABIAQ2AowBIAEgFCABKAJAQR53ajYCgAEgAUHgAGogAUHwAGogAUGAAWpBAhAeIAIgFikDADcDACABIAEpA2A3A0AgASAOIAcgCXNzNgKEASABIBcgCCAMc3M2AoABIAEgDyALIAhzczYCiAEgASAVIAMgB3NzNgKMASABQfAAaiABQYABaiAGIAUgBBAfIAEoAnwhByABKAJ4IQggASgCcCEMIAEoAnQhCSATIAIpAwA3AwAgASABKQNANwNwIAEgCTYChAEgASAMIBhBHndqNgKAASABIAg2AogBIAEgBzYCjAEgAUHgAGogAUHwAGogAUGAAWpBAhAeIAEoAmwhGiABKQJkIR8gASgCYCEYIAEgBiARIANzczYChAEgASAUIBIgC3NzNgKAASABIAUgFyASc3M2AogBIAEgBCAOIBFzczYCjAEgAUHwAGogAUGAAWogCSAIIAcQHyABKAJwIQsgASgCfCENIAEoAnghECABKAJ0IQogASAYNgJwIAEgHzcCdCABIBo2AnwgASAKNgKEASABIBA2AogBIAEgDTYCjAEgASALIAEoAkBBHndqNgKAASABQeAAaiABQfAAaiABQYABakECEB4gAiAWKQMANwMAIAEgASkDYDcDQCABIAkgFSAOc3M2AoQBIAEgDCAPIBdzczYCgAEgASAIIBQgD3NzNgKIASABIAcgBiAVc3M2AowBIAFB8ABqIAFBgAFqIAogECANEB8gASgCfCERIAEoAnghEiABKAJwIQ4gASgCdCEDIBMgAikDADcDACABIAEpA0A3A3AgASADNgKEASABIA4gGEEed2o2AoABIAEgEjYCiAEgASARNgKMASABQeAAaiABQfAAaiABQYABakECEB4gASgCbCEPIAEpAmQhHyABKAJgIRUgASAKIAQgBnNzNgKEASABIAsgBSAUc3M2AoABIAEgECAMIAVzczYCiAEgASANIAkgBHNzNgKMASABQdAAaiABQYABaiADIBIgERAfIAEgFTYCcCABIB83AnQgASAPNgJ8IAEgASgCVCIENgKEASABIAEoAlgiBTYCiAEgASABKAJcIgY2AowBIAEgASgCQEEedyABKAJQIhRqNgKAASABQeAAaiABQfAAaiABQYABakECEB4gAiAWKQMANwMAIAEgASkDYDcDQCABIAMgByAJc3M2AoQBIAEgDiAIIAxzczYCgAEgASASIAsgCHNzNgKIASABIBEgCiAHc3M2AowBIAFB8ABqIAFBgAFqIAQgBSAGEB8gASgCfCEHIAEoAnghCCABKAJwIQ8gASgCdCEJIBMgAikDADcDACABIAEpA0A3A3AgASAJNgKEASABIA8gFUEed2o2AoABIAEgCDYCiAEgASAHNgKMASABQeAAaiABQfAAaiABQYABakEDEB4gASgCbCEVIAEpAmQhHyABKAJgIQwgASAEIA0gCnNzNgKEASABIBQgECALc3M2AoABIAEgBSAOIBBzczYCiAEgASAGIAMgDXNzNgKMASABQfAAaiABQYABaiAJIAggBxAfIAEoAnAhECABKAJ8IQogASgCeCELIAEoAnQhDSABIAw2AnAgASAfNwJ0IAEgFTYCfCABIA02AoQBIAEgCzYCiAEgASAKNgKMASABIBAgASgCQEEed2o2AoABIAFB4ABqIAFB8ABqIAFBgAFqQQMQHiACIBYpAwA3AwAgASABKQNgNwNAIAEgCSARIANzczYChAEgASAPIBIgDnNzNgKAASABIAggFCASc3M2AogBIAEgByAEIBFzczYCjAEgAUHwAGogAUGAAWogDSALIAoQHyABKAJ8IREgASgCeCESIAEoAnAhDiABKAJ0IQMgEyACKQMANwMAIAEgASkDQDcDcCABIAM2AoQBIAEgDiAMQR53ajYCgAEgASASNgKIASABIBE2AowBIAFB4ABqIAFB8ABqIAFBgAFqQQMQHiABKAJsIRUgASkCZCEfIAEoAmAhDCABIA0gBiAEc3M2AoQBIAEgECAFIBRzczYCgAEgASALIA8gBXNzNgKIASABIAogCSAGc3M2AowBIAFB8ABqIAFBgAFqIAMgEiAREB8gASgCcCEKIAEoAnwhBCABKAJ4IQUgASgCdCEGIAEgDDYCcCABIB83AnQgASAVNgJ8IAEgBjYChAEgASAFNgKIASABIAQ2AowBIAEgCiABKAJAQR53ajYCgAEgAUHgAGogAUHwAGogAUGAAWpBAxAeIAIgFikDADcDACABIAEpA2A3A0AgASADIAcgCXNzNgKEASABIA4gCCAPc3M2AoABIAEgEiAQIAhzczYCiAEgASARIA0gB3NzNgKMASABQdAAaiABQYABaiAGIAUgBBAfIBMgAikDADcDACABIAEpA0A3A3AgASABKQJUNwKEASABIAEoAlw2AowBIAEgASgCUCAMQR53ajYCgAEgAUHgAGogAUHwAGogAUGAAWpBAxAe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DSAKIABBDHZBD3FB4AFyOgAMQQMMAQsgCiAAQRJ2QfABcjoADCAKIABBP3FBgAFyOgAPIAogAEEMdkE/cUGAAXI6AA0gCiAAQQZ2QT9xQYABcjoADkEECyEIIAEoAhghAkF/IQAgAUEcaigCACIJQQxqIQECQAJAAkADQCAAQQFqIgAgBE8NASACIApBDGogCCABKAIAEQUARQ0ACwwBCyACIAcgBiAJQQxqKAIAIgERBQANAEF/IQADQCAAQQFqIgAgA08NAiACIApBDGogCCABEQUARQ0ACwtBAQwBC0EACyEAIApBEGokACAAC0YCAX8BfiMAQSBrIgIkACABKQIAIQMgAkEUaiABKQIINwIAIAJBlBY2AgQgAkGsDjYCACACIAA2AgggAiADNwIMIAIQJAALUAACQAJAQZARKAIAQQFGBEBBlBFBlBEoAgBBAWoiADYCACAAQQNJDQEMAgtBkBFCgYCAgBA3AwALQZwRKAIAIgBBf0wNAEGcESAANgIACwALPwECfyMAQRBrIgEkAAJ/IAAoAggiAiACDQAaQfwVEAcACxogASAAKQIMNwMAIAEgAEEUaikCADcDCCABECMAC7MCAQV/IAAoAhghAwJAAkACQCAAKAIMIgIgAEcEQCAAKAIIIgEgAjYCDCACIAE2AgggAw0BDAILIABBFGoiASAAQRBqIAEoAgAbIgQoAgAiAQRAAkADQCAEIQUgASICQRRqIgQoAgAiAQRAIAENAQwCCyACQRBqIQQgAigCECIBDQALCyAFQQA2AgAgAw0BDAILQQAhAiADRQ0BCwJAIAAoAhwiBEECdEG0E2oiASgCACAARwRAIANBEGogA0EUaiADKAIQIABGGyACNgIAIAINAQwCCyABIAI2AgAgAkUNAgsgAiADNgIYIAAoAhAiAQRAIAIgATYCECABIAI2AhgLIABBFGooAgAiAUUNACACQRRqIAE2AgAgASACNgIYCw8LQagRQagRKAIAQX4gBHdxNgIAC8UCAQR/IAACf0EAIAFBCHYiA0UNABpBHyICIAFB////B0sNABogAUEmIANnIgJrQR9xdkEBcUEfIAJrQQF0cgsiAjYCHCAAQgA3AhAgAkECdEG0E2ohAwJAAkACQEGoESgCACIEQQEgAkEfcXQiBXEEQCADKAIAIgQoAgRBeHEgAUcNASAEIQIM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LTFlY2M2Mjk5ZGI5ZWM4MjMvYmxvY2stYnVmZmVyLTAuMy4zL3NyYy9saWIucnNkZXN0aW5hdGlvbiBhbmQgc291cmNlIHNsaWNlcyBoYXZlIGRpZmZlcmVudCBsZW5ndGhzL3Jvb3QvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvc2hhLTEtMC43LjAvc3JjL3V0aWxzLnJzaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZTogdW5rbm93biBpY29zYXJvdW5kIGluZGV4AEHwCwvSBAEAAAAAAAAAIAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAwAAAGNhcGFjaXR5IG92ZXJmbG93Y2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZWxpYmNvcmUvb3B0aW9uLnJzMDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTkAAAAAaW5kZXggb3V0IG9mIGJvdW5kczogdGhlIGxlbiBpcyAgYnV0IHRoZSBpbmRleCBpcyBsaWJjb3JlL3NsaWNlL21vZC5ycwABAAAAAAAAACAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAABAAAAAQAAACAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAABpbmRleCAgb3V0IG9mIHJhbmdlIGZvciBzbGljZSBvZiBsZW5ndGggc2xpY2UgaW5kZXggc3RhcnRzIGF0ICBidXQgZW5kcyBhdCBpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2RlbGliYWxsb2MvcmF3X3ZlYy5ycwBB7BQLnQIWBAAAJAAAAC8IAAATAAAASAIAAAkAAADQBAAAUwAAAEsAAAARAAAAUAQAACAAAABwBAAAWgAAAB8AAAAFAAAAIwUAADQAAABfBwAAFAAAAG0GAAAJAAAAzwUAABgAAAClBQAAKgAAAFcFAABOAAAAQgAAAA4AAAAUBgAAEQAAAC8IAAATAAAA8gIAAAUAAAAlBgAAKwAAAFAGAAARAAAAWQEAABUAAAADAAAAAAAAAAEAAAAEAAAALQcAACAAAABNBwAAEgAAALwHAAAGAAAAwgcAACIAAABfBwAAFAAAAK0HAAAFAAAA5AcAABYAAAD6BwAADQAAAF8HAAAUAAAAswcAAAUAAAAHCAAAKAAAAC8IAAATAAAA9QEAAB4ADAdsaW5raW5nAwKMDw==";

// node_modules/@bitauth/libauth/build/lib/bin/sha256/sha256.base64.js
var import_dist55 = __toESM(require_dist(), 1);
var import_dist56 = __toESM(require_dist2(), 1);
var import_dist57 = __toESM(require_dist3(), 1);
var sha256Base64Bytes = "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IAJHDQUgAygCGCABIAIQKxoMAwsgAiEEDAELIANBMGogASACIAQQFiADQTxqKAIAIQQgAygCOCEBIAMoAjAhBSADKAI0IQIgA0EgaiAAQQxqIgYgACgCCBAXIAIgAygCJEcNBCADKAIgIAUgAhArGiAAQQhqQQA2AgAgA0EsaiAGEBgLIANBPGohAiADQThqIQUCQANAIARBP00NASADQTBqIAEgBEHAABAWIAIoAgAhBCAFKAIAIQEgA0EIakEAQcAAIAMoAjAgAygCNBAZIANBLGogAygCCBAYDAALAAsgA0EQaiAAQQxqIAQQGiADKAIUIARHDQEgAygCECABIAQQKxoLIABBCGogBDYCACADQUBrJAAPC0GEFBAHAAtBhBQQBwALQYQUEAcAC98EAgN/AX4jAEHQAGsiAiQAIAIgAUHMAGo2AiQgASkDACEFIAEoAgghBCACIAJBJGo2AigCQCAEQT9NBEAgAUEMaiIDIARqQYABOgAAIAEgASgCCEEBaiIENgIIIAJBGGogAyAEEBcgAigCGEEAIAIoAhwQLRpBwAAgASgCCGtBB00EQCACQShqIAMQGCACQRBqIAMgAUEIaigCABAaIAIoAhBBACACKAIUEC0aCyACQQhqIANBOBAXIAIoAgxBCEcNASACKAIIIAVCOIYgBUIohkKAgICAgIDA/wCDhCAFQhiGQoCAgICA4D+DIAVCCIZCgICAgPAfg4SEIAVCCIhCgICA+A+DIAVCGIhCgID8B4OEIAVCKIhCgP4DgyAFQjiIhISENwAAIAJBKGogAxAYIAFBCGpBADYCACACQQA2AiggAkEoakEEciEEQQAhAwJAA0AgA0EgRg0BIAQgA2pBADoAACACIAIoAihBAWo2AiggA0EBaiEDDAALAAsgAkFAayABQeQAaikAADcDACACQThqIAFB3ABqKQAANwMAIAJBMGogAUHUAGopAAA3AwAgAiABKQBMNwMoQQAhAwJAA0AgA0EgRg0BIAJBKGogA2oiBCAEKAIAIgRBGHQgBEEIdEGAgPwHcXIgBEEIdkGA/gNxIARBGHZycjYCACADQQRqIQMMAAsACyAAIAIpAyg3AAAgAEEYaiACQUBrKQMANwAAIABBEGogAkE4aikDADcAACAAQQhqIAJBMGopAwA3AAAgAkHQAGokAA8LQdwTIARBwAAQ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KAJsIQggASAPNgJkIAEgDjYCYCABIBM2AmggASAYNgJsIAEgAjYCdCABIBc2AnAgASAQNgJ4IAEgDDYCfCABQdAAaiABQeAAaiABQfAAaiAHQevZwaJ6aiAIQfr/+4V5ahAeIAEoAlwhByABKAJYIQggASgCUCEKIAEoAlQhESABIAI2AmQgASAXNgJgIAEgEDYCaCABIAw2AmwgASARNgJ0IAEgCjYCcCABIAg2AnggASAHNgJ8IAFB0ABqIAFB4ABqIAFB8ABqIA1B8vHFs3xqIBlB98fm93tqEB4gASgCXCENIAEoAlghGCABKAJQIRMgACAeIAEoAlRqNgIEIAAgEyAdajYCACAAIAogIWo2AgggACARICJqNgIMIAAgGCAcajYCECAAIA0gG2o2AhQgACAIICBqNgIYIAAgByAfajYCHCABQYABaiQAC30BAX8jAEEwayICJAAgAiABNgIEIAIgADYCACACQSxqQQE2AgAgAkEUakECNgIAIAJBHGpBAjYCACACQQE2AiQgAkGMFTYCCCACQQI2AgwgAkHMDTYCECACIAI2AiAgAiACQQRqNgIoIAIgAkEgajYCGCACQQhqQZwVECgAC3wBAX8jAEEwayIDJAAgAyACNgIEIAMgATYCACADQSxqQQE2AgAgA0EUakECNgIAIANBHGpBAjYCACADQQE2AiQgA0HcFDYCCCADQQI2AgwgA0HMDTYCECADIANBBGo2AiAgAyADNgIoIAMgA0EgajYCGCADQQhqIAAQKAAL1gEBBn8gACABKAIAIgggAigCBCIHcyACKAIAIgVxIAggB3FzIAVBHncgBUETd3MgBUEKd3NqIAIoAggiBkEadyAGQRV3cyAGQQd3cyAEaiABKAIMaiABKAIIIgQgAigCDCIJcyAGcSAEc2oiCmoiAjYCBCAAIAogASgCBGoiATYCDCAAIAJBHncgAkETd3MgAkEKd3MgAiAHIAVzcSAHIAVxc2ogBCADaiAJIAEgCSAGc3FzaiABQRp3IAFBFXdzIAFBB3dzaiIFajYCACAAIAUgCGo2AggLeAAgACACQRl3IAJBA3ZzIAJBDndzIAEoAgAiAmo2AgAgACACQRl3IAJBA3ZzIAJBDndzIAEoAgQiAmo2AgQgACACQRl3IAJBA3ZzIAJBDndzIAEoAggiAmo2AgggACACQRl3IAJBA3ZzIAJBDndzIAEoAgxqNgIMC3YAIAAgAkENdyACQQp2cyACQQ93cyABKAIIaiICNgIIIAAgA0ENdyADQQp2cyADQQ93cyABKAIMaiIDNgIMIAAgAkENdyACQQp2cyACQQ93cyABKAIAajYCACAAIANBDXcgA0EKdnMgA0EPd3MgASgCBGo2AgQLUAACQAJAQegPKAIAQQFGBEBB7A9B7A8oAgBBAWoiADYCACAAQQNJDQEMAgtB6A9CgYCAgBA3AwALQfQPKAIAIgBBf0wNAEH0DyAANgIACwALPwECfyMAQRBrIgEkAAJ/IAAoAggiAiACDQAaQbQUEAcACxogASAAKQIMNwMAIAEgAEEUaikCADcDCCABECEAC7MCAQV/IAAoAhghAwJAAkACQCAAKAIMIgIgAEcEQCAAKAIIIgEgAjYCDCACIAE2AgggAw0BDAILIABBFGoiASAAQRBqIAEoAgAbIgQoAgAiAQRAAkADQCAEIQUgASICQRRqIgQoAgAiAQRAIAENAQwCCyACQRBqIQQgAigCECIBDQALCyAFQQA2AgAgAw0BDAILQQAhAiADRQ0BCwJAIAAoAhwiBEECdEGMEmoiASgCACAARwRAIANBEGogA0EUaiADKAIQIABGGyACNgIAIAINAQwCCyABIAI2AgAgAkUNAgsgAiADNgIYIAAoAhAiAQRAIAIgATYCECABIAI2AhgLIABBFGooAgAiAUUNACACQRRqIAE2AgAgASACNgIYCw8LQYAQQYAQKAIAQX4gBHdxNgIAC8UCAQR/IAACf0EAIAFBCHYiA0UNABpBHyICIAFB////B0sNABogAUEmIANnIgJrQR9xdkEBcUEfIAJrQQF0cgsiAjYCHCAAQgA3AhAgAkECdEGMEmohAwJAAkACQEGAECgCACIEQQEgAkEfcXQiBXEEQCADKAIAIgQoAgRBeHEgAUcNASAEIQIMAgsgAyAANgIAQYAQIAQgBXI2AgAgACADNgIYIAAgADYCCCAAIAA2AgwPCyABQQBBGSACQQF2a0EfcSACQR9GG3QhAwNAIAQgA0EddkEEcWpBEGoiBSgCACICRQ0CIANBAXQhAyACIQQgAigCBEF4cSABRw0ACwsgAigCCCIDIAA2AgwgAiAANgIIIAAgAjYCDCAAIAM2AgggAEEANgIYDwsgBSAANgIAIAAgBDYCGCAAIAA2AgwgACAANgIIC/UEAQR/IAAgAWohAgJAAkACQAJAAkACQAJAAkAgACgCBCIDQQFxDQAgA0EDcUUNASAAKAIAIgMgAWohAQJAAkBBlBMoAgAgACADayIARwRAIANB/wFLDQEgACgCDCIEIAAoAggiBUYNAiAFIAQ2AgwgBCAFNgIIDAMLIAIoAgQiA0EDcUEDRw0CQYwTIAE2AgAgAkEEaiADQX5xNgIAIAAgAUEBcjYCBCACIAE2AgAPCyAAECMMAQtB/A9B/A8oAgBBfiADQQN2d3E2AgALAkAgAigCBCIDQQJxRQRAQZgTKAIAIAJGDQFBlBMoAgAgAkYNAyADQXhxIgQgAWohASAEQf8BSw0EIAIoAgwiBCACKAIIIgJGDQYgAiAENgIMIAQgAjYCCAwHCyACQQRqIANBfnE2AgAgACABQQFyNgIEIAAgAWogATYCAAwHC0GYEyAANgIAQZATQZATKAIAIAFqIgE2AgAgACABQQFyNgIEIABBlBMoAgBGDQMLDwtBlBMgADYCAEGME0GMEygCACABaiIBNgIAIAAgAUEBcjYCBCAAIAFqIAE2AgAPCyACECMMAgtBjBNBADYCAEGUE0EANgIADwtB/A9B/A8oAgBBfiADQQN2d3E2AgALIAAgAUEBcjYCBCAAIAFqIAE2AgAgAEGUEygCAEcNAEGMEyABNgIADwsCfwJAIAFB/wFNBEAgAUEDdiICQQN0QYQQaiEBQfwPKAIAIgNBASACQR9xdCICcUUNASABKAIIDAILIAAgARAkDwtB/A8gAyACcjYCACABCyECIAFBCGogADYCACACIAA2AgwgACABNgIMIAAgAjYCCAvSAgEFfyMAQRBrIgMkAAJ/IAAoAgAoAgAiAkGAgMQARwRAIAFBHGooAgAhBCABKAIYIQUgA0EANgIMAn8gAkH/AE0EQCADIAI6AAxBAQwBCyACQf8PTQRAIAMgAkE/cUGAAXI6AA0gAyACQQZ2QR9xQcABcjoADEECDAELIAJB//8DTQRAIAMgAkE/cUGAAXI6AA4gAyACQQZ2QT9xQYABcjoADSADIAJBDHZBD3FB4AFyOgAMQQMMAQsgAyACQRJ2QfABcjoADCADIAJBP3FBgAFyOgAPIAMgAkEMdkE/cUGAAXI6AA0gAyACQQZ2QT9xQYABcjoADkEECyEGQQEiAiAFIANBDGogBiAEKAIMEQUADQEaCyAAKAIELQAABEAgASgCGCAAKAIIIgAoAgAgACgCBCABQRxqKAIAKAIMEQUADAELQQALIQIgA0EQaiQAIAILqggBCX8jAEHQAGsiAiQAQSchAwJAIAAoAgAiAEGQzgBPBEADQCACQQlqIANqIgVBfGogACAAQZDOAG4iBEHwsX9saiIHQeQAbiIGQQF0QboLai8AADsAACAFQX5qIAcgBkGcf2xqQQF0QboLai8AADsAACADQXxqIQMgAEH/wdcvSyEFIAQhACAFDQALDAELIAAhBAsCQCAEQeQATgRAIAJBCWogA0F+aiIDaiAEIARB5ABuIgBBnH9sakEBdEG6C2ovAAA7AAAMAQsgBCEACwJAIABBCUwEQCACQQlqIANBf2oiA2oiCCAAQTBqOgAADAELIAJBCWogA0F+aiIDaiIIIABBAXRBugtqLwAAOwAACyACQQA2AjQgAkGEDTYCMCACQYCAxAA2AjhBJyADayIGIQMgASgCACIAQQFxBEAgAkErNgI4IAZBAWohAwsgAiAAQQJ2QQFxOgA/IAEoAgghBCACIAJBP2o2AkQgAiACQThqNgJAIAIgAkEwajYCSAJ/AkACQAJ/AkACQAJAAkACQAJAAkAgBEEBRgRAIAFBDGooAgAiBCADTQ0BIABBCHENAiAEIANrIQVBASABLQAwIgAgAEEDRhtBA3EiAEUNAyAAQQJGDQQMBQsgAkFAayABECYNCCABKAIYIAggBiABQRxqKAIAKAIMEQUADAoLIAJBQGsgARAmDQcgASgCGCAIIAYgAUEcaigCACgCDBEFAAwJCyABQQE6ADAgAUEwNgIEIAJBQGsgARAmDQYgAkEwNgJMIAQgA2shAyABKAIYIQRBfyEAIAFBHGooAgAiB0EMaiEFA0AgAEEBaiIAIANPDQQgBCACQcwAakEBIAUoAgARBQBFDQALDAYLIAUhCUEAIQUMAQsgBUEBakEBdiEJIAVBAXYhBQsgAkEANgJMIAEoAgQiAEH/AE0EQCACIAA6AExBAQwDCyAAQf8PSw0BIAIgAEE/cUGAAXI6AE0gAiAAQQZ2QR9xQcABcjoATEECDAILIAQgCCAGIAdBDGooAgARBQANAgwDCyAAQf//A00EQCACIABBP3FBgAFyOgBOIAIgAEEGdkE/cUGAAXI6AE0gAiAAQQx2QQ9xQeABcjoATEEDDAELIAIgAEESdkHwAXI6AEwgAiAAQT9xQYABcjoATyACIABBDHZBP3FBgAFyOgBNIAIgAEEGdkE/cUGAAXI6AE5BBAshBCABKAIYIQNBfyEAIAFBHGooAgAiCkEMaiEHAkADQCAAQQFqIgAgBU8NASADIAJBzABqIAQgBygCABEFAEUNAAsMAQsgAkFAayABECYNACADIAggBiAKQQxqKAIAIgURBQANAEF/IQADQCAAQQFqIgAgCU8NAiADIAJBzABqIAQgBREFAEUNAAsLQQEMAQtBAAshACACQdAAaiQAIAALRgIBfwF+IwBBIGsiAiQAIAEpAgAhAyACQRRqIAEpAgg3AgAgAkHMFDYCBCACQYQNNgIAIAIgADYCCCACIAM3AgwgAhAiAAsDAAELDQBCiLKUk5iBlYz/AAszAQF/IAIEQCAAIQMDQCADIAEtAAA6AAAgAUEBaiEBIANBAWohAyACQX9qIgINAAsLIAALZwEBfwJAIAEgAEkEQCACRQ0BA0AgACACakF/aiABIAJqQX9qLQAAOgAAIAJBf2oiAg0ACwwBCyACRQ0AIAAhAwNAIAMgAS0AADoAACABQQFqIQEgA0EBaiEDIAJBf2oiAg0ACwsgAAspAQF/IAIEQCAAIQMDQCADIAE6AAAgA0EBaiEDIAJBf2oiAg0ACwsgAAsLoQkDAEGACAu0AWludmFsaWQgbWFsbG9jIHJlcXVlc3RUcmllZCB0byBzaHJpbmsgdG8gYSBsYXJnZXIgY2FwYWNpdHlhc3NlcnRpb24gZmFpbGVkOiA4ID09IGRzdC5sZW4oKS9yb290Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2J5dGUtdG9vbHMtMC4yLjAvc3JjL3dyaXRlX3NpbmdsZS5ycwBBwAkL2gUvcm9vdC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9ibG9jay1idWZmZXItMC4zLjMvc3JjL2xpYi5yc2Rlc3RpbmF0aW9uIGFuZCBzb3VyY2Ugc2xpY2VzIGhhdmUgZGlmZmVyZW50IGxlbmd0aHMAZ+YJaoWuZ7ty8248OvVPpX9SDlGMaAWbq9mDHxnN4FsAAAAAAGNhcGFjaXR5IG92ZXJmbG93Y2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZWxpYmNvcmUvb3B0aW9uLnJzMDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTkAAABpbmRleCBvdXQgb2YgYm91bmRzOiB0aGUgbGVuIGlzICBidXQgdGhlIGluZGV4IGlzIGxpYmNvcmUvc2xpY2UvbW9kLnJzAAEAAAAAAAAAIAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAwAAAAEAAAABAAAAIAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAwAAAGluZGV4ICBvdXQgb2YgcmFuZ2UgZm9yIHNsaWNlIG9mIGxlbmd0aCBzbGljZSBpbmRleCBzdGFydHMgYXQgIGJ1dCBlbmRzIGF0IGludGVybmFsIGVycm9yOiBlbnRlcmVkIHVucmVhY2hhYmxlIGNvZGVsaWJhbGxvYy9yYXdfdmVjLnJzAEHEEwv9ARYEAAAkAAAAhwcAABMAAABIAgAACQAAAMAEAABTAAAASwAAABEAAAA6BAAAIAAAAFoEAABaAAAAHwAAAAUAAAATBQAANAAAALcGAAAUAAAAbQYAAAkAAABtBQAAEQAAAIcHAAATAAAA8gIAAAUAAAB+BQAAKwAAAKkFAAARAAAAWQEAABUAAAACAAAAAAAAAAEAAAADAAAAhQYAACAAAAClBgAAEgAAABQHAAAGAAAAGgcAACIAAAC3BgAAFAAAAK0HAAAFAAAAPAcAABYAAABSBwAADQAAALcGAAAUAAAAswcAAAUAAABfBwAAKAAAAIcHAAATAAAA9QEAAB4ADAdsaW5raW5nAwLEDQ==";

// node_modules/@bitauth/libauth/build/lib/bin/sha512/sha512.base64.js
var import_dist58 = __toESM(require_dist(), 1);
var import_dist59 = __toESM(require_dist2(), 1);
var import_dist60 = __toESM(require_dist3(), 1);
var sha512Base64Bytes = "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AjYCACAAIAJBAXI2AgQMBQsgAEGsEygCACACaiICQQFyNgIEQbQTIAA2AgBBrBMgAjYCACAAIAJqIAI2AgAMBAsgAxAiDAELQZwQQZwQKAIAQX4gAUEDdndxNgIACyAEIAJqIQIgAyAEaiEDCyADIAMoAgRBfnE2AgQgACACQQFyNgIEIAAgAmogAjYCAAJ/AkAgAkH/AU0EQCACQQN2IgFBA3RBpBBqIQJBnBAoAgAiA0EBIAFBH3F0IgFxRQ0BIAJBCGohAyACKAIIDAILIAAgAhAjDAILQZwQIAMgAXI2AgAgAkEIaiEDIAILIQEgAyAANgIAIAEgADYCDCAAIAI2AgwgACABNgIICyAFQQhqDwtBsBMgACACayIBNgIAQbgTQbgTKAIAIgAgAmoiAzYCACADIAFBAXI2AgQgACACQQNyNgIEIABBCGoLpQEBAn9BAiEFAkACQAJAAkACQCAAKAIEIgYgAWsgAk8NACABIAJqIgIgAUkhAQJAIAQEQEEAIQUgAQ0CIAZBAXQiASACIAIgAUkbIQIMAQtBACEFIAENAQsgAkEASA0AIAZFDQEgACgCACACEBMiAUUNAgwDCyAFDwsgAhAEIgENAQsgAw0BCyABBEAgACABNgIAIABBBGogAjYCAEECDwtBAQ8LAAsIAEG8FBAHAAtmAgF/A34jAEEwayIBJAAgACkCECECIAApAgghAyAAKQIAIQQgAUEUakEANgIAIAEgBDcDGCABQgE3AgQgAUGkDTYCECABIAFBGGo2AgAgASADNwMgIAEgAjcDKCABIAFBIGoQJwALsgEBAn8jAEGABGsiAyQAIANB2ABqIgRCADcDACADQgA3A1AgA0GgAWpBAEGEARAsGiADQeAAakHICkHAABAqGiADQdAAaiABIAIQCSADQagCaiADQdAAakHYARAqGiADQRBqIANBqAJqEAogA0HQAGogA0EQakHAABADIANBsAJqIAQoAgA2AgAgAyADKQNQNwOoAiADQQhqIANBqAJqEAsgACADKQMINwIAIANBgARqJAALuwMCBH8CfiMAQUBqIgMkACAAIAApAwgiByACrUIDhnwiCDcDCCAIIAdUBEAgACAAKQMAQgF8NwMACyADIABBEGo2AiggAyADQShqNgIsAkACQAJAAkACQAJAIAAoAlAiBQRAQYABIAVrIgQg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sBMoAgAgAGoiADYCACABIABBAXI2AgQgAUG0EygCAEYEQEGsE0EANgIAQbQTQQA2AgALQdQTKAIAIABPDQcCQCAAQSlJDQBBxBMhAANAIAAoAgAiAiABTQRAIAIgACgCBGogAUsNAgsgACgCCCIADQALC0EAIQFBzBMoAgAiAEUNBANAIAFBAWohASAAKAIIIgANAAsgAUH/HyABQf8fSxsMBQtBtBMgATYCAEGsE0GsEygCACAAaiIANgIADAcLIAIQIgwBC0GcEEGcECgCAEF+IANBA3Z3cTYCAAsgASAAQQFyNgIEIAEgAGogADYCACABQbQTKAIARw0CQawTIAA2AgAPC0H/HwshAUHUE0F/NgIAQdwTIAE2AgAPC0HcEwJ/AkACfwJAIABB/wFNBEAgAEEDdiICQQN0QaQQaiEAQZwQKAIAIgNBASACQR9xdCICcUUNASAAQQhqIQMgACgCCAwCCyABIAAQI0HcE0HcEygCAEF/aiIBNgIAIAENBEHMEygCACIARQ0CQQAhAQNAIAFBAWohASAAKAIIIgANAAsgAUH/HyABQf8fSxsMAwtBnBAgAyACcjYCACAAQQhqIQMgAAshAiADIAE2AgAgAiABNgIMIAEgADYCDCABIAI2AggPC0H/HwsiATYCAAsPCyABIABBAXI2AgQgASAAaiAANgIACzkAAkAgAiABTwRAIAJBgQFPDQEgACACIAFrNgIEIAAgAyABajYCAA8LIAEgAhAcAAsgAkGAARACAAtNAgF/An4jAEEQayIEJAAgBEEIakEAIAMgASACEBkgBCkDCCEFIAQgAyACIAEgAhAZIAQpAwAhBiAAIAU3AgAgACAGNwIIIARBEGokAAssAQF/IwBBEGsiAyQAIANBCGogAkGAASABEBUgACADKQMINwIAIANBEGokAAsOACAAKAIAKAIAIAEQGws3AAJAIAIgAU8EQCAEIAJJDQEgACACIAFrNgIEIAAgAyABajYCAA8LIAEgAhAcAAsgAiAEEAIACysBAX8jAEEQayIDJAAgA0EIakEAIAIgARAVIAAgAykDCDcCACADQRBqJAALqioCAn8ifiMAQYAPayICJAAgAkGADmogAUGAARAqGkEAIQECQANAIAFBgAFGDQEgAkGADmogAWoiAyADKQMAIhxCOIYgHEIohkKAgICAgIDA/wCD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c2VydGlvbiBmYWlsZWQ6IDggPT0gZHN0LmxlbigpL3Jvb3QvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvYnl0ZS10b29scy0wLjIuMC9zcmMvd3JpdGVfc2luZ2xlLnJzAEHwCQvKBS9yb290Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2Jsb2NrLWJ1ZmZlci0wLjMuMy9zcmMvbGliLnJzAAAAAAAIybzzZ+YJajunyoSFrme7K/iU/nLzbjzxNh1fOvVPpdGC5q1/Ug5RH2w+K4xoBZtrvUH7q9mDH3khfhMZzeBbAAAAAABjYXBhY2l0eSBvdmVyZmxvd2NhbGxlZCBgT3B0aW9uOjp1bndyYXAoKWAgb24gYSBgTm9uZWAgdmFsdWVsaWJjb3JlL29wdGlvbi5yczAwMDEwMjAzMDQwNTA2MDcwODA5MTAxMTEyMTMxNDE1MTYxNzE4MTkyMDIxMjIyMzI0MjUyNjI3MjgyOTMwMzEzMjMzMzQzNTM2MzczODM5NDA0MTQyNDM0NDQ1NDY0NzQ4NDk1MDUxNTI1MzU0NTU1NjU3NTg1OTYwNjE2MjYzNjQ2NTY2Njc2ODY5NzA3MTcyNzM3NDc1NzY3Nzc4Nzk4MDgxODI4Mzg0ODU4Njg3ODg4OTkwOTE5MjkzOTQ5NTk2OTc5ODk5AAAAaW5kZXggb3V0IG9mIGJvdW5kczogdGhlIGxlbiBpcyAgYnV0IHRoZSBpbmRleCBpcyBsaWJjb3JlL3NsaWNlL21vZC5ycwABAAAAAAAAACAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAABAAAAAQAAACAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAABpbmRleCAgb3V0IG9mIHJhbmdlIGZvciBzbGljZSBvZiBsZW5ndGggc2xpY2UgaW5kZXggc3RhcnRzIGF0ICBidXQgZW5kcyBhdCBpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2RlbGliYWxsb2MvcmF3X3ZlYy5ycwBB5BML/QEWBAAAJAAAAKcHAAATAAAASAIAAAkAAAA6BAAANAAAANcGAAAUAAAAbQYAAAkAAADwBAAAUwAAAEsAAAARAAAAbgQAACAAAACOBAAAWgAAAB8AAAAFAAAAjQUAABEAAACnBwAAEwAAAPICAAAFAAAAngUAACsAAADJBQAAEQAAAFkBAAAVAAAAAgAAAAAAAAABAAAAAwAAAKUGAAAgAAAAxQYAABIAAAA0BwAABgAAADoHAAAiAAAA1wYAABQAAACtBwAABQAAAFwHAAAWAAAAcgcAAA0AAADXBgAAFAAAALMHAAAFAAAAfwcAACgAAACnBwAAEwAAAPUBAAAeAAwHbGlua2luZwMC5A0=";

// node_modules/@bitauth/libauth/build/lib/crypto/ripemd160.js
var instantiateRipemd160Bytes = async (webassemblyBytes) => {
  const wasm = await instantiateRustWasm(webassemblyBytes, "./ripemd160", "ripemd160", "ripemd160_init", "ripemd160_update", "ripemd160_final");
  return {
    final: wasm.final,
    hash: wasm.hash,
    init: wasm.init,
    update: wasm.update
  };
};
var getEmbeddedRipemd160Binary = () => base64ToBin(ripemd160Base64Bytes).buffer;
var instantiateRipemd160 = async () => instantiateRipemd160Bytes(getEmbeddedRipemd160Binary());

// node_modules/@bitauth/libauth/build/lib/crypto/secp256k1.js
var import_dist70 = __toESM(require_dist(), 1);
var import_dist71 = __toESM(require_dist2(), 1);
var import_dist72 = __toESM(require_dist3(), 1);
var Secp256k1Error;
(function(Secp256k1Error2) {
  Secp256k1Error2["unparsableSignature"] = "Failed to parse signature.";
  Secp256k1Error2["unparsablePublicKey"] = "Failed to parse public key.";
  Secp256k1Error2["derivePublicKeyFromInvalidPrivateKey"] = "Cannot derive public key from invalid private key.";
  Secp256k1Error2["signWithInvalidPrivateKey"] = "Failed to sign message hash. The private key is not valid.";
  Secp256k1Error2["recoverPublicKeyWithUnparsableSignature"] = "Failed to recover public key. Could not parse signature.";
  Secp256k1Error2["recoverPublicKeyInvalidMaterial"] = "Failed to recover public key. The compact signature, recovery, or message hash is invalid.";
  Secp256k1Error2["addTweakPrivateKey"] = "Private key is invalid or adding failed.";
  Secp256k1Error2["mulTweakPrivateKey"] = "Private key is invalid or multiplying failed.";
  Secp256k1Error2["addTweakPublicKey"] = "Failed to tweak public key (by addition).";
  Secp256k1Error2["mulTweakPublicKey"] = "Failed to tweak public key (by multiplication).";
})(Secp256k1Error || (Secp256k1Error = {}));
var wrapSecp256k1Wasm2 = (secp256k1Wasm, randomSeed) => {
  const contextPtr = secp256k1Wasm.contextCreate(ContextFlag.BOTH);
  const sigScratch = secp256k1Wasm.malloc(
    72
    /* ByteLength.maxECDSASig */
  );
  const publicKeyScratch = secp256k1Wasm.malloc(
    65
    /* ByteLength.maxPublicKey */
  );
  const messageHashScratch = secp256k1Wasm.malloc(
    32
    /* ByteLength.messageHash */
  );
  const internalPublicKeyPtr = secp256k1Wasm.malloc(
    64
    /* ByteLength.internalPublicKey */
  );
  const internalSigPtr = secp256k1Wasm.malloc(
    64
    /* ByteLength.internalSig */
  );
  const schnorrSigPtr = secp256k1Wasm.malloc(
    64
    /* ByteLength.schnorrSig */
  );
  const privateKeyPtr = secp256k1Wasm.malloc(
    32
    /* ByteLength.privateKey */
  );
  const internalRSigPtr = secp256k1Wasm.malloc(
    65
    /* ByteLength.recoverableSig */
  );
  const recoveryNumPtr = secp256k1Wasm.malloc(4);
  const recoveryNumPtrView32 = recoveryNumPtr >> 2;
  const getRecoveryNumPtr = () => secp256k1Wasm.heapU32[recoveryNumPtrView32];
  const lengthPtr = secp256k1Wasm.malloc(4);
  const lengthPtrView32 = lengthPtr >> 2;
  const cloneAndPad = (value, expectedLength) => {
    const zeroPaddedValue = new Uint8Array(expectedLength);
    zeroPaddedValue.set(value);
    return zeroPaddedValue;
  };
  const parsePublicKey = (publicKey) => {
    const paddedPublicKey = cloneAndPad(
      publicKey,
      65
      /* ByteLength.maxPublicKey */
    );
    secp256k1Wasm.heapU8.set(paddedPublicKey, publicKeyScratch);
    return secp256k1Wasm.pubkeyParse(
      contextPtr,
      internalPublicKeyPtr,
      publicKeyScratch,
      // eslint-disable-next-line @typescript-eslint/no-magic-numbers
      publicKey.length
    ) === 1;
  };
  const setLengthPtr = (value) => {
    secp256k1Wasm.heapU32.set([value], lengthPtrView32);
  };
  const getLengthPtr = () => secp256k1Wasm.heapU32[lengthPtrView32];
  const serializePublicKey = (length, flag) => {
    setLengthPtr(length);
    secp256k1Wasm.pubkeySerialize(contextPtr, publicKeyScratch, lengthPtr, internalPublicKeyPtr, flag);
    return secp256k1Wasm.readHeapU8(publicKeyScratch, getLengthPtr()).slice();
  };
  const getSerializedPublicKey = (compressed) => compressed ? serializePublicKey(33, CompressionFlag.COMPRESSED) : serializePublicKey(65, CompressionFlag.UNCOMPRESSED);
  const convertPublicKey = (compressed) => (publicKey) => {
    if (!parsePublicKey(publicKey)) {
      return Secp256k1Error.unparsablePublicKey;
    }
    return getSerializedPublicKey(compressed);
  };
  const parseSignature = (signature, isDer) => {
    const paddedSignature = cloneAndPad(
      signature,
      72
      /* ByteLength.maxECDSASig */
    );
    secp256k1Wasm.heapU8.set(paddedSignature, sigScratch);
    return isDer ? secp256k1Wasm.signatureParseDER(contextPtr, internalSigPtr, sigScratch, signature.length) === 1 : secp256k1Wasm.signatureParseCompact(contextPtr, internalSigPtr, sigScratch) === 1;
  };
  const getCompactSig = () => {
    secp256k1Wasm.signatureSerializeCompact(contextPtr, sigScratch, internalSigPtr);
    return secp256k1Wasm.readHeapU8(
      sigScratch,
      64
      /* ByteLength.compactSig */
    ).slice();
  };
  const getDERSig = () => {
    setLengthPtr(
      72
      /* ByteLength.maxECDSASig */
    );
    secp256k1Wasm.signatureSerializeDER(contextPtr, sigScratch, lengthPtr, internalSigPtr);
    return secp256k1Wasm.readHeapU8(sigScratch, getLengthPtr()).slice();
  };
  const convertSignature = (wasDER) => (signature) => {
    if (!parseSignature(signature, wasDER)) {
      return Secp256k1Error.unparsableSignature;
    }
    return wasDER ? getCompactSig() : getDERSig();
  };
  const fillPrivateKeyPtr = (privateKey) => {
    const paddedPrivateKey = cloneAndPad(
      privateKey,
      32
      /* ByteLength.privateKey */
    );
    secp256k1Wasm.heapU8.set(paddedPrivateKey, privateKeyPtr);
  };
  const zeroOutPtr = (pointer, bytes) => {
    secp256k1Wasm.heapU8.fill(0, pointer, pointer + bytes);
  };
  const zeroOutPrivateKeyPtr = () => {
    zeroOutPtr(
      privateKeyPtr,
      32
      /* ByteLength.privateKey */
    );
  };
  const withPrivateKey = (privateKey, instructions) => {
    fillPrivateKeyPtr(privateKey);
    const ret = instructions();
    zeroOutPrivateKeyPtr();
    return ret;
  };
  const derivePublicKey = (compressed) => (privateKey) => {
    const invalid = withPrivateKey(privateKey, () => secp256k1Wasm.pubkeyCreate(contextPtr, internalPublicKeyPtr, privateKeyPtr) !== 1);
    if (invalid) {
      return Secp256k1Error.derivePublicKeyFromInvalidPrivateKey;
    }
    return getSerializedPublicKey(compressed);
  };
  const fillMessageHashScratch = (messageHash) => {
    const paddedMessageHash = cloneAndPad(
      messageHash,
      32
      /* ByteLength.messageHash */
    );
    secp256k1Wasm.heapU8.set(paddedMessageHash, messageHashScratch);
  };
  const normalizeSignature = () => {
    secp256k1Wasm.signatureNormalize(contextPtr, internalSigPtr, internalSigPtr);
  };
  const modifySignature = (isDer, normalize) => (signature) => {
    if (!parseSignature(signature, isDer)) {
      return Secp256k1Error.unparsableSignature;
    }
    if (normalize) {
      normalizeSignature();
    } else {
      secp256k1Wasm.signatureMalleate(contextPtr, internalSigPtr, internalSigPtr);
    }
    return isDer ? getDERSig() : getCompactSig();
  };
  const parseAndNormalizeSignature = (signature, isDer, normalize) => {
    const ret = parseSignature(signature, isDer);
    if (normalize) {
      normalizeSignature();
    }
    return ret;
  };
  const signMessageHash = (isDer) => (privateKey, messageHash) => {
    fillMessageHashScratch(messageHash);
    return withPrivateKey(privateKey, () => {
      const failed = secp256k1Wasm.sign(contextPtr, internalSigPtr, messageHashScratch, privateKeyPtr) !== 1;
      if (failed) {
        return Secp256k1Error.signWithInvalidPrivateKey;
      }
      if (isDer) {
        setLengthPtr(
          72
          /* ByteLength.maxECDSASig */
        );
        secp256k1Wasm.signatureSerializeDER(contextPtr, sigScratch, lengthPtr, internalSigPtr);
        return secp256k1Wasm.readHeapU8(sigScratch, getLengthPtr()).slice();
      }
      secp256k1Wasm.signatureSerializeCompact(contextPtr, sigScratch, internalSigPtr);
      return secp256k1Wasm.readHeapU8(
        sigScratch,
        64
        /* ByteLength.compactSig */
      ).slice();
    });
  };
  const signMessageHashSchnorr = () => (privateKey, messageHash) => {
    fillMessageHashScratch(messageHash);
    return withPrivateKey(privateKey, () => {
      const failed = secp256k1Wasm.schnorrSign(contextPtr, schnorrSigPtr, messageHashScratch, privateKeyPtr) !== 1;
      if (failed) {
        return Secp256k1Error.signWithInvalidPrivateKey;
      }
      return secp256k1Wasm.readHeapU8(
        schnorrSigPtr,
        64
        /* ByteLength.schnorrSig */
      ).slice();
    });
  };
  const verifyMessage = (messageHash) => {
    fillMessageHashScratch(messageHash);
    return secp256k1Wasm.verify(contextPtr, internalSigPtr, messageHashScratch, internalPublicKeyPtr) === 1;
  };
  const verifySignature = (isDer, normalize) => (signature, publicKey, messageHash) => parsePublicKey(publicKey) && parseAndNormalizeSignature(signature, isDer, normalize) && verifyMessage(messageHash);
  const verifyMessageSchnorr = (messageHash, signature) => {
    fillMessageHashScratch(messageHash);
    const paddedSignature = cloneAndPad(
      signature,
      64
      /* ByteLength.schnorrSig */
    );
    secp256k1Wasm.heapU8.set(paddedSignature, schnorrSigPtr);
    return secp256k1Wasm.schnorrVerify(contextPtr, schnorrSigPtr, messageHashScratch, internalPublicKeyPtr) === 1;
  };
  const verifySignatureSchnorr = () => (signature, publicKey, messageHash) => parsePublicKey(publicKey) ? verifyMessageSchnorr(messageHash, signature) : false;
  const signMessageHashRecoverable = (privateKey, messageHash) => {
    fillMessageHashScratch(messageHash);
    return withPrivateKey(privateKey, () => {
      if (secp256k1Wasm.signRecoverable(contextPtr, internalRSigPtr, messageHashScratch, privateKeyPtr) !== 1) {
        return Secp256k1Error.signWithInvalidPrivateKey;
      }
      secp256k1Wasm.recoverableSignatureSerialize(contextPtr, sigScratch, recoveryNumPtr, internalRSigPtr);
      return {
        recoveryId: getRecoveryNumPtr(),
        signature: secp256k1Wasm.readHeapU8(
          sigScratch,
          64
          /* ByteLength.compactSig */
        ).slice()
      };
    });
  };
  const recoverPublicKey = (compressed) => (signature, recoveryId, messageHash) => {
    fillMessageHashScratch(messageHash);
    const paddedSignature = cloneAndPad(
      signature,
      72
      /* ByteLength.maxECDSASig */
    );
    secp256k1Wasm.heapU8.set(paddedSignature, sigScratch);
    if (secp256k1Wasm.recoverableSignatureParse(contextPtr, internalRSigPtr, sigScratch, recoveryId) !== 1) {
      return Secp256k1Error.recoverPublicKeyWithUnparsableSignature;
    }
    if (secp256k1Wasm.recover(contextPtr, internalPublicKeyPtr, internalRSigPtr, messageHashScratch) !== 1) {
      return Secp256k1Error.recoverPublicKeyInvalidMaterial;
    }
    return getSerializedPublicKey(compressed);
  };
  const addTweakPrivateKey = (privateKey, tweakValue) => {
    fillMessageHashScratch(tweakValue);
    return withPrivateKey(privateKey, () => {
      if (secp256k1Wasm.privkeyTweakAdd(contextPtr, privateKeyPtr, messageHashScratch) !== 1) {
        return Secp256k1Error.addTweakPrivateKey;
      }
      return secp256k1Wasm.readHeapU8(
        privateKeyPtr,
        32
        /* ByteLength.privateKey */
      ).slice();
    });
  };
  const mulTweakPrivateKey = (privateKey, tweakValue) => {
    fillMessageHashScratch(tweakValue);
    return withPrivateKey(privateKey, () => {
      if (secp256k1Wasm.privkeyTweakMul(contextPtr, privateKeyPtr, messageHashScratch) !== 1) {
        return Secp256k1Error.mulTweakPrivateKey;
      }
      return secp256k1Wasm.readHeapU8(
        privateKeyPtr,
        32
        /* ByteLength.privateKey */
      ).slice();
    });
  };
  const addTweakPublicKey = (compressed) => (publicKey, tweakValue) => {
    if (!parsePublicKey(publicKey)) {
      return Secp256k1Error.unparsablePublicKey;
    }
    fillMessageHashScratch(tweakValue);
    if (secp256k1Wasm.pubkeyTweakAdd(contextPtr, internalPublicKeyPtr, messageHashScratch) !== 1) {
      return Secp256k1Error.addTweakPublicKey;
    }
    return getSerializedPublicKey(compressed);
  };
  const mulTweakPublicKey = (compressed) => (publicKey, tweakValue) => {
    if (!parsePublicKey(publicKey)) {
      return Secp256k1Error.unparsablePublicKey;
    }
    fillMessageHashScratch(tweakValue);
    if (secp256k1Wasm.pubkeyTweakMul(contextPtr, internalPublicKeyPtr, messageHashScratch) !== 1) {
      return Secp256k1Error.mulTweakPublicKey;
    }
    return getSerializedPublicKey(compressed);
  };
  if (randomSeed !== void 0) {
    const randomSeedPtr = messageHashScratch;
    const paddedRandomSeed = cloneAndPad(
      randomSeed,
      32
      /* ByteLength.randomSeed */
    );
    secp256k1Wasm.heapU8.set(paddedRandomSeed, randomSeedPtr);
    secp256k1Wasm.contextRandomize(contextPtr, randomSeedPtr);
    zeroOutPtr(
      randomSeedPtr,
      32
      /* ByteLength.randomSeed */
    );
  }
  return {
    addTweakPrivateKey,
    addTweakPublicKeyCompressed: addTweakPublicKey(true),
    addTweakPublicKeyUncompressed: addTweakPublicKey(false),
    compressPublicKey: convertPublicKey(true),
    derivePublicKeyCompressed: derivePublicKey(true),
    derivePublicKeyUncompressed: derivePublicKey(false),
    malleateSignatureCompact: modifySignature(false, false),
    malleateSignatureDER: modifySignature(true, false),
    mulTweakPrivateKey,
    mulTweakPublicKeyCompressed: mulTweakPublicKey(true),
    mulTweakPublicKeyUncompressed: mulTweakPublicKey(false),
    normalizeSignatureCompact: modifySignature(false, true),
    normalizeSignatureDER: modifySignature(true, true),
    recoverPublicKeyCompressed: recoverPublicKey(true),
    recoverPublicKeyUncompressed: recoverPublicKey(false),
    signMessageHashCompact: signMessageHash(false),
    signMessageHashDER: signMessageHash(true),
    signMessageHashRecoverableCompact: signMessageHashRecoverable,
    signMessageHashSchnorr: signMessageHashSchnorr(),
    signatureCompactToDER: convertSignature(false),
    signatureDERToCompact: convertSignature(true),
    uncompressPublicKey: convertPublicKey(false),
    validatePrivateKey: (privateKey) => withPrivateKey(privateKey, () => secp256k1Wasm.seckeyVerify(contextPtr, privateKeyPtr) === 1),
    validatePublicKey: parsePublicKey,
    verifySignatureCompact: verifySignature(false, true),
    verifySignatureCompactLowS: verifySignature(false, false),
    verifySignatureDER: verifySignature(true, true),
    verifySignatureDERLowS: verifySignature(true, false),
    verifySignatureSchnorr: verifySignatureSchnorr()
  };
};
var instantiateSecp256k1Bytes = async (webassemblyBytes, randomSeed) => wrapSecp256k1Wasm2(await instantiateSecp256k1WasmBytes(webassemblyBytes), randomSeed);
var instantiateSecp256k1 = async (randomSeed) => wrapSecp256k1Wasm2(await instantiateSecp256k1Wasm(), randomSeed);

// node_modules/@bitauth/libauth/build/lib/crypto/sha1.js
var import_dist73 = __toESM(require_dist(), 1);
var import_dist74 = __toESM(require_dist2(), 1);
var import_dist75 = __toESM(require_dist3(), 1);
var instantiateSha1Bytes = async (webassemblyBytes) => {
  const wasm = await instantiateRustWasm(webassemblyBytes, "./sha1", "sha1", "sha1_init", "sha1_update", "sha1_final");
  return {
    final: wasm.final,
    hash: wasm.hash,
    init: wasm.init,
    update: wasm.update
  };
};
var getEmbeddedSha1Binary = () => base64ToBin(sha1Base64Bytes).buffer;
var instantiateSha1 = async () => instantiateSha1Bytes(getEmbeddedSha1Binary());

// node_modules/@bitauth/libauth/build/lib/crypto/sha256.js
var import_dist76 = __toESM(require_dist(), 1);
var import_dist77 = __toESM(require_dist2(), 1);
var import_dist78 = __toESM(require_dist3(), 1);
var instantiateSha256Bytes = async (webassemblyBytes) => {
  const wasm = await instantiateRustWasm(webassemblyBytes, "./sha256", "sha256", "sha256_init", "sha256_update", "sha256_final");
  return {
    final: wasm.final,
    hash: wasm.hash,
    init: wasm.init,
    update: wasm.update
  };
};
var getEmbeddedSha256Binary = () => base64ToBin(sha256Base64Bytes).buffer;
var instantiateSha256 = async () => instantiateSha256Bytes(getEmbeddedSha256Binary());

// node_modules/@bitauth/libauth/build/lib/crypto/sha512.js
var import_dist79 = __toESM(require_dist(), 1);
var import_dist80 = __toESM(require_dist2(), 1);
var import_dist81 = __toESM(require_dist3(), 1);
var instantiateSha512Bytes = async (webassemblyBytes) => {
  const wasm = await instantiateRustWasm(webassemblyBytes, "./sha512", "sha512", "sha512_init", "sha512_update", "sha512_final");
  return {
    final: wasm.final,
    hash: wasm.hash,
    init: wasm.init,
    update: wasm.update
  };
};
var getEmbeddedSha512Binary = () => base64ToBin(sha512Base64Bytes).buffer;
var instantiateSha512 = async () => instantiateSha512Bytes(getEmbeddedSha512Binary());

// node_modules/@bitauth/libauth/build/lib/crypto/default-crypto-instances.js
var [sha1, sha256, sha512, ripemd160, secp256k1] = await Promise.all([
  instantiateSha1(),
  instantiateSha256(),
  instantiateSha512(),
  instantiateRipemd160(),
  instantiateSecp256k1()
]);

// node_modules/@bitauth/libauth/build/lib/crypto/combinations.js
var hash160 = (payload, crypto = { ripemd160, sha256 }) => crypto.ripemd160.hash(crypto.sha256.hash(payload));
var hash256 = (payload, sha2562 = sha256) => sha2562.hash(sha2562.hash(payload));

// node_modules/@bitauth/libauth/build/lib/crypto/hmac.js
var import_dist88 = __toESM(require_dist(), 1);
var import_dist89 = __toESM(require_dist2(), 1);
var import_dist90 = __toESM(require_dist3(), 1);
var instantiateHmacFunction = (hashFunction, blockByteLength) => (secret, message) => {
  const key = new Uint8Array(blockByteLength).fill(0);
  key.set(secret.length > blockByteLength ? hashFunction(secret) : secret, 0);
  const innerPaddingFill = 54;
  const innerPadding = new Uint8Array(blockByteLength).fill(innerPaddingFill);
  const innerPrefix = innerPadding.map((pad, index2) => pad ^ key[index2]);
  const innerContent = flattenBinArray([innerPrefix, message]);
  const innerResult = hashFunction(innerContent);
  const outerPaddingFill = 92;
  const outerPadding = new Uint8Array(blockByteLength).fill(outerPaddingFill);
  const outerPrefix = outerPadding.map((pad, index2) => pad ^ key[index2]);
  return hashFunction(flattenBinArray([outerPrefix, innerResult]));
};
var sha256BlockByteLength = 64;
var hmacSha256 = (secret, message, sha2562 = sha256) => instantiateHmacFunction(sha2562.hash, sha256BlockByteLength)(secret, message);
var sha512BlockByteLength = 128;
var hmacSha512 = (secret, message, sha5122 = sha512) => instantiateHmacFunction(sha5122.hash, sha512BlockByteLength)(secret, message);

// node_modules/@bitauth/libauth/build/lib/crypto/secp256k1-types.js
var import_dist91 = __toESM(require_dist(), 1);
var import_dist92 = __toESM(require_dist2(), 1);
var import_dist93 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/address/base58-address.js
var Base58AddressFormatVersion;
(function(Base58AddressFormatVersion2) {
  Base58AddressFormatVersion2[Base58AddressFormatVersion2["p2pkh"] = 0] = "p2pkh";
  Base58AddressFormatVersion2[Base58AddressFormatVersion2["p2sh20"] = 5] = "p2sh20";
  Base58AddressFormatVersion2[Base58AddressFormatVersion2["wif"] = 128] = "wif";
  Base58AddressFormatVersion2[Base58AddressFormatVersion2["p2pkhTestnet"] = 111] = "p2pkhTestnet";
  Base58AddressFormatVersion2[Base58AddressFormatVersion2["p2sh20Testnet"] = 196] = "p2sh20Testnet";
  Base58AddressFormatVersion2[Base58AddressFormatVersion2["wifTestnet"] = 239] = "wifTestnet";
  Base58AddressFormatVersion2[Base58AddressFormatVersion2["p2pkhCopayBCH"] = 28] = "p2pkhCopayBCH";
  Base58AddressFormatVersion2[Base58AddressFormatVersion2["p2sh20CopayBCH"] = 40] = "p2sh20CopayBCH";
})(Base58AddressFormatVersion || (Base58AddressFormatVersion = {}));
var encodeBase58AddressFormat = (version, payload, sha2562 = sha256) => {
  const checksumBytes = 4;
  const content = Uint8Array.from([version, ...payload]);
  const checksum = hash256(content, sha2562).slice(0, checksumBytes);
  const bin = flattenBinArray([content, checksum]);
  return binToBase58(bin);
};
var encodeBase58Address = (type, payload, sha2562 = sha256) => encodeBase58AddressFormat({
  p2pkh: Base58AddressFormatVersion.p2pkh,
  p2pkhCopayBCH: Base58AddressFormatVersion.p2pkhCopayBCH,
  p2pkhTestnet: Base58AddressFormatVersion.p2pkhTestnet,
  p2sh20: Base58AddressFormatVersion.p2sh20,
  p2sh20CopayBCH: Base58AddressFormatVersion.p2sh20CopayBCH,
  p2sh20Testnet: Base58AddressFormatVersion.p2sh20Testnet
}[type], payload, sha2562);
var Base58AddressError;
(function(Base58AddressError2) {
  Base58AddressError2["unknownCharacter"] = "Base58Address error: address may only contain valid base58 characters.";
  Base58AddressError2["tooShort"] = "Base58Address error: address is too short to be valid.";
  Base58AddressError2["invalidChecksum"] = "Base58Address error: address has an invalid checksum.";
  Base58AddressError2["unknownAddressVersion"] = "Base58Address error: address uses an unknown address version.";
  Base58AddressError2["incorrectLength"] = "Base58Address error: the encoded payload is not the correct length (20 bytes).";
})(Base58AddressError || (Base58AddressError = {}));
var decodeBase58AddressFormat = (address, sha2562 = sha256) => {
  const checksumBytes = 4;
  const bin = base58ToBin(address);
  if (bin === BaseConversionError.unknownCharacter) {
    return Base58AddressError.unknownCharacter;
  }
  const minimumBase58AddressLength = 5;
  if (bin.length < minimumBase58AddressLength) {
    return Base58AddressError.tooShort;
  }
  const content = bin.slice(0, -checksumBytes);
  const checksum = bin.slice(-checksumBytes);
  const expectedChecksum = sha2562.hash(sha2562.hash(content)).slice(0, checksumBytes);
  if (!checksum.every((value, i) => value === expectedChecksum[i])) {
    return Base58AddressError.invalidChecksum;
  }
  return {
    payload: content.slice(1),
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    version: content[0]
  };
};
var decodeBase58Address = (address, sha2562 = sha256) => {
  const decoded = decodeBase58AddressFormat(address, sha2562);
  if (typeof decoded === "string")
    return decoded;
  if (![
    Base58AddressFormatVersion.p2pkh,
    Base58AddressFormatVersion.p2sh20,
    Base58AddressFormatVersion.p2pkhTestnet,
    Base58AddressFormatVersion.p2sh20Testnet,
    Base58AddressFormatVersion.p2pkhCopayBCH,
    Base58AddressFormatVersion.p2sh20CopayBCH
  ].includes(decoded.version)) {
    return Base58AddressError.unknownAddressVersion;
  }
  const hash160Length = 20;
  if (decoded.payload.length !== hash160Length) {
    return Base58AddressError.incorrectLength;
  }
  return decoded;
};

// node_modules/@bitauth/libauth/build/lib/address/bech32.js
var import_dist100 = __toESM(require_dist(), 1);
var import_dist101 = __toESM(require_dist2(), 1);
var import_dist102 = __toESM(require_dist3(), 1);
var bech32CharacterSet = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
var bech32CharacterSetIndex = { q: 0, p: 1, z: 2, r: 3, y: 4, "9": 5, x: 6, "8": 7, g: 8, f: 9, "2": 10, t: 11, v: 12, d: 13, w: 14, "0": 15, s: 16, "3": 17, j: 18, n: 19, "5": 20, "4": 21, k: 22, h: 23, c: 24, e: 25, "6": 26, m: 27, u: 28, a: 29, "7": 30, l: 31 };
var BitRegroupingError;
(function(BitRegroupingError2) {
  BitRegroupingError2["integerOutOfRange"] = "An integer provided in the source array is out of the range of the specified source word length.";
  BitRegroupingError2["hasDisallowedPadding"] = "Encountered padding when padding was disallowed.";
  BitRegroupingError2["requiresDisallowedPadding"] = "Encoding requires padding while padding is disallowed.";
})(BitRegroupingError || (BitRegroupingError = {}));
var regroupBits = ({ bin, sourceWordLength, resultWordLength, allowPadding = true }) => {
  let accumulator = 0;
  let bits = 0;
  const result = [];
  const maxResultInt = (1 << resultWordLength) - 1;
  for (let p = 0; p < bin.length; ++p) {
    const value = bin[p];
    if (value < 0 || value >> sourceWordLength !== 0) {
      return BitRegroupingError.integerOutOfRange;
    }
    accumulator = accumulator << sourceWordLength | value;
    bits += sourceWordLength;
    while (bits >= resultWordLength) {
      bits -= resultWordLength;
      result.push(accumulator >> bits & maxResultInt);
    }
  }
  if (allowPadding) {
    if (bits > 0) {
      result.push(accumulator << resultWordLength - bits & maxResultInt);
    }
  } else if (bits >= sourceWordLength) {
    return BitRegroupingError.hasDisallowedPadding;
  } else if ((accumulator << resultWordLength - bits & maxResultInt) > 0) {
    return BitRegroupingError.requiresDisallowedPadding;
  }
  return result;
};
var encodeBech32 = (base32IntegerArray) => {
  let result = "";
  for (let i = 0; i < base32IntegerArray.length; i++) {
    result += bech32CharacterSet[base32IntegerArray[i]];
  }
  return result;
};
var decodeBech32 = (validBech32) => {
  const result = [];
  for (let i = 0; i < validBech32.length; i++) {
    result.push(bech32CharacterSetIndex[validBech32[i]]);
  }
  return result;
};
var nonBech32Characters = new RegExp(`[^${bech32CharacterSet}]`, "u");
var base32WordLength = 5;
var base256WordLength = 8;
var isBech32CharacterSet = (maybeBech32) => !nonBech32Characters.test(maybeBech32);
var Bech32DecodingError;
(function(Bech32DecodingError2) {
  Bech32DecodingError2["notBech32CharacterSet"] = "Bech32 decoding error: input contains characters outside of the Bech32 character set.";
})(Bech32DecodingError || (Bech32DecodingError = {}));
var bech32PaddedToBin = (bech32Padded) => {
  const result = isBech32CharacterSet(bech32Padded) ? regroupBits({
    allowPadding: false,
    bin: decodeBech32(bech32Padded),
    resultWordLength: base256WordLength,
    sourceWordLength: base32WordLength
  }) : Bech32DecodingError.notBech32CharacterSet;
  return typeof result === "string" ? result : Uint8Array.from(result);
};
var binToBech32Padded = (bytes) => encodeBech32(regroupBits({
  bin: bytes,
  resultWordLength: base32WordLength,
  sourceWordLength: base256WordLength
}));

// node_modules/@bitauth/libauth/build/lib/address/cash-address.js
var import_dist103 = __toESM(require_dist(), 1);
var import_dist104 = __toESM(require_dist2(), 1);
var import_dist105 = __toESM(require_dist3(), 1);
var CashAddressNetworkPrefix;
(function(CashAddressNetworkPrefix2) {
  CashAddressNetworkPrefix2["mainnet"] = "bitcoincash";
  CashAddressNetworkPrefix2["testnet"] = "bchtest";
  CashAddressNetworkPrefix2["regtest"] = "bchreg";
})(CashAddressNetworkPrefix || (CashAddressNetworkPrefix = {}));
var CashAddressVersionByte;
(function(CashAddressVersionByte2) {
  CashAddressVersionByte2[CashAddressVersionByte2["p2pkh"] = 0] = "p2pkh";
  CashAddressVersionByte2[CashAddressVersionByte2["p2sh20"] = 8] = "p2sh20";
  CashAddressVersionByte2[CashAddressVersionByte2["p2sh32"] = 11] = "p2sh32";
  CashAddressVersionByte2[CashAddressVersionByte2["p2pkhWithTokens"] = 16] = "p2pkhWithTokens";
  CashAddressVersionByte2[CashAddressVersionByte2["p2sh20WithTokens"] = 24] = "p2sh20WithTokens";
  CashAddressVersionByte2[CashAddressVersionByte2["p2sh32WithTokens"] = 27] = "p2sh32WithTokens";
})(CashAddressVersionByte || (CashAddressVersionByte = {}));
var CashAddressType;
(function(CashAddressType2) {
  CashAddressType2["p2pkh"] = "p2pkh";
  CashAddressType2["p2sh"] = "p2sh";
  CashAddressType2["p2pkhWithTokens"] = "p2pkhWithTokens";
  CashAddressType2["p2shWithTokens"] = "p2shWithTokens";
})(CashAddressType || (CashAddressType = {}));
var CashAddressTypeBits;
(function(CashAddressTypeBits2) {
  CashAddressTypeBits2[CashAddressTypeBits2["p2pkh"] = 0] = "p2pkh";
  CashAddressTypeBits2[CashAddressTypeBits2["p2sh"] = 1] = "p2sh";
  CashAddressTypeBits2[CashAddressTypeBits2["p2pkhWithTokens"] = 2] = "p2pkhWithTokens";
  CashAddressTypeBits2[CashAddressTypeBits2["p2shWithTokens"] = 3] = "p2shWithTokens";
})(CashAddressTypeBits || (CashAddressTypeBits = {}));
var cashAddressTypeToTypeBits = {
  [CashAddressType.p2pkh]: CashAddressTypeBits.p2pkh,
  [CashAddressType.p2sh]: CashAddressTypeBits.p2sh,
  [CashAddressType.p2pkhWithTokens]: CashAddressTypeBits.p2pkhWithTokens,
  [CashAddressType.p2shWithTokens]: CashAddressTypeBits.p2shWithTokens
};
var cashAddressTypeBitsToType = {
  [CashAddressTypeBits.p2pkh]: CashAddressType.p2pkh,
  [CashAddressTypeBits.p2sh]: CashAddressType.p2sh,
  [CashAddressTypeBits.p2pkhWithTokens]: CashAddressType.p2pkhWithTokens,
  [CashAddressTypeBits.p2shWithTokens]: CashAddressType.p2shWithTokens
};
var cashAddressSizeBitsToLength = {
  0: 20,
  1: 24,
  2: 28,
  3: 32,
  4: 40,
  5: 48,
  6: 56,
  7: 64
};
var cashAddressLengthToSizeBits = {
  20: 0,
  24: 1,
  28: 2,
  32: 3,
  40: 4,
  48: 5,
  56: 6,
  64: 7
};
var encodeCashAddressVersionByte = (typeBits, length) => (
  // eslint-disable-next-line no-bitwise
  typeBits << 3 | cashAddressLengthToSizeBits[length]
);
var CashAddressVersionByteDecodingError;
(function(CashAddressVersionByteDecodingError2) {
  CashAddressVersionByteDecodingError2["reservedBitSet"] = "Reserved bit is set.";
})(CashAddressVersionByteDecodingError || (CashAddressVersionByteDecodingError = {}));
var decodeCashAddressVersionByte = (version) => (
  // eslint-disable-next-line no-negated-condition, no-bitwise
  (version & 128) !== 0 ? CashAddressVersionByteDecodingError.reservedBitSet : {
    length: cashAddressSizeBitsToLength[
      // eslint-disable-next-line no-bitwise
      version & 7
    ],
    typeBits: (
      // eslint-disable-next-line no-bitwise
      version >>> 3 & 15
    )
  }
);
var maskCashAddressPrefix = (prefix) => {
  const result = [];
  for (let i = 0; i < prefix.length; i++) {
    result.push(
      prefix.charCodeAt(i) & 31
      /* Constants.asciiCaseInsensitiveBits */
    );
  }
  return result;
};
var bech32GeneratorMostSignificantByte = [152, 121, 243, 174, 30];
var bech32GeneratorRemainingBytes = [4072443489, 3077413346, 1046459332, 783016616, 1329849456];
var cashAddressPolynomialModulo = (v) => {
  let mostSignificantByte = 0;
  let lowerBytes = 1;
  let c = 0;
  for (let j = 0; j < v.length; j++) {
    c = mostSignificantByte >>> 3;
    mostSignificantByte &= 7;
    mostSignificantByte <<= 5;
    mostSignificantByte |= lowerBytes >>> 27;
    lowerBytes &= 134217727;
    lowerBytes <<= 5;
    lowerBytes ^= v[j];
    for (let i = 0; i < bech32GeneratorMostSignificantByte.length; ++i) {
      if (c & 1 << i) {
        mostSignificantByte ^= bech32GeneratorMostSignificantByte[i];
        lowerBytes ^= bech32GeneratorRemainingBytes[i];
      }
    }
  }
  lowerBytes ^= 1;
  if (lowerBytes < 0) {
    lowerBytes ^= 1 << 31;
    lowerBytes += (1 << 30) * 2;
  }
  return mostSignificantByte * (1 << 30) * 4 + lowerBytes;
};
var cashAddressChecksumToUint5Array = (checksum) => {
  const result = [];
  for (let i = 0; i < 8; ++i) {
    result.push(checksum & 31);
    checksum /= 32;
  }
  return result.reverse();
};
var encodeCashAddressFormat = (prefix, version, payload) => {
  const checksum40BitPlaceholder = [0, 0, 0, 0, 0, 0, 0, 0];
  const payloadContents = regroupBits({
    bin: Uint8Array.from([version, ...payload]),
    resultWordLength: 5,
    sourceWordLength: 8
  });
  const checksumContents = [
    ...maskCashAddressPrefix(prefix),
    0,
    ...payloadContents,
    ...checksum40BitPlaceholder
  ];
  const checksum = cashAddressPolynomialModulo(checksumContents);
  const encoded = [
    ...payloadContents,
    ...cashAddressChecksumToUint5Array(checksum)
  ];
  return `${prefix}:${encodeBech32(encoded)}`;
};
var CashAddressEncodingError;
(function(CashAddressEncodingError2) {
  CashAddressEncodingError2["unsupportedPayloadLength"] = "Error encoding CashAddress: a payload of this length can not be encoded as a valid CashAddress.";
  CashAddressEncodingError2["noTypeBitsValueStandardizedForP2pk"] = "Error encoding CashAddress: no CashAddress type bit has been standardized for P2PK locking bytecode.";
  CashAddressEncodingError2["unknownLockingBytecodeType"] = "Error encoding CashAddress: unknown locking bytecode type.";
})(CashAddressEncodingError || (CashAddressEncodingError = {}));
var isValidCashAddressPayloadLength = (length) => cashAddressLengthToSizeBits[length] !== void 0;
var encodeCashAddressNonStandard = (prefix, typeBits, payload) => {
  const { length } = payload;
  if (!isValidCashAddressPayloadLength(length)) {
    throw new Error(formatError(CashAddressEncodingError.unsupportedPayloadLength, `Payload length: ${length}.`));
  }
  return encodeCashAddressFormat(prefix, encodeCashAddressVersionByte(typeBits, length), payload);
};
var encodeCashAddress = (prefix, type, payload) => encodeCashAddressNonStandard(prefix, cashAddressTypeToTypeBits[type], payload);
var CashAddressDecodingError;
(function(CashAddressDecodingError2) {
  CashAddressDecodingError2["improperPadding"] = "Error decoding CashAddress: the payload is improperly padded.";
  CashAddressDecodingError2["invalidCharacters"] = "Error decoding CashAddress: the payload contains non-bech32 characters.";
  CashAddressDecodingError2["invalidChecksum"] = "Error decoding CashAddress: invalid checksum - please review the address for errors.";
  CashAddressDecodingError2["invalidFormat"] = 'Error decoding CashAddress: CashAddresses should be of the form "prefix:payload".';
  CashAddressDecodingError2["mismatchedPayloadLength"] = "Error decoding CashAddress: mismatched payload length for specified address version.";
  CashAddressDecodingError2["reservedByte"] = "Error decoding CashAddress: unknown CashAddress version, reserved byte set.";
  CashAddressDecodingError2["unknownAddressType"] = "Error decoding CashAddress: unknown CashAddress type.";
})(CashAddressDecodingError || (CashAddressDecodingError = {}));
var decodeCashAddressFormat = (address) => {
  const parts = address.toLowerCase().split(":");
  if (parts.length !== 2 || parts[0] === "" || parts[1] === "") {
    return CashAddressDecodingError.invalidFormat;
  }
  const [prefix, payload] = parts;
  if (!isBech32CharacterSet(payload)) {
    return CashAddressDecodingError.invalidCharacters;
  }
  const decodedPayload = decodeBech32(payload);
  const polynomial = [
    ...maskCashAddressPrefix(prefix),
    0,
    ...decodedPayload
  ];
  if (cashAddressPolynomialModulo(polynomial) !== 0) {
    return CashAddressDecodingError.invalidChecksum;
  }
  const checksum40BitPlaceholderLength = 8;
  const payloadContents = regroupBits({
    allowPadding: false,
    bin: decodedPayload.slice(0, -checksum40BitPlaceholderLength),
    resultWordLength: 8,
    sourceWordLength: 5
  });
  if (typeof payloadContents === "string") {
    return CashAddressDecodingError.improperPadding;
  }
  const [version, ...contents] = payloadContents;
  const result = Uint8Array.from(contents);
  return { payload: result, prefix, version };
};
var decodeCashAddressNonStandard = (address) => {
  const decoded = decodeCashAddressFormat(address);
  if (typeof decoded === "string") {
    return decoded;
  }
  const info = decodeCashAddressVersionByte(decoded.version);
  if (info === CashAddressVersionByteDecodingError.reservedBitSet) {
    return CashAddressDecodingError.reservedByte;
  }
  if (decoded.payload.length !== info.length) {
    return CashAddressDecodingError.mismatchedPayloadLength;
  }
  return {
    payload: decoded.payload,
    prefix: decoded.prefix,
    typeBits: info.typeBits
  };
};
var decodeCashAddress = (address) => {
  const decoded = decodeCashAddressNonStandard(address);
  if (typeof decoded === "string") {
    return decoded;
  }
  const type = cashAddressTypeBitsToType[decoded.typeBits];
  if (type === void 0) {
    return `${CashAddressDecodingError.unknownAddressType} Type bit value: ${decoded.typeBits}.`;
  }
  return {
    payload: decoded.payload,
    prefix: decoded.prefix,
    type
  };
};
var decodeCashAddressFormatWithoutPrefix = (address, possiblePrefixes = [
  CashAddressNetworkPrefix.mainnet,
  CashAddressNetworkPrefix.testnet,
  CashAddressNetworkPrefix.regtest
]) => {
  for (const prefix of possiblePrefixes) {
    const attempt = decodeCashAddressFormat(`${prefix}:${address}`);
    if (attempt !== CashAddressDecodingError.invalidChecksum) {
      return attempt;
    }
  }
  return CashAddressDecodingError.invalidChecksum;
};
var cashAddressPolynomialToCashAddress = (polynomial) => {
  const separatorPosition = polynomial.indexOf(0);
  const prefix = polynomial.slice(0, separatorPosition).map((integer) => String.fromCharCode(96 + integer)).join("");
  const contents = encodeBech32(polynomial.slice(separatorPosition + 1));
  return `${prefix}:${contents}`;
};
var CashAddressCorrectionError;
(function(CashAddressCorrectionError2) {
  CashAddressCorrectionError2["tooManyErrors"] = "This address has more than 2 errors and cannot be corrected.";
})(CashAddressCorrectionError || (CashAddressCorrectionError = {}));
var attemptCashAddressFormatErrorCorrection = (address) => {
  const parts = address.toLowerCase().split(":");
  if (parts.length !== 2 || parts[0] === "" || parts[1] === "") {
    return CashAddressDecodingError.invalidFormat;
  }
  const [prefix, payload] = parts;
  if (!isBech32CharacterSet(payload)) {
    return CashAddressDecodingError.invalidCharacters;
  }
  const decodedPayload = decodeBech32(payload);
  const polynomial = [...maskCashAddressPrefix(prefix), 0, ...decodedPayload];
  const originalChecksum = cashAddressPolynomialModulo(polynomial);
  if (originalChecksum === 0) {
    return {
      address: cashAddressPolynomialToCashAddress(polynomial),
      corrections: []
    };
  }
  const syndromes = {};
  for (let term = 0; term < polynomial.length; term++) {
    for (
      let errorVector = 1;
      errorVector < 32;
      // eslint-disable-next-line no-plusplus
      errorVector++
    ) {
      polynomial[term] ^= errorVector;
      const correct = cashAddressPolynomialModulo(polynomial);
      if (correct === 0) {
        return {
          address: cashAddressPolynomialToCashAddress(polynomial),
          corrections: [term]
        };
      }
      const s0 = (BigInt(correct) ^ BigInt(originalChecksum)).toString();
      syndromes[s0] = term * 32 + errorVector;
      polynomial[term] ^= errorVector;
    }
  }
  for (const [s0, pe] of Object.entries(syndromes)) {
    const s1Location = (BigInt(s0) ^ BigInt(originalChecksum)).toString();
    const s1 = syndromes[s1Location];
    if (s1 !== void 0) {
      const correctionIndex1 = Math.trunc(
        pe / 32
        /* Constants.finiteFieldOrder */
      );
      const correctionIndex2 = Math.trunc(
        s1 / 32
        /* Constants.finiteFieldOrder */
      );
      polynomial[correctionIndex1] ^= pe % 32;
      polynomial[correctionIndex2] ^= s1 % 32;
      return {
        address: cashAddressPolynomialToCashAddress(polynomial),
        corrections: [correctionIndex1, correctionIndex2].sort((a, b) => a - b)
      };
    }
  }
  return CashAddressCorrectionError.tooManyErrors;
};

// node_modules/@bitauth/libauth/build/lib/address/locking-bytecode.js
var import_dist106 = __toESM(require_dist(), 1);
var import_dist107 = __toESM(require_dist2(), 1);
var import_dist108 = __toESM(require_dist3(), 1);
var LockingBytecodeType;
(function(LockingBytecodeType2) {
  LockingBytecodeType2["p2pk"] = "P2PK";
  LockingBytecodeType2["p2pkh"] = "P2PKH";
  LockingBytecodeType2["p2sh20"] = "P2SH20";
  LockingBytecodeType2["p2sh32"] = "P2SH32";
})(LockingBytecodeType || (LockingBytecodeType = {}));
var isPayToPublicKeyUncompressed = (lockingBytecode) => lockingBytecode.length === 67 && lockingBytecode[0] === 65 && lockingBytecode[
  66
  /* PayToPublicKeyUncompressed.lastElement */
] === 172;
var isPayToPublicKeyCompressed = (lockingBytecode) => lockingBytecode.length === 35 && lockingBytecode[0] === 33 && lockingBytecode[
  34
  /* PayToPublicKeyCompressed.lastElement */
] === 172;
var isPayToPublicKey = (lockingBytecode) => isPayToPublicKeyCompressed(lockingBytecode) || isPayToPublicKeyUncompressed(lockingBytecode);
var isPayToPublicKeyHash = (lockingBytecode) => lockingBytecode.length === 25 && lockingBytecode[0] === 118 && lockingBytecode[1] === 169 && lockingBytecode[2] === 20 && lockingBytecode[23] === 136 && lockingBytecode[24] === 172;
var isPayToScriptHash20 = (lockingBytecode) => lockingBytecode.length === 23 && lockingBytecode[0] === 169 && lockingBytecode[1] === 20 && lockingBytecode[
  22
  /* PayToScriptHash20.lastElement */
] === 135;
var isPayToScriptHash32 = (lockingBytecode) => lockingBytecode.length === 35 && lockingBytecode[0] === 170 && lockingBytecode[1] === 32 && lockingBytecode[
  34
  /* PayToScriptHash32.lastElement */
] === 135;
var lockingBytecodeToAddressContents = (bytecode) => {
  if (isPayToPublicKeyHash(bytecode)) {
    return {
      payload: bytecode.slice(
        3,
        23
        /* AddressPayload.p2pkhEnd */
      ),
      type: LockingBytecodeType.p2pkh
    };
  }
  if (isPayToScriptHash20(bytecode)) {
    return {
      payload: bytecode.slice(
        2,
        22
        /* AddressPayload.p2sh20End */
      ),
      type: LockingBytecodeType.p2sh20
    };
  }
  if (isPayToScriptHash32(bytecode)) {
    return {
      payload: bytecode.slice(
        2,
        34
        /* AddressPayload.p2sh32End */
      ),
      type: LockingBytecodeType.p2sh32
    };
  }
  if (isPayToPublicKeyUncompressed(bytecode)) {
    return {
      payload: bytecode.slice(
        1,
        66
        /* AddressPayload.p2pkUncompressedEnd */
      ),
      type: LockingBytecodeType.p2pk
    };
  }
  if (isPayToPublicKeyCompressed(bytecode)) {
    return {
      payload: bytecode.slice(
        1,
        34
        /* AddressPayload.p2pkCompressedEnd */
      ),
      type: LockingBytecodeType.p2pk
    };
  }
  return { payload: bytecode.slice(), type: "unknown" };
};
var encodeLockingBytecodeP2pkh = (publicKeyHash) => Uint8Array.from([
  118,
  169,
  20,
  ...publicKeyHash,
  136,
  172
]);
var encodeLockingBytecodeP2sh20 = (p2sh20Hash) => Uint8Array.from([
  169,
  20,
  ...p2sh20Hash,
  135
]);
var encodeLockingBytecodeP2sh32 = (p2sh32Hash) => Uint8Array.from([
  170,
  32,
  ...p2sh32Hash,
  135
]);
var encodeLockingBytecodeP2pk = (publicKey) => publicKey.length === 33 ? Uint8Array.from([
  33,
  ...publicKey,
  172
]) : Uint8Array.from([
  65,
  ...publicKey,
  172
]);
var addressContentsToLockingBytecode = ({ payload, type }) => {
  if (type === LockingBytecodeType.p2pkh) {
    return encodeLockingBytecodeP2pkh(payload);
  }
  if (type === LockingBytecodeType.p2sh20) {
    return encodeLockingBytecodeP2sh20(payload);
  }
  if (type === LockingBytecodeType.p2sh32) {
    return encodeLockingBytecodeP2sh32(payload);
  }
  if (type === LockingBytecodeType.p2pk) {
    return encodeLockingBytecodeP2pk(payload);
  }
  return unknownValue(type, `Unrecognized addressContents type: ${type}`);
};
var lockingBytecodeToCashAddress = (bytecode, prefix = "bitcoincash", options = { tokenSupport: false }) => {
  const contents = lockingBytecodeToAddressContents(bytecode);
  if (contents.type === LockingBytecodeType.p2pkh) {
    return options.tokenSupport ? encodeCashAddress(prefix, CashAddressType.p2pkhWithTokens, contents.payload) : encodeCashAddress(prefix, CashAddressType.p2pkh, contents.payload);
  }
  if (contents.type === LockingBytecodeType.p2sh20 || contents.type === LockingBytecodeType.p2sh32) {
    return options.tokenSupport ? encodeCashAddress(prefix, CashAddressType.p2shWithTokens, contents.payload) : encodeCashAddress(prefix, CashAddressType.p2sh, contents.payload);
  }
  if (contents.type === "P2PK") {
    return {
      error: CashAddressEncodingError.noTypeBitsValueStandardizedForP2pk
    };
  }
  if (contents.type === "unknown") {
    return { error: CashAddressEncodingError.unknownLockingBytecodeType };
  }
  return unknownValue(contents.type, `Unrecognized locking bytecode type: ${contents.type}`);
};
var LockingBytecodeGenerationError;
(function(LockingBytecodeGenerationError2) {
  LockingBytecodeGenerationError2["unsupportedPayloadLength"] = "Error generating locking bytecode: no standard locking bytecode patterns support a payload of this length.";
})(LockingBytecodeGenerationError || (LockingBytecodeGenerationError = {}));
var cashAddressToLockingBytecode = (address) => {
  const decoded = decodeCashAddress(address);
  if (typeof decoded === "string")
    return decoded;
  if (decoded.payload.length !== 20 && decoded.payload.length !== 32) {
    return formatError(LockingBytecodeGenerationError.unsupportedPayloadLength, `Payload length: ${decoded.payload.length}`);
  }
  if (decoded.type === CashAddressType.p2pkh || decoded.type === CashAddressType.p2pkhWithTokens) {
    return {
      bytecode: addressContentsToLockingBytecode({
        payload: decoded.payload,
        type: LockingBytecodeType.p2pkh
      }),
      options: {
        tokenSupport: decoded.type === CashAddressType.p2pkhWithTokens
      },
      prefix: decoded.prefix
    };
  }
  if (decoded.type === CashAddressType.p2sh || // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  decoded.type === CashAddressType.p2shWithTokens) {
    return {
      bytecode: addressContentsToLockingBytecode({
        payload: decoded.payload,
        type: decoded.payload.length === 32 ? LockingBytecodeType.p2sh32 : LockingBytecodeType.p2sh20
      }),
      options: {
        tokenSupport: decoded.type === CashAddressType.p2shWithTokens
      },
      prefix: decoded.prefix
    };
  }
  return unknownValue(decoded.type, `Unrecognized address type: ${decoded.type}`);
};
var lockingBytecodeToBase58Address = (bytecode, network = "mainnet", sha2562 = sha256) => {
  const contents = lockingBytecodeToAddressContents(bytecode);
  if (contents.type === LockingBytecodeType.p2pkh) {
    return encodeBase58AddressFormat({
      copayBCH: Base58AddressFormatVersion.p2pkhCopayBCH,
      mainnet: Base58AddressFormatVersion.p2pkh,
      testnet: Base58AddressFormatVersion.p2pkhTestnet
    }[network], contents.payload, sha2562);
  }
  if (contents.type === LockingBytecodeType.p2sh20) {
    return encodeBase58AddressFormat({
      copayBCH: Base58AddressFormatVersion.p2sh20CopayBCH,
      mainnet: Base58AddressFormatVersion.p2sh20,
      testnet: Base58AddressFormatVersion.p2sh20Testnet
    }[network], contents.payload, sha2562);
  }
  return contents;
};
var base58AddressToLockingBytecode = (address, sha2562 = sha256) => {
  const decoded = decodeBase58Address(address, sha2562);
  if (typeof decoded === "string")
    return decoded;
  return {
    bytecode: addressContentsToLockingBytecode({
      payload: decoded.payload,
      type: [
        Base58AddressFormatVersion.p2pkh,
        Base58AddressFormatVersion.p2pkhCopayBCH,
        Base58AddressFormatVersion.p2pkhTestnet
      ].includes(decoded.version) ? LockingBytecodeType.p2pkh : LockingBytecodeType.p2sh20
    }),
    version: decoded.version
  };
};

// node_modules/@bitauth/libauth/build/lib/key/key.js
var import_dist121 = __toESM(require_dist(), 1);
var import_dist122 = __toESM(require_dist2(), 1);
var import_dist123 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/key/hd-key.js
var import_dist115 = __toESM(require_dist(), 1);
var import_dist116 = __toESM(require_dist2(), 1);
var import_dist117 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/key/key-utils.js
var import_dist112 = __toESM(require_dist(), 1);
var import_dist113 = __toESM(require_dist2(), 1);
var import_dist114 = __toESM(require_dist3(), 1);
var validateSecp256k1PrivateKey = (privateKey) => {
  const privateKeyLength = 32;
  if (privateKey.length !== privateKeyLength || privateKey.every((value) => value === 0)) {
    return false;
  }
  const maximumSecp256k1PrivateKey = [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254, 186, 174, 220, 230, 175, 72, 160, 59, 191, 210, 94, 140, 208, 54, 65, 63];
  const firstDifference = privateKey.findIndex((value, i) => value !== maximumSecp256k1PrivateKey[i]);
  if (firstDifference === -1 || // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  privateKey[firstDifference] < maximumSecp256k1PrivateKey[firstDifference]) {
    return true;
  }
  return false;
};
var generatePrivateKey = (secureRandom) => {
  let maybeKey;
  do {
    maybeKey = secureRandom();
  } while (!validateSecp256k1PrivateKey(maybeKey));
  return maybeKey;
};

// node_modules/@bitauth/libauth/build/lib/key/hd-key.js
var bip32HmacSha512Key = Uint8Array.from([
  // eslint-disable-next-line @typescript-eslint/no-magic-numbers
  66,
  105,
  116,
  99,
  111,
  105,
  110,
  32,
  115,
  101,
  101,
  100
]);
var halfHmacSha512Length = 32;
var deriveHdPrivateNodeFromSeed = (seed, assumeValidity, crypto = { sha512 }) => {
  const mac = hmacSha512(bip32HmacSha512Key, seed, crypto.sha512);
  const privateKey = mac.slice(0, halfHmacSha512Length);
  const chainCode = mac.slice(halfHmacSha512Length);
  const depth = 0;
  const childIndex = 0;
  const parentFingerprint = Uint8Array.from([0, 0, 0, 0]);
  const valid = assumeValidity ?? validateSecp256k1PrivateKey(privateKey);
  return valid ? { chainCode, childIndex, depth, parentFingerprint, privateKey, valid } : {
    chainCode,
    childIndex,
    depth,
    invalidPrivateKey: privateKey,
    parentFingerprint,
    valid
  };
};
var deriveHdPrivateNodeIdentifier = (hdPrivateNode, crypto = {
  ripemd160,
  secp256k1,
  sha256
}) => {
  const publicKey = crypto.secp256k1.derivePublicKeyCompressed(hdPrivateNode.privateKey);
  if (typeof publicKey === "string")
    return publicKey;
  return crypto.ripemd160.hash(crypto.sha256.hash(publicKey));
};
var deriveHdPublicNodeIdentifier = (node, crypto = { ripemd160, sha256 }) => crypto.ripemd160.hash(crypto.sha256.hash(node.publicKey));
var HdKeyVersion;
(function(HdKeyVersion2) {
  HdKeyVersion2[HdKeyVersion2["mainnetPrivateKey"] = 76066276] = "mainnetPrivateKey";
  HdKeyVersion2[HdKeyVersion2["mainnetPublicKey"] = 76067358] = "mainnetPublicKey";
  HdKeyVersion2[HdKeyVersion2["testnetPrivateKey"] = 70615956] = "testnetPrivateKey";
  HdKeyVersion2[HdKeyVersion2["testnetPublicKey"] = 70617039] = "testnetPublicKey";
})(HdKeyVersion || (HdKeyVersion = {}));
var HdKeyDecodingError;
(function(HdKeyDecodingError2) {
  HdKeyDecodingError2["incorrectLength"] = "HD key decoding error: length is incorrect (must encode 82 bytes).";
  HdKeyDecodingError2["invalidChecksum"] = "HD key decoding error: checksum is invalid.";
  HdKeyDecodingError2["invalidPrivateNode"] = "HD key decoding error: the key for this HD private node is not a valid Secp256k1 private key.";
  HdKeyDecodingError2["missingPrivateKeyPaddingByte"] = "HD key decoding error: version indicates a private key, but the key data is missing a padding byte.";
  HdKeyDecodingError2["privateKeyExpected"] = "HD key decoding error: expected an HD private key, but encountered an HD public key.";
  HdKeyDecodingError2["publicKeyExpected"] = "HD key decoding error: expected an HD public key, but encountered an HD private key.";
  HdKeyDecodingError2["unknownCharacter"] = "HD key decoding error: key includes a non-base58 character.";
  HdKeyDecodingError2["unknownVersion"] = "HD key decoding error: key uses an unknown version.";
})(HdKeyDecodingError || (HdKeyDecodingError = {}));
var decodeHdKey = (hdKey, crypto = { sha256 }) => {
  const decoded = base58ToBin(hdKey);
  if (decoded === BaseConversionError.unknownCharacter)
    return HdKeyDecodingError.unknownCharacter;
  const expectedLength = 82;
  if (decoded.length !== expectedLength)
    return HdKeyDecodingError.incorrectLength;
  const checksumIndex = 78;
  const payload = decoded.slice(0, checksumIndex);
  const checksumBits = decoded.slice(checksumIndex);
  const checksum = crypto.sha256.hash(crypto.sha256.hash(payload));
  if (!checksumBits.every((value, i) => value === checksum[i])) {
    return HdKeyDecodingError.invalidChecksum;
  }
  const depthIndex = 4;
  const fingerprintIndex = 5;
  const childIndexIndex = 9;
  const chainCodeIndex = 13;
  const keyDataIndex = 45;
  const version = new DataView(decoded.buffer, decoded.byteOffset, depthIndex).getUint32(0);
  const depth = decoded[depthIndex];
  const parentFingerprint = decoded.slice(fingerprintIndex, childIndexIndex);
  const childIndex = new DataView(decoded.buffer, decoded.byteOffset + childIndexIndex, decoded.byteOffset + chainCodeIndex).getUint32(0);
  const chainCode = decoded.slice(chainCodeIndex, keyDataIndex);
  const keyData = decoded.slice(keyDataIndex, checksumIndex);
  const isPrivateKey = version === HdKeyVersion.mainnetPrivateKey || version === HdKeyVersion.testnetPrivateKey;
  if (isPrivateKey && keyData[0] !== 0) {
    return HdKeyDecodingError.missingPrivateKeyPaddingByte;
  }
  if (isPrivateKey) {
    const privateKey = keyData.slice(1);
    const valid = validateSecp256k1PrivateKey(privateKey);
    return {
      node: valid ? {
        chainCode,
        childIndex,
        depth,
        parentFingerprint,
        privateKey,
        valid: true
      } : {
        chainCode,
        childIndex,
        depth,
        invalidPrivateKey: privateKey,
        parentFingerprint,
        valid: false
      },
      version
    };
  }
  const isPublicKey = version === HdKeyVersion.mainnetPublicKey || version === HdKeyVersion.testnetPublicKey;
  if (!isPublicKey) {
    return HdKeyDecodingError.unknownVersion;
  }
  return {
    node: {
      chainCode,
      childIndex,
      depth,
      parentFingerprint,
      publicKey: keyData
    },
    version
  };
};
var decodeHdPrivateKey = (hdPrivateKey, crypto = { sha256 }) => {
  const decoded = decodeHdKey(hdPrivateKey, crypto);
  if (typeof decoded === "string")
    return decoded;
  if ("publicKey" in decoded.node) {
    return HdKeyDecodingError.privateKeyExpected;
  }
  if (!decoded.node.valid) {
    return HdKeyDecodingError.invalidPrivateNode;
  }
  if (decoded.version === HdKeyVersion.mainnetPrivateKey) {
    return {
      network: "mainnet",
      node: decoded.node
    };
  }
  return {
    network: "testnet",
    node: decoded.node
  };
};
var decodeHdPublicKey = (hdPublicKey, crypto = { sha256 }) => {
  const decoded = decodeHdKey(hdPublicKey, crypto);
  if (typeof decoded === "string")
    return decoded;
  if (decoded.version === HdKeyVersion.mainnetPublicKey) {
    return {
      network: "mainnet",
      node: decoded.node
    };
  }
  if (decoded.version === HdKeyVersion.testnetPublicKey) {
    return {
      network: "testnet",
      node: decoded.node
    };
  }
  return HdKeyDecodingError.publicKeyExpected;
};
var hdPrivateKeyToIdentifier = (hdPrivateKey, crypto = { sha256 }) => {
  const privateKeyParams = decodeHdPrivateKey(hdPrivateKey, crypto);
  if (typeof privateKeyParams === "string") {
    return privateKeyParams;
  }
  return deriveHdPrivateNodeIdentifier(privateKeyParams.node);
};
var hdPublicKeyToIdentifier = (hdPublicKey, crypto = { sha256 }) => {
  const publicKeyParams = decodeHdPublicKey(hdPublicKey, crypto);
  if (typeof publicKeyParams === "string") {
    return publicKeyParams;
  }
  return deriveHdPublicNodeIdentifier(publicKeyParams.node);
};
var encodeHdPrivateKey = (keyParameters, crypto = { sha256 }) => {
  const version = numberToBinUint32BE(keyParameters.network === "mainnet" ? HdKeyVersion.mainnetPrivateKey : HdKeyVersion.testnetPrivateKey);
  const depth = Uint8Array.of(keyParameters.node.depth);
  const childIndex = numberToBinUint32BE(keyParameters.node.childIndex);
  const isPrivateKey = Uint8Array.of(0);
  const payload = flattenBinArray([
    version,
    depth,
    keyParameters.node.parentFingerprint,
    childIndex,
    keyParameters.node.chainCode,
    isPrivateKey,
    keyParameters.node.privateKey
  ]);
  const checksumLength = 4;
  const checksum = crypto.sha256.hash(crypto.sha256.hash(payload)).slice(0, checksumLength);
  return binToBase58(flattenBinArray([payload, checksum]));
};
var encodeHdPublicKey = (keyParameters, crypto = { sha256 }) => {
  const version = numberToBinUint32BE(keyParameters.network === "mainnet" ? HdKeyVersion.mainnetPublicKey : HdKeyVersion.testnetPublicKey);
  const depth = Uint8Array.of(keyParameters.node.depth);
  const childIndex = numberToBinUint32BE(keyParameters.node.childIndex);
  const payload = flattenBinArray([
    version,
    depth,
    keyParameters.node.parentFingerprint,
    childIndex,
    keyParameters.node.chainCode,
    keyParameters.node.publicKey
  ]);
  const checksumLength = 4;
  const checksum = crypto.sha256.hash(crypto.sha256.hash(payload)).slice(0, checksumLength);
  return binToBase58(flattenBinArray([payload, checksum]));
};
var deriveHdPublicNode = (node, crypto = { secp256k1 }) => ({
  chainCode: node.chainCode,
  childIndex: node.childIndex,
  depth: node.depth,
  parentFingerprint: node.parentFingerprint,
  ...node.parentIdentifier === void 0 ? {} : { parentIdentifier: node.parentIdentifier },
  publicKey: crypto.secp256k1.derivePublicKeyCompressed(node.privateKey)
});
var HdNodeDerivationError;
(function(HdNodeDerivationError2) {
  HdNodeDerivationError2["childIndexExceedsMaximum"] = "HD key derivation error: child index exceeds maximum (4294967295).";
  HdNodeDerivationError2["nextChildIndexRequiresHardenedAlgorithm"] = "HD key derivation error: an incredibly rare HMAC-SHA512 result occurred, and incrementing the child index would require switching to the hardened algorithm.";
  HdNodeDerivationError2["hardenedDerivationRequiresPrivateNode"] = "HD key derivation error: derivation for hardened child indexes (indexes greater than or equal to 2147483648) requires an HD private node.";
  HdNodeDerivationError2["invalidDerivationPath"] = `HD key derivation error: invalid derivation path - paths must begin with "m" or "M" and contain only forward slashes ("/"), apostrophes ("'"), or positive child index numbers.`;
  HdNodeDerivationError2["invalidPrivateDerivationPrefix"] = 'HD key derivation error: private derivation paths must begin with "m".';
  HdNodeDerivationError2["invalidPublicDerivationPrefix"] = 'HD key derivation error: public derivation paths must begin with "M".';
})(HdNodeDerivationError || (HdNodeDerivationError = {}));
var deriveHdPrivateNodeChild = (node, index2, crypto = {
  ripemd160,
  secp256k1,
  sha256,
  sha512
}) => {
  const maximumIndex = 4294967295;
  if (index2 > maximumIndex) {
    return HdNodeDerivationError.childIndexExceedsMaximum;
  }
  const hardenedIndexOffset = 2147483648;
  const useHardenedAlgorithm = index2 >= hardenedIndexOffset;
  const keyMaterial = useHardenedAlgorithm ? node.privateKey : crypto.secp256k1.derivePublicKeyCompressed(node.privateKey);
  const serialization = Uint8Array.from([
    ...useHardenedAlgorithm ? [0] : [],
    ...keyMaterial,
    ...numberToBinUint32BE(index2)
  ]);
  const derivation = hmacSha512(node.chainCode, serialization, crypto.sha512);
  const tweakValueLength = 32;
  const tweakValue = derivation.slice(0, tweakValueLength);
  const nextChainCode = derivation.slice(tweakValueLength);
  const nextPrivateKey = crypto.secp256k1.addTweakPrivateKey(node.privateKey, tweakValue);
  if (typeof nextPrivateKey === "string") {
    if (index2 === hardenedIndexOffset - 1) {
      return HdNodeDerivationError.nextChildIndexRequiresHardenedAlgorithm;
    }
    return deriveHdPrivateNodeChild(node, index2 + 1, crypto);
  }
  const parentIdentifier = deriveHdPrivateNodeIdentifier(node, crypto);
  const parentFingerprintLength = 4;
  return {
    chainCode: nextChainCode,
    childIndex: index2,
    depth: node.depth + 1,
    parentFingerprint: parentIdentifier.slice(0, parentFingerprintLength),
    parentIdentifier,
    privateKey: nextPrivateKey,
    valid: true
  };
};
var deriveHdPublicNodeChild = (node, index2, crypto = {
  ripemd160,
  secp256k1,
  sha256,
  sha512
}) => {
  const hardenedIndexOffset = 2147483648;
  if (index2 >= hardenedIndexOffset) {
    return HdNodeDerivationError.hardenedDerivationRequiresPrivateNode;
  }
  const serialization = Uint8Array.from([
    ...node.publicKey,
    ...numberToBinUint32BE(index2)
  ]);
  const derivation = hmacSha512(node.chainCode, serialization, crypto.sha512);
  const tweakValueLength = 32;
  const tweakValue = derivation.slice(0, tweakValueLength);
  const nextChainCode = derivation.slice(tweakValueLength);
  const nextPublicKey = crypto.secp256k1.addTweakPublicKeyCompressed(node.publicKey, tweakValue);
  if (typeof nextPublicKey === "string") {
    if (index2 === hardenedIndexOffset - 1) {
      return HdNodeDerivationError.nextChildIndexRequiresHardenedAlgorithm;
    }
    return deriveHdPublicNodeChild(node, index2 + 1, crypto);
  }
  const parentIdentifier = deriveHdPublicNodeIdentifier(node, crypto);
  const parentFingerprintLength = 4;
  return {
    chainCode: nextChainCode,
    childIndex: index2,
    depth: node.depth + 1,
    parentFingerprint: parentIdentifier.slice(0, parentFingerprintLength),
    parentIdentifier,
    publicKey: nextPublicKey
  };
};
var deriveHdPath = (node, path, crypto = {
  ripemd160,
  secp256k1,
  sha256,
  sha512
}) => {
  const validDerivationPath = /^[mM](?:\/[0-9]+'?)*$/u;
  if (!validDerivationPath.test(path)) {
    return HdNodeDerivationError.invalidDerivationPath;
  }
  const parsed = path.split("/");
  const isPrivateDerivation = "privateKey" in node;
  if (isPrivateDerivation && parsed[0] !== "m") {
    return HdNodeDerivationError.invalidPrivateDerivationPrefix;
  }
  if (!isPrivateDerivation && parsed[0] !== "M") {
    return HdNodeDerivationError.invalidPublicDerivationPrefix;
  }
  const base = 10;
  const hardenedIndexOffset = 2147483648;
  const indexes = parsed.slice(1).map((index2) => index2.endsWith("'") ? parseInt(index2.slice(0, -1), base) + hardenedIndexOffset : parseInt(index2, base));
  return isPrivateDerivation ? indexes.reduce(
    (result, nextIndex) => typeof result === "string" ? result : deriveHdPrivateNodeChild(result, nextIndex, crypto),
    node
    // eslint-disable-line @typescript-eslint/prefer-reduce-type-parameter
  ) : indexes.reduce(
    (result, nextIndex) => typeof result === "string" ? result : deriveHdPublicNodeChild(result, nextIndex, crypto),
    node
    // eslint-disable-line @typescript-eslint/prefer-reduce-type-parameter
  );
};
var HdNodeCrackingError;
(function(HdNodeCrackingError2) {
  HdNodeCrackingError2["cannotCrackHardenedDerivation"] = "HD node cracking error: cannot crack an HD parent node using hardened child node.";
})(HdNodeCrackingError || (HdNodeCrackingError = {}));
var crackHdPrivateNodeFromHdPublicNodeAndChildPrivateNode = (parentPublicNode, childPrivateNode, crypto = { sha512 }) => {
  const hardenedIndexOffset = 2147483648;
  if (childPrivateNode.childIndex >= hardenedIndexOffset) {
    return HdNodeCrackingError.cannotCrackHardenedDerivation;
  }
  const serialization = Uint8Array.from([
    ...parentPublicNode.publicKey,
    ...numberToBinUint32BE(childPrivateNode.childIndex)
  ]);
  const derivation = hmacSha512(parentPublicNode.chainCode, serialization, crypto.sha512);
  const tweakValueLength = 32;
  const tweakValue = binToBigIntUint256BE(derivation.slice(0, tweakValueLength));
  const childPrivateValue = binToBigIntUint256BE(childPrivateNode.privateKey);
  const secp256k1OrderN = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n;
  const trueMod = (n, m) => (n % m + m) % m;
  const parentPrivateValue = trueMod(childPrivateValue - tweakValue, secp256k1OrderN);
  const privateKey = bigIntToBinUint256BEClamped(parentPrivateValue);
  return {
    chainCode: parentPublicNode.chainCode,
    childIndex: parentPublicNode.childIndex,
    depth: parentPublicNode.depth,
    parentFingerprint: parentPublicNode.parentFingerprint,
    ...parentPublicNode.parentIdentifier === void 0 ? {} : { parentIdentifier: parentPublicNode.parentIdentifier },
    privateKey,
    valid: true
  };
};

// node_modules/@bitauth/libauth/build/lib/key/wallet-import-format.js
var import_dist118 = __toESM(require_dist(), 1);
var import_dist119 = __toESM(require_dist2(), 1);
var import_dist120 = __toESM(require_dist3(), 1);
var WalletImportFormatError;
(function(WalletImportFormatError2) {
  WalletImportFormatError2["incorrectLength"] = "The WIF private key payload is not the correct length.";
})(WalletImportFormatError || (WalletImportFormatError = {}));
var encodePrivateKeyWif = (privateKey, type, sha2562 = sha256) => {
  const compressedByte = 1;
  const mainnet = type === "mainnet" || type === "mainnetUncompressed";
  const compressed = type === "mainnet" || type === "testnet";
  const payload = compressed ? Uint8Array.from([...privateKey, compressedByte]) : privateKey;
  return encodeBase58AddressFormat(mainnet ? Base58AddressFormatVersion.wif : Base58AddressFormatVersion.wifTestnet, payload, sha2562);
};
var decodePrivateKeyWif = (wifKey, sha2562 = sha256) => {
  const compressedPayloadLength = 33;
  const decoded = decodeBase58AddressFormat(wifKey, sha2562);
  if (typeof decoded === "string")
    return decoded;
  const mainnet = decoded.version === Base58AddressFormatVersion.wif;
  const compressed = decoded.payload.length === compressedPayloadLength;
  const privateKey = compressed ? decoded.payload.slice(0, -1) : decoded.payload;
  const type = mainnet ? compressed ? "mainnet" : "mainnetUncompressed" : compressed ? "testnet" : "testnetUncompressed";
  return { privateKey, type };
};

// node_modules/@bitauth/libauth/build/lib/language/language.js
var import_dist337 = __toESM(require_dist(), 1);
var import_dist338 = __toESM(require_dist2(), 1);
var import_dist339 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/language/compile.js
var import_dist334 = __toESM(require_dist(), 1);
var import_dist335 = __toESM(require_dist2(), 1);
var import_dist336 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/language/resolve.js
var import_dist331 = __toESM(require_dist(), 1);
var import_dist332 = __toESM(require_dist2(), 1);
var import_dist333 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/vm/vm.js
var import_dist313 = __toESM(require_dist(), 1);
var import_dist314 = __toESM(require_dist2(), 1);
var import_dist315 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/instruction-sets.js
var import_dist307 = __toESM(require_dist(), 1);
var import_dist308 = __toESM(require_dist2(), 1);
var import_dist309 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/xec/xec.js
var import_dist253 = __toESM(require_dist(), 1);
var import_dist254 = __toESM(require_dist2(), 1);
var import_dist255 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/xec/xec-descriptions.js
var import_dist124 = __toESM(require_dist(), 1);
var import_dist125 = __toESM(require_dist2(), 1);
var import_dist126 = __toESM(require_dist3(), 1);
var OpcodeDescriptionsXEC;
(function(OpcodeDescriptionsXEC2) {
  OpcodeDescriptionsXEC2["OP_0"] = "Push the VM Number 0 onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_1"] = "Push the next byte onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_2"] = "Push the next 2 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_3"] = "Push the next 3 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_4"] = "Push the next 4 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_5"] = "Push the next 5 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_6"] = "Push the next 6 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_7"] = "Push the next 7 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_8"] = "Push the next 8 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_9"] = "Push the next 9 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_10"] = "Push the next 10 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_11"] = "Push the next 11 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_12"] = "Push the next 12 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_13"] = "Push the next 13 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_14"] = "Push the next 14 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_15"] = "Push the next 15 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_16"] = "Push the next 16 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_17"] = "Push the next 17 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_18"] = "Push the next 18 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_19"] = "Push the next 19 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_20"] = "Push the next 20 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_21"] = "Push the next 21 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_22"] = "Push the next 22 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_23"] = "Push the next 23 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_24"] = "Push the next 24 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_25"] = "Push the next 25 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_26"] = "Push the next 26 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_27"] = "Push the next 27 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_28"] = "Push the next 28 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_29"] = "Push the next 29 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_30"] = "Push the next 30 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_31"] = "Push the next 31 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_32"] = "Push the next 32 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_33"] = "Push the next 33 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_34"] = "Push the next 34 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_35"] = "Push the next 35 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_36"] = "Push the next 36 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_37"] = "Push the next 37 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_38"] = "Push the next 38 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_39"] = "Push the next 39 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_40"] = "Push the next 40 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_41"] = "Push the next 41 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_42"] = "Push the next 42 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_43"] = "Push the next 43 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_44"] = "Push the next 44 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_45"] = "Push the next 45 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_46"] = "Push the next 46 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_47"] = "Push the next 47 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_48"] = "Push the next 48 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_49"] = "Push the next 49 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_50"] = "Push the next 50 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_51"] = "Push the next 51 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_52"] = "Push the next 52 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_53"] = "Push the next 53 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_54"] = "Push the next 54 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_55"] = "Push the next 55 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_56"] = "Push the next 56 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_57"] = "Push the next 57 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_58"] = "Push the next 58 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_59"] = "Push the next 59 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_60"] = "Push the next 60 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_61"] = "Push the next 61 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_62"] = "Push the next 62 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_63"] = "Push the next 63 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_64"] = "Push the next 64 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_65"] = "Push the next 65 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_66"] = "Push the next 66 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_67"] = "Push the next 67 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_68"] = "Push the next 68 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_69"] = "Push the next 69 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_70"] = "Push the next 70 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_71"] = "Push the next 71 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_72"] = "Push the next 72 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_73"] = "Push the next 73 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_74"] = "Push the next 74 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHBYTES_75"] = "Push the next 75 bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHDATA_1"] = "Read the next Uint8 and push that number of bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHDATA_2"] = "Read the next little-endian Uint16 and push that number of bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_PUSHDATA_4"] = "Read the next little-endian Uint32 and push that number of bytes onto the stack.";
  OpcodeDescriptionsXEC2["OP_1NEGATE"] = "Push the VM Number -1 onto the stack.";
  OpcodeDescriptionsXEC2["OP_RESERVED"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED does not count toward the opcode limit.";
  OpcodeDescriptionsXEC2["OP_1"] = "Push a 1 (VM Number) onto the stack.";
  OpcodeDescriptionsXEC2["OP_2"] = "Push a 2 (VM Number) onto the stack.";
  OpcodeDescriptionsXEC2["OP_3"] = "Push a 3 (VM Number) onto the stack.";
  OpcodeDescriptionsXEC2["OP_4"] = "Push a 4 (VM Number) onto the stack.";
  OpcodeDescriptionsXEC2["OP_5"] = "Push a 5 (VM Number) onto the stack.";
  OpcodeDescriptionsXEC2["OP_6"] = "Push a 6 (VM Number) onto the stack.";
  OpcodeDescriptionsXEC2["OP_7"] = "Push a 7 (VM Number) onto the stack.";
  OpcodeDescriptionsXEC2["OP_8"] = "Push a 8 (VM Number) onto the stack.";
  OpcodeDescriptionsXEC2["OP_9"] = "Push a 9 (VM Number) onto the stack.";
  OpcodeDescriptionsXEC2["OP_10"] = "Push a 10 (VM Number) onto the stack.";
  OpcodeDescriptionsXEC2["OP_11"] = "Push a 11 (VM Number) onto the stack.";
  OpcodeDescriptionsXEC2["OP_12"] = "Push a 12 (VM Number) onto the stack.";
  OpcodeDescriptionsXEC2["OP_13"] = "Push a 13 (VM Number) onto the stack.";
  OpcodeDescriptionsXEC2["OP_14"] = "Push a 14 (VM Number) onto the stack.";
  OpcodeDescriptionsXEC2["OP_15"] = "Push a 15 (VM Number) onto the stack.";
  OpcodeDescriptionsXEC2["OP_16"] = "Push a 16 (VM Number) onto the stack.";
  OpcodeDescriptionsXEC2["OP_NOP"] = "No operation. Note: OP_NOP counts toward the opcode limit.";
  OpcodeDescriptionsXEC2["OP_VER"] = "Error unless found in an unexecuted conditional branch. Note: OP_VER counts toward the opcode limit. (Historically, this pushed a protocol version number to the stack.)";
  OpcodeDescriptionsXEC2["OP_IF"] = 'Pop the top item from the stack. If it is not "truthy", skip evaluation until a matching OP_ELSE or OP_ENDIF.';
  OpcodeDescriptionsXEC2["OP_NOTIF"] = 'Pop the top item from the stack. If it is "truthy", skip evaluation until a matching OP_ELSE or OP_ENDIF.';
  OpcodeDescriptionsXEC2["OP_VERIF"] = "Error, even when found in an unexecuted conditional branch. (Historically, this was a combination of OP_VER and OP_IF.)";
  OpcodeDescriptionsXEC2["OP_VERNOTIF"] = "Error, even when found in an unexecuted conditional branch. (Historically, this was a combination of OP_VER and OP_NOTIF.)";
  OpcodeDescriptionsXEC2["OP_ELSE"] = "Invert conditional evaluation within the current OP_IF ... OP_ENDIF block. (If evaluation is enabled, disable it, if it is disabled, enable it.)";
  OpcodeDescriptionsXEC2["OP_ENDIF"] = "End the current OP_IF/OP_NOTIF ... OP_ENDIF block.";
  OpcodeDescriptionsXEC2["OP_VERIFY"] = `Pop the top item from the stack and error if it isn't "truthy".`;
  OpcodeDescriptionsXEC2["OP_RETURN"] = "Error when executed.";
  OpcodeDescriptionsXEC2["OP_TOALTSTACK"] = "Pop the top item from the stack and push it onto the alternate stack.";
  OpcodeDescriptionsXEC2["OP_FROMALTSTACK"] = "Pop the top item from the alternate stack and push it onto the stack.";
  OpcodeDescriptionsXEC2["OP_2DROP"] = "Pop the top 2 items from the stack and discard them.";
  OpcodeDescriptionsXEC2["OP_2DUP"] = "Duplicate the top 2 items on the stack. (E.g. [a, b] -> [a, b, a, b])";
  OpcodeDescriptionsXEC2["OP_3DUP"] = "Duplicate the top 3 items on the stack. (E.g. [a, b, c] -> [a, b, c, a, b, c])";
  OpcodeDescriptionsXEC2["OP_2OVER"] = "Duplicate the 2 items beginning at a depth of 2 on the stack. (E.g. [a, b, c, d] -> [a, b, c, d, a, b])";
  OpcodeDescriptionsXEC2["OP_2ROT"] = "Rotate the top 6 items on the stack, bringing the fifth and sixth items to the top. (E.g. [a, b, c, d, e, f] -> [c, d, e, f, a, b])";
  OpcodeDescriptionsXEC2["OP_2SWAP"] = "Swap the positions of the top two pairs of items on the stack. (E.g. [a, b, c, d] -> [c, d, a, b])";
  OpcodeDescriptionsXEC2["OP_IFDUP"] = 'If the top item on the stack is "truthy", duplicate it.';
  OpcodeDescriptionsXEC2["OP_DEPTH"] = "Push the current number of stack items as a VM Number.";
  OpcodeDescriptionsXEC2["OP_DROP"] = "Pop the top item from the stack and discard it. (E.g. [a] -> [])";
  OpcodeDescriptionsXEC2["OP_DUP"] = "Duplicate the top item on the stack. (E.g. [a] -> [a, a])";
  OpcodeDescriptionsXEC2["OP_NIP"] = "Remove the second-to-top item from the stack. (E.g. [a, b] -> [b])";
  OpcodeDescriptionsXEC2["OP_OVER"] = "Duplicate the second-to-top item on the stack. (E.g. [a, b] -> [a, b, a])";
  OpcodeDescriptionsXEC2["OP_PICK"] = "Pop the top item from the stack as a VM Number. Duplicate the item at that depth (zero-indexed), placing it on top of the stack. (E.g. [a, b, c, 2] -> [a, b, c, a])";
  OpcodeDescriptionsXEC2["OP_ROLL"] = "Pop the top item from the stack as a VM Number. Move the item at that depth (zero-indexed) to the top of the stack. (E.g. [a, b, c, 2] -> [b, c, a])";
  OpcodeDescriptionsXEC2["OP_ROT"] = "Rotate the top 3 items on the stack, bringing the third item to the top. (E.g. [a, b, c] -> [b, c, a])";
  OpcodeDescriptionsXEC2["OP_SWAP"] = "Swap the top two items on the stack. (E.g. [a, b] -> [b, a])";
  OpcodeDescriptionsXEC2["OP_TUCK"] = "Duplicate the item at the top of the stack, inserting it below the second-to-top item. (E.g. [a, b] -> [b, a, b])";
  OpcodeDescriptionsXEC2["OP_CAT"] = "Pop the top 2 items from the stack and concatenate them, pushing the result.";
  OpcodeDescriptionsXEC2["OP_SPLIT"] = "Pop the top item from the stack as an index (VM Number) and the next item as a byte array. Split the byte array into two stack items at the index (zero-based), pushing the results.";
  OpcodeDescriptionsXEC2["OP_NUM2BIN"] = "Pop the top item from the stack as an item length (VM Number) and the next item as a VM Number (without encoding restrictions). Re-encode the number using a byte array of the provided length, filling any unused bytes with zeros, then push the result. (If the requested length is too short to encode the number, error.)";
  OpcodeDescriptionsXEC2["OP_BIN2NUM"] = "Pop the top item from the stack as a VM Number without encoding restrictions. Minimally-encode the number and push the result. (If the number can't be encoded in 4 bytes or less, error.)";
  OpcodeDescriptionsXEC2["OP_SIZE"] = "Push the byte-length of the top stack item as a VM Number.";
  OpcodeDescriptionsXEC2["OP_INVERT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this flipped all the bits in a stack item.)";
  OpcodeDescriptionsXEC2["OP_AND"] = "Pop the top 2 items from the stack and perform a bitwise AND on each byte, pushing the result. If the length of the items are not equal, error.";
  OpcodeDescriptionsXEC2["OP_OR"] = "Pop the top 2 items from the stack and perform a bitwise OR on each byte, pushing the result. If the length of the items are not equal, error.";
  OpcodeDescriptionsXEC2["OP_XOR"] = "Pop the top 2 items from the stack and perform a bitwise XOR on each byte, pushing the result. If the length of the items are not equal, error.";
  OpcodeDescriptionsXEC2["OP_EQUAL"] = "Pop the top two items from the stack and compare them byte-by-byte. If they are the same, push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsXEC2["OP_EQUALVERIFY"] = "Pop the top two items from the stack and compare them byte-by-byte. If the values are different, error. (This operation is a combination of OP_EQUAL followed by OP_VERIFY.)";
  OpcodeDescriptionsXEC2["OP_RESERVED1"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED1 counts toward the opcode limit.";
  OpcodeDescriptionsXEC2["OP_RESERVED2"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED2 counts toward the opcode limit.";
  OpcodeDescriptionsXEC2["OP_1ADD"] = "Pop the top item from the stack as a VM Number, add 1, then push the result.";
  OpcodeDescriptionsXEC2["OP_1SUB"] = "Pop the top item from the stack as a VM Number, subtract 1, then push the result.";
  OpcodeDescriptionsXEC2["OP_2MUL"] = "Error, even when found in an unexecuted conditional branch. (Historically, this multiplied a VM Number by 2.)";
  OpcodeDescriptionsXEC2["OP_2DIV"] = "Error, even when found in an unexecuted conditional branch. (Historically, this divided a VM Number by 2.)";
  OpcodeDescriptionsXEC2["OP_NEGATE"] = "Pop the top item from the stack as a VM Number, negate it, then push the result.";
  OpcodeDescriptionsXEC2["OP_ABS"] = "Pop the top item from the stack as a VM Number, take its absolute value, then push the result.";
  OpcodeDescriptionsXEC2["OP_NOT"] = "Pop the top item from the stack as a VM Number. If its value is 0, push a 1 (VM Number), otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsXEC2["OP_0NOTEQUAL"] = "Pop the top item from the stack as a VM Number. If its value is not 0, push a 1 (VM Number), otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsXEC2["OP_ADD"] = "Pop the top two items from the stack as VM Numbers. Add them, then push the result.";
  OpcodeDescriptionsXEC2["OP_SUB"] = "Pop the top two items from the stack as VM Numbers. Subtract the top item from the second item, then push the result.";
  OpcodeDescriptionsXEC2["OP_MUL"] = "Pop the top two items from the stack as VM Numbers. Multiply them, then push the result.";
  OpcodeDescriptionsXEC2["OP_DIV"] = "Pop the top item from the stack as a denominator (VM Number) and the next as a numerator (VM Number). Divide and push the result to the stack.";
  OpcodeDescriptionsXEC2["OP_MOD"] = "Pop the top item from the stack as a denominator (VM Number) and the next as a numerator (VM Number). Divide and push the remainder to the stack.";
  OpcodeDescriptionsXEC2["OP_LSHIFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a sign-preserving, left bit shift.)";
  OpcodeDescriptionsXEC2["OP_RSHIFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a sign-preserving, right bit shift.)";
  OpcodeDescriptionsXEC2["OP_BOOLAND"] = "Pop the top two items from the stack as VM Numbers. If neither value is a 0 (VM Number), push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsXEC2["OP_BOOLOR"] = "Pop the top two items from the stack as VM Numbers. If either value is a 1 (VM Number), push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsXEC2["OP_NUMEQUAL"] = "Pop the top two items from the stack as VM Numbers. If the values are equal, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsXEC2["OP_NUMEQUALVERIFY"] = "Pop the top two items from the stack as VM Numbers. If the values are different, error. (This operation is a combination of OP_NUMEQUAL followed by OP_VERIFY.)";
  OpcodeDescriptionsXEC2["OP_NUMNOTEQUAL"] = "Pop the top two items from the stack as VM Numbers. If the values are not equal, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsXEC2["OP_LESSTHAN"] = "Pop the top two items from the stack as VM Numbers. If the second item is less than top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsXEC2["OP_GREATERTHAN"] = "Pop the top two items from the stack as VM Numbers. If the second item is greater than top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsXEC2["OP_LESSTHANOREQUAL"] = "Pop the top two items from the stack as VM Numbers. If the second item is less than or equal to the top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsXEC2["OP_GREATERTHANOREQUAL"] = "Pop the top two items from the stack as VM Numbers. If the second item is greater than or equal to the top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsXEC2["OP_MIN"] = "Pop the top two items from the stack as VM Numbers. Push the smaller of the two numbers.";
  OpcodeDescriptionsXEC2["OP_MAX"] = "Pop the top two items from the stack as VM Numbers. Push the larger of the two numbers.";
  OpcodeDescriptionsXEC2["OP_WITHIN"] = "Pop the top three items from the stack as VM Numbers. If the top number is within the range defined by the following two numbers (left-inclusive), push a 1 (VM Number). Otherwise, push a 0 (VM Number). (E.g. for [a, b, c]: if (b <= a), and (a < c), [1]. Else [0].)";
  OpcodeDescriptionsXEC2["OP_RIPEMD160"] = "Pop the top item from the stack and pass it through ripemd160, pushing the result onto the stack.";
  OpcodeDescriptionsXEC2["OP_SHA1"] = "Pop the top item from the stack and pass it through sha1, pushing the result onto the stack.";
  OpcodeDescriptionsXEC2["OP_SHA256"] = "Pop the top item from the stack and pass it through sha256, pushing the result onto the stack.";
  OpcodeDescriptionsXEC2["OP_HASH160"] = "Pop the top item from the stack and pass it through sha256, then ripemd160, pushing the result onto the stack.";
  OpcodeDescriptionsXEC2["OP_HASH256"] = "Pop the top item from the stack and pass it through sha256 twice, pushing the result onto the stack.";
  OpcodeDescriptionsXEC2["OP_CODESEPARATOR"] = "Update the value of lastCodeSeparator to the instruction pointer's current value. (This reduces the coverage of signing serializations used in signature verification operations.)";
  OpcodeDescriptionsXEC2["OP_CHECKSIG"] = "Pop the top two items from the stack. Treat the top as a signature and the second as a public key. If the signature is valid, push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsXEC2["OP_CHECKSIGVERIFY"] = "Pop the top two items from the stack. Treat the top as a signature and the second as a public key. If the signature is not valid, error. (This operation is a combination of OP_CHECKSIG followed by OP_VERIFY.)";
  OpcodeDescriptionsXEC2["OP_CHECKMULTISIG"] = "Pop items from the stack: first pop the VM Number of public keys, then pop each of those public keys. Next, pop the VM Number of required signatures, then pop each of those signatures. Finally, pop a final VM Number that must be 0 due to a protocol bug. Checking each signature against each public key in order, if all signatures are valid – and the required number of signatures have been provided – push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsXEC2["OP_CHECKMULTISIGVERIFY"] = "Pop items from the stack: first pop the VM Number of public keys, then pop each of those public keys. Next, pop the VM Number of required signatures, then pop each of those signatures. Finally, (due to a protocol bug) pop an unused final VM Number that must be 0. Checking each signature against each public key in order, if any signatures are invalid – or the required number of signatures have not been provided – error. (This operation is a combination of OP_CHECKMULTISIG followed by OP_VERIFY.)";
  OpcodeDescriptionsXEC2["OP_NOP1"] = "No operation (reserved for future expansion). Note: OP_NOP1 counts toward the opcode limit.";
  OpcodeDescriptionsXEC2["OP_CHECKLOCKTIMEVERIFY"] = "Verify the transaction occurs after an absolute block time or height: read the top item on the stack as a VM Number (without removing it), and compare it to the transaction's locktime. If the required locktime has not passed, or if locktime has been disabled for this input by a maximized sequence number, error.";
  OpcodeDescriptionsXEC2["OP_CHECKSEQUENCEVERIFY"] = `Verify the transaction occurs after the output being spent has "aged" by a relative block time or block height since it was created: read the top item on the stack as a VM Number (without removing it), and compare it to the age encoded in the input's sequence number. If the required relative locktime has not passed, or if relative locktime has been disabled by the sequence number or the transaction version, error.`;
  OpcodeDescriptionsXEC2["OP_NOP4"] = "No operation (reserved for future expansion). Note: OP_NOP4 counts toward the opcode limit.";
  OpcodeDescriptionsXEC2["OP_NOP6"] = "No operation (reserved for future expansion). Note: OP_NOP6 counts toward the opcode limit.";
  OpcodeDescriptionsXEC2["OP_NOP5"] = "No operation (reserved for future expansion). Note: OP_NOP5 counts toward the opcode limit.";
  OpcodeDescriptionsXEC2["OP_NOP7"] = "No operation (reserved for future expansion). Note: OP_NOP7 counts toward the opcode limit.";
  OpcodeDescriptionsXEC2["OP_NOP8"] = "No operation (reserved for future expansion). Note: OP_NOP8 counts toward the opcode limit.";
  OpcodeDescriptionsXEC2["OP_NOP9"] = "No operation (reserved for future expansion). Note: OP_NOP9 counts toward the opcode limit.";
  OpcodeDescriptionsXEC2["OP_NOP10"] = "No operation (reserved for future expansion). Note: OP_NOP10 counts toward the opcode limit.";
  OpcodeDescriptionsXEC2["OP_CHECKDATASIG"] = "Pop the top 3 items from the stack. Treat the top as a public key, the second as a message, and the third as a signature. If the signature is valid, push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsXEC2["OP_CHECKDATASIGVERIFY"] = "Pop the top 3 items from the stack. Treat the top as a public key, the second as a message, and the third as a signature. If the signature is not valid, error. (This operation is a combination of OP_CHECKDATASIG followed by OP_VERIFY.)";
  OpcodeDescriptionsXEC2["OP_REVERSEBYTES"] = "Pop the top item from the stack and reverse it, pushing the result.";
})(OpcodeDescriptionsXEC || (OpcodeDescriptionsXEC = {}));

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/xec/xec-instruction-set.js
var import_dist241 = __toESM(require_dist(), 1);
var import_dist242 = __toESM(require_dist2(), 1);
var import_dist243 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/bch/2022/bch-2022-instruction-set.js
var import_dist229 = __toESM(require_dist(), 1);
var import_dist230 = __toESM(require_dist2(), 1);
var import_dist231 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/message/message.js
var import_dist136 = __toESM(require_dist(), 1);
var import_dist137 = __toESM(require_dist2(), 1);
var import_dist138 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/message/read-components.js
var import_dist127 = __toESM(require_dist(), 1);
var import_dist128 = __toESM(require_dist2(), 1);
var import_dist129 = __toESM(require_dist3(), 1);
var ReadBytesError;
(function(ReadBytesError2) {
  ReadBytesError2["insufficientLength"] = "Error reading bytes: insufficient length.";
})(ReadBytesError || (ReadBytesError = {}));
var readBytes = (length) => (position) => {
  const nextPosition = {
    bin: position.bin,
    index: position.index + length
  };
  const result = position.bin.slice(position.index, nextPosition.index);
  if (result.length !== length) {
    return formatError(ReadBytesError.insufficientLength, `Provided length: ${result.length}`);
  }
  return { position: nextPosition, result };
};
var ReadUint32LEError;
(function(ReadUint32LEError2) {
  ReadUint32LEError2["insufficientBytes"] = "Error reading Uint32LE: requires 4 bytes.";
})(ReadUint32LEError || (ReadUint32LEError = {}));
var readUint32LE = (position) => {
  const nextPosition = {
    bin: position.bin,
    index: position.index + 4
  };
  const uint32LEBin = position.bin.subarray(position.index, nextPosition.index);
  if (uint32LEBin.length !== 4) {
    return formatError(ReadUint32LEError.insufficientBytes, `Provided length: ${uint32LEBin.length}`);
  }
  const result = binToNumberUint32LE(uint32LEBin);
  return { position: nextPosition, result };
};
var ReadUint64LEError;
(function(ReadUint64LEError2) {
  ReadUint64LEError2["insufficientBytes"] = "Error reading Uint64LE: requires 8 bytes.";
})(ReadUint64LEError || (ReadUint64LEError = {}));
var readUint64LE = (position) => {
  const nextPosition = {
    bin: position.bin,
    index: position.index + 8
  };
  const uint64LEBin = position.bin.subarray(position.index, nextPosition.index);
  if (uint64LEBin.length !== 8) {
    return formatError(ReadUint64LEError.insufficientBytes, `Provided length: ${uint64LEBin.length}`);
  }
  const result = binToBigIntUint64LE(uint64LEBin);
  return { position: nextPosition, result };
};
var CompactSizePrefixedBinError;
(function(CompactSizePrefixedBinError2) {
  CompactSizePrefixedBinError2["invalidCompactSize"] = "Error reading CompactSize-prefixed bin: invalid CompactSize.";
  CompactSizePrefixedBinError2["insufficientBytes"] = "Error reading CompactSize-prefixed bin: insufficient bytes.";
})(CompactSizePrefixedBinError || (CompactSizePrefixedBinError = {}));
var readCompactSizePrefixedBin = (position) => {
  const read = readCompactSizeMinimal(position);
  if (typeof read === "string") {
    return formatError(CompactSizePrefixedBinError.invalidCompactSize, read);
  }
  const { result, position: p2 } = read;
  const length = Number(result);
  const nextPosition = { bin: position.bin, index: p2.index + length };
  const contents = position.bin.slice(p2.index, nextPosition.index);
  if (contents.length !== length) {
    return formatError(CompactSizePrefixedBinError.insufficientBytes, `Required bytes: ${length}, remaining bytes: ${contents.length}`);
  }
  return { position: nextPosition, result: contents };
};
var readRemainingBytes = (position) => {
  const nextPosition = {
    bin: position.bin,
    index: position.bin.length
  };
  const result = position.bin.subarray(position.index, nextPosition.index);
  return { position: nextPosition, result };
};

// node_modules/@bitauth/libauth/build/lib/message/transaction-encoding.js
var import_dist133 = __toESM(require_dist(), 1);
var import_dist134 = __toESM(require_dist2(), 1);
var import_dist135 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/message/transaction-types.js
var import_dist130 = __toESM(require_dist(), 1);
var import_dist131 = __toESM(require_dist2(), 1);
var import_dist132 = __toESM(require_dist3(), 1);
var NonFungibleTokenCapability;
(function(NonFungibleTokenCapability2) {
  NonFungibleTokenCapability2["none"] = "none";
  NonFungibleTokenCapability2["mutable"] = "mutable";
  NonFungibleTokenCapability2["minting"] = "minting";
})(NonFungibleTokenCapability || (NonFungibleTokenCapability = {}));
var excessiveSatoshis = Uint8Array.from([255, 255, 255, 255, 255, 255, 255, 255]);

// node_modules/@bitauth/libauth/build/lib/message/transaction-encoding.js
var encodeTransactionInput = (input) => flattenBinArray([
  input.outpointTransactionHash.slice().reverse(),
  numberToBinUint32LE(input.outpointIndex),
  bigIntToCompactSize(BigInt(input.unlockingBytecode.length)),
  input.unlockingBytecode,
  numberToBinUint32LE(input.sequenceNumber)
]);
var TransactionDecodingError;
(function(TransactionDecodingError2) {
  TransactionDecodingError2["transaction"] = "Error reading transaction.";
  TransactionDecodingError2["endsWithUnexpectedBytes"] = "Error decoding transaction: the provided input includes unexpected bytes after the encoded transaction.";
  TransactionDecodingError2["input"] = "Error reading transaction input.";
  TransactionDecodingError2["inputs"] = "Error reading transaction inputs.";
  TransactionDecodingError2["output"] = "Error reading transaction output.";
  TransactionDecodingError2["outputs"] = "Error reading transaction outputs.";
  TransactionDecodingError2["lockingBytecodeLength"] = "Error reading locking bytecode length.";
})(TransactionDecodingError || (TransactionDecodingError = {}));
var readTransactionInput = (position) => {
  const inputRead = readMultiple(position, [
    readBytes(
      32
      /* TransactionConstants.outpointTransactionHashLength */
    ),
    readUint32LE,
    readCompactSizePrefixedBin,
    readUint32LE
  ]);
  if (typeof inputRead === "string") {
    return formatError(TransactionDecodingError.input, inputRead);
  }
  const { position: nextPosition, result: [outpointTransactionHash, outpointIndex, unlockingBytecode, sequenceNumber] } = inputRead;
  return {
    position: nextPosition,
    result: {
      outpointIndex,
      outpointTransactionHash: outpointTransactionHash.reverse(),
      sequenceNumber,
      unlockingBytecode
    }
  };
};
var encodeTransactionInputs = (inputs) => flattenBinArray([
  bigIntToCompactSize(BigInt(inputs.length)),
  ...inputs.map(encodeTransactionInput)
]);
var readTransactionInputs = (position) => {
  const inputsRead = readItemCount(position, readTransactionInput);
  if (typeof inputsRead === "string") {
    return formatError(TransactionDecodingError.inputs, inputsRead);
  }
  return inputsRead;
};
var maximumTokenAmount = 9223372036854775807n;
var nftCapabilityNumberToLabel = [
  NonFungibleTokenCapability.none,
  NonFungibleTokenCapability.mutable,
  NonFungibleTokenCapability.minting
];
var nftCapabilityLabelToNumber = {
  [NonFungibleTokenCapability.none]: 0,
  [NonFungibleTokenCapability.mutable]: 1,
  [NonFungibleTokenCapability.minting]: 2
};
var CashTokenDecodingError;
(function(CashTokenDecodingError2) {
  CashTokenDecodingError2["invalidPrefix"] = "Error reading token prefix.";
  CashTokenDecodingError2["insufficientLength"] = "Invalid token prefix: insufficient length.";
  CashTokenDecodingError2["reservedBit"] = "Invalid token prefix: reserved bit is set.";
  CashTokenDecodingError2["invalidCapability"] = "Invalid token prefix: capability must be none (0), mutable (1), or minting (2).";
  CashTokenDecodingError2["commitmentWithoutNft"] = "Invalid token prefix: commitment requires an NFT.";
  CashTokenDecodingError2["capabilityWithoutNft"] = "Invalid token prefix: capability requires an NFT.";
  CashTokenDecodingError2["commitmentLengthZero"] = "Invalid token prefix: if encoded, commitment length must be greater than 0.";
  CashTokenDecodingError2["invalidCommitment"] = "Invalid token prefix: invalid non-fungible token commitment.";
  CashTokenDecodingError2["invalidAmountEncoding"] = "Invalid token prefix: invalid fungible token amount encoding.";
  CashTokenDecodingError2["zeroAmount"] = "Invalid token prefix: if encoded, fungible token amount must be greater than 0.";
  CashTokenDecodingError2["excessiveAmount"] = "Invalid token prefix: exceeds maximum fungible token amount of 9223372036854775807.";
  CashTokenDecodingError2["noTokens"] = "Invalid token prefix: must encode at least one token.";
})(CashTokenDecodingError || (CashTokenDecodingError = {}));
var readTokenAmount = (position) => {
  const amountRead = readCompactSizeMinimal(position);
  if (typeof amountRead === "string") {
    return formatError(CashTokenDecodingError.invalidAmountEncoding, amountRead);
  }
  if (amountRead.result > maximumTokenAmount) {
    return formatError(CashTokenDecodingError.excessiveAmount, `Encoded amount: ${amountRead.result}`);
  }
  if (amountRead.result === 0n) {
    return formatError(CashTokenDecodingError.zeroAmount);
  }
  return amountRead;
};
var readTokenPrefix = (position) => {
  const { bin, index: index2 } = position;
  if (bin[index2] !== 239) {
    return { position, result: {} };
  }
  if (bin.length < index2 + 34) {
    return formatError(CashTokenDecodingError.insufficientLength, `The minimum possible length is ${34}. Missing bytes: ${34 - (bin.length - index2)}`);
  }
  const category = bin.slice(
    index2 + 1,
    index2 + 33
    /* CashTokens.tokenBitfieldIndex */
  ).reverse();
  const tokenBitfield = bin[
    index2 + 33
    /* CashTokens.tokenBitfieldIndex */
  ];
  const prefixStructure = tokenBitfield & 240;
  if ((prefixStructure & 128) !== 0) {
    return formatError(CashTokenDecodingError.reservedBit, `Bitfield: 0b${tokenBitfield.toString(
      2
      /* CashTokens.useBinaryOutput */
    )}`);
  }
  const nftCapabilityInt = tokenBitfield & 15;
  if (nftCapabilityInt > 2) {
    return formatError(CashTokenDecodingError.invalidCapability, `Capability value: ${nftCapabilityInt}`);
  }
  const capability = nftCapabilityNumberToLabel[nftCapabilityInt];
  const hasNft = (prefixStructure & 32) !== 0;
  const hasCommitmentLength = (prefixStructure & 64) !== 0;
  if (hasCommitmentLength && !hasNft) {
    return formatError(CashTokenDecodingError.commitmentWithoutNft, `Bitfield: 0b${tokenBitfield.toString(
      2
      /* CashTokens.useBinaryOutput */
    )}`);
  }
  const hasAmount = (prefixStructure & 16) !== 0;
  const nextPosition = {
    bin,
    index: index2 + 33 + 1
  };
  if (hasNft) {
    const commitmentRead = hasCommitmentLength ? readCompactSizePrefixedBin(nextPosition) : { position: nextPosition, result: Uint8Array.of() };
    if (typeof commitmentRead === "string") {
      return formatError(CashTokenDecodingError.invalidCommitment, commitmentRead);
    }
    if (hasCommitmentLength && commitmentRead.result.length === 0) {
      return formatError(CashTokenDecodingError.commitmentLengthZero);
    }
    const amountRead2 = hasAmount ? readTokenAmount(commitmentRead.position) : { position: commitmentRead.position, result: 0n };
    if (typeof amountRead2 === "string") {
      return amountRead2;
    }
    return {
      position: amountRead2.position,
      result: {
        token: {
          amount: amountRead2.result,
          category,
          nft: { capability, commitment: commitmentRead.result }
        }
      }
    };
  }
  if (capability !== NonFungibleTokenCapability.none) {
    return formatError(CashTokenDecodingError.capabilityWithoutNft, `Bitfield: 0b${tokenBitfield.toString(
      2
      /* CashTokens.useBinaryOutput */
    )}`);
  }
  if (!hasAmount) {
    return formatError(CashTokenDecodingError.noTokens, `Bitfield: 0b${tokenBitfield.toString(
      2
      /* CashTokens.useBinaryOutput */
    )}`);
  }
  const amountRead = readTokenAmount(nextPosition);
  if (typeof amountRead === "string") {
    return amountRead;
  }
  return {
    position: amountRead.position,
    result: { token: { amount: amountRead.result, category } }
  };
};
var readLockingBytecodeWithPrefix = (position) => {
  const bytecodeRead = readCompactSizePrefixedBin(position);
  if (typeof bytecodeRead === "string") {
    return formatError(TransactionDecodingError.lockingBytecodeLength, bytecodeRead);
  }
  const { result: contents, position: nextPosition } = bytecodeRead;
  const contentsRead = readMultiple({ bin: contents, index: 0 }, [
    readTokenPrefix,
    readRemainingBytes
  ]);
  if (typeof contentsRead === "string") {
    return formatError(CashTokenDecodingError.invalidPrefix, contentsRead);
  }
  const { result: [{ token }, lockingBytecode] } = contentsRead;
  return {
    position: nextPosition,
    result: { lockingBytecode, ...token === void 0 ? {} : { token } }
  };
};
var readTransactionOutput = (position) => {
  const outputRead = readMultiple(position, [
    readUint64LE,
    readLockingBytecodeWithPrefix
  ]);
  if (typeof outputRead === "string") {
    return formatError(TransactionDecodingError.output, outputRead);
  }
  const { position: nextPosition, result: [valueSatoshis, { lockingBytecode, token }] } = outputRead;
  return {
    position: nextPosition,
    result: {
      lockingBytecode,
      ...token === void 0 ? {} : { token },
      valueSatoshis
    }
  };
};
var encodeTokenPrefix = (token) => {
  if (token === void 0 || token.nft === void 0 && token.amount < 1n) {
    return Uint8Array.of();
  }
  const hasNft = token.nft === void 0 ? 0 : 32;
  const capabilityInt = token.nft === void 0 ? 0 : nftCapabilityLabelToNumber[token.nft.capability];
  const hasCommitmentLength = token.nft !== void 0 && token.nft.commitment.length > 0 ? 64 : 0;
  const hasAmount = token.amount > 0n ? 16 : 0;
  const tokenBitfield = (
    // eslint-disable-next-line no-bitwise
    hasNft | hasCommitmentLength | hasAmount | capabilityInt
  );
  return flattenBinArray([
    Uint8Array.of(
      239
      /* CashTokens.PREFIX_TOKEN */
    ),
    token.category.slice().reverse(),
    Uint8Array.of(tokenBitfield),
    ...hasCommitmentLength === 0 ? [] : [
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      bigIntToCompactSize(BigInt(token.nft.commitment.length)),
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      token.nft.commitment
    ],
    ...hasAmount === 0 ? [] : [bigIntToCompactSize(token.amount)]
  ]);
};
var encodeTransactionOutput = (output) => {
  const lockingBytecodeField = flattenBinArray([
    encodeTokenPrefix(output.token),
    output.lockingBytecode
  ]);
  return flattenBinArray([
    valueSatoshisToBin(output.valueSatoshis),
    bigIntToCompactSize(BigInt(lockingBytecodeField.length)),
    lockingBytecodeField
  ]);
};
var readTransactionOutputs = (position) => {
  const outputsRead = readItemCount(position, readTransactionOutput);
  if (typeof outputsRead === "string") {
    return formatError(TransactionDecodingError.outputs, outputsRead);
  }
  return outputsRead;
};
var encodeTransactionOutputs = (outputs) => flattenBinArray([
  bigIntToCompactSize(BigInt(outputs.length)),
  ...outputs.map(encodeTransactionOutput)
]);
var readTransactionCommon = (position) => {
  const transactionRead = readMultiple(position, [
    readUint32LE,
    readTransactionInputs,
    readTransactionOutputs,
    readUint32LE
  ]);
  if (typeof transactionRead === "string") {
    return formatError(TransactionDecodingError.transaction, transactionRead);
  }
  const { position: nextPosition, result: [version, inputs, outputs, locktime] } = transactionRead;
  return {
    position: nextPosition,
    result: { inputs, locktime, outputs, version }
  };
};
var readTransaction = readTransactionCommon;
var readTransactionOutputNonTokenAware = (pos) => {
  const outputRead = readMultiple(pos, [
    readUint64LE,
    readCompactSizePrefixedBin
  ]);
  if (typeof outputRead === "string") {
    return formatError(TransactionDecodingError.output, outputRead);
  }
  const { position: nextPosition, result: [valueSatoshis, lockingBytecode] } = outputRead;
  return {
    position: nextPosition,
    result: { lockingBytecode, valueSatoshis }
  };
};
var readTransactionOutputsNonTokenAware = (pos) => {
  const outputsRead = readItemCount(pos, readTransactionOutputNonTokenAware);
  if (typeof outputsRead === "string") {
    return formatError(TransactionDecodingError.outputs, outputsRead);
  }
  return outputsRead;
};
var readTransactionNonTokenAware = (position) => {
  const transactionRead = readMultiple(position, [
    readUint32LE,
    readTransactionInputs,
    readTransactionOutputsNonTokenAware,
    readUint32LE
  ]);
  if (typeof transactionRead === "string") {
    return formatError(TransactionDecodingError.transaction, transactionRead);
  }
  const { position: nextPosition, result: [version, inputs, outputs, locktime] } = transactionRead;
  return {
    position: nextPosition,
    result: { inputs, locktime, outputs, version }
  };
};
var decodeTransactionCommon = (bin) => {
  const transactionRead = readTransactionCommon({ bin, index: 0 });
  if (typeof transactionRead === "string") {
    return transactionRead;
  }
  if (transactionRead.position.index !== bin.length) {
    return formatError(TransactionDecodingError.endsWithUnexpectedBytes, `Encoded transaction ends at index ${transactionRead.position.index - 1}, leaving ${bin.length - transactionRead.position.index} remaining bytes.`);
  }
  return transactionRead.result;
};
var decodeTransactionBCH = decodeTransactionCommon;
var decodeTransaction = decodeTransactionBCH;
var decodeTransactionUnsafeCommon = (bin) => {
  const result = decodeTransactionCommon(bin);
  if (typeof result === "string") {
    throw new Error(result);
  }
  return result;
};
var decodeTransactionUnsafeBCH = decodeTransactionUnsafeCommon;
var decodeTransactionUnsafe = decodeTransactionUnsafeBCH;
var encodeTransactionCommon = (tx) => flattenBinArray([
  numberToBinUint32LE(tx.version),
  encodeTransactionInputs(tx.inputs),
  encodeTransactionOutputs(tx.outputs),
  numberToBinUint32LE(tx.locktime)
]);
var encodeTransactionBCH = encodeTransactionCommon;
var encodeTransaction = encodeTransactionBCH;
var cloneTransactionInputsCommon = (inputs) => inputs.map((input) => ({
  outpointIndex: input.outpointIndex,
  outpointTransactionHash: input.outpointTransactionHash.slice(),
  sequenceNumber: input.sequenceNumber,
  unlockingBytecode: input.unlockingBytecode.slice()
}));
var cloneTransactionOutputsCommon = (outputs) => outputs.map((output) => ({
  lockingBytecode: output.lockingBytecode.slice(),
  ...output.token === void 0 ? {} : {
    token: {
      amount: output.token.amount,
      category: output.token.category.slice(),
      ...output.token.nft === void 0 ? {} : {
        nft: {
          capability: output.token.nft.capability,
          commitment: output.token.nft.commitment.slice()
        }
      }
    }
  },
  valueSatoshis: output.valueSatoshis
}));
var cloneTransactionCommon = (transaction) => ({
  inputs: cloneTransactionInputsCommon(transaction.inputs),
  locktime: transaction.locktime,
  outputs: cloneTransactionOutputsCommon(transaction.outputs),
  version: transaction.version
});
var hashTransactionP2pOrder = (transaction, sha2562 = sha256) => hash256(transaction, sha2562);
var hashTransactionUiOrder = (transaction, sha2562 = sha256) => hashTransactionP2pOrder(transaction, sha2562).reverse();
var hashTransaction = (transaction) => binToHex(hashTransactionUiOrder(transaction));
var encodeTransactionOutpoints = (inputs) => flattenBinArray(inputs.map((i) => flattenBinArray([
  i.outpointTransactionHash.slice().reverse(),
  numberToBinUint32LE(i.outpointIndex)
])));
var encodeTransactionOutputsForSigning = (outputs) => flattenBinArray(outputs.map(encodeTransactionOutput));
var encodeTransactionInputSequenceNumbersForSigning = (inputs) => flattenBinArray(inputs.map((i) => numberToBinUint32LE(i.sequenceNumber)));

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/common/common.js
var import_dist199 = __toESM(require_dist(), 1);
var import_dist200 = __toESM(require_dist2(), 1);
var import_dist201 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/common/arithmetic.js
var import_dist163 = __toESM(require_dist(), 1);
var import_dist164 = __toESM(require_dist2(), 1);
var import_dist165 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/common/combinators.js
var import_dist157 = __toESM(require_dist(), 1);
var import_dist158 = __toESM(require_dist2(), 1);
var import_dist159 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/common/consensus.js
var import_dist142 = __toESM(require_dist(), 1);
var import_dist143 = __toESM(require_dist2(), 1);
var import_dist144 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/common/signing-serialization.js
var import_dist139 = __toESM(require_dist(), 1);
var import_dist140 = __toESM(require_dist2(), 1);
var import_dist141 = __toESM(require_dist3(), 1);
var SigningSerializationFlag;
(function(SigningSerializationFlag2) {
  SigningSerializationFlag2[SigningSerializationFlag2["allOutputs"] = 1] = "allOutputs";
  SigningSerializationFlag2[SigningSerializationFlag2["noOutputs"] = 2] = "noOutputs";
  SigningSerializationFlag2[SigningSerializationFlag2["correspondingOutput"] = 3] = "correspondingOutput";
  SigningSerializationFlag2[SigningSerializationFlag2["utxos"] = 32] = "utxos";
  SigningSerializationFlag2[SigningSerializationFlag2["forkId"] = 64] = "forkId";
  SigningSerializationFlag2[SigningSerializationFlag2["singleInput"] = 128] = "singleInput";
})(SigningSerializationFlag || (SigningSerializationFlag = {}));
var SigningSerializationType;
(function(SigningSerializationType2) {
  SigningSerializationType2[SigningSerializationType2["allOutputs"] = 65] = "allOutputs";
  SigningSerializationType2[SigningSerializationType2["allOutputsAllUtxos"] = 97] = "allOutputsAllUtxos";
  SigningSerializationType2[SigningSerializationType2["allOutputsSingleInput"] = 193] = "allOutputsSingleInput";
  SigningSerializationType2[SigningSerializationType2["correspondingOutput"] = 67] = "correspondingOutput";
  SigningSerializationType2[SigningSerializationType2["correspondingOutputAllUtxos"] = 99] = "correspondingOutputAllUtxos";
  SigningSerializationType2[SigningSerializationType2["correspondingOutputSingleInput"] = 195] = "correspondingOutputSingleInput";
  SigningSerializationType2[SigningSerializationType2["noOutputs"] = 66] = "noOutputs";
  SigningSerializationType2[SigningSerializationType2["noOutputsAllUtxos"] = 98] = "noOutputsAllUtxos";
  SigningSerializationType2[SigningSerializationType2["noOutputsSingleInput"] = 194] = "noOutputsSingleInput";
})(SigningSerializationType || (SigningSerializationType = {}));
var SigningSerializationTypeBCH = SigningSerializationType;
var match = (type, flag) => (
  // eslint-disable-next-line no-bitwise, @typescript-eslint/no-non-null-assertion
  (type[0] & flag) !== 0
);
var equals = (type, flag) => (type[0] & 31) === flag;
var shouldSerializeSingleInput = (type) => match(type, SigningSerializationFlag.singleInput);
var shouldSerializeCorrespondingOutput = (type) => equals(type, SigningSerializationFlag.correspondingOutput);
var shouldSerializeNoOutputs = (type) => equals(type, SigningSerializationFlag.noOutputs);
var shouldSerializeUtxos = (type) => match(type, SigningSerializationFlag.utxos);
var emptyHash = () => new Uint8Array(
  32
  /* Internal.sha256HashByteLength */
).fill(0);
var hashPrevouts = ({ signingSerializationType, transactionOutpoints }, sha2562 = sha256) => shouldSerializeSingleInput(signingSerializationType) ? emptyHash() : hash256(transactionOutpoints, sha2562);
var hashUtxos = ({ signingSerializationType, transactionUtxos }, sha2562 = sha256) => shouldSerializeUtxos(signingSerializationType) ? hash256(transactionUtxos, sha2562) : Uint8Array.of();
var hashSequence = ({ signingSerializationType, transactionSequenceNumbers }, sha2562 = sha256) => !shouldSerializeSingleInput(signingSerializationType) && !shouldSerializeCorrespondingOutput(signingSerializationType) && !shouldSerializeNoOutputs(signingSerializationType) ? hash256(transactionSequenceNumbers, sha2562) : emptyHash();
var hashOutputs = ({ correspondingOutput, signingSerializationType, transactionOutputs }, sha2562 = sha256) => !shouldSerializeCorrespondingOutput(signingSerializationType) && !shouldSerializeNoOutputs(signingSerializationType) ? hash256(transactionOutputs, sha2562) : shouldSerializeCorrespondingOutput(signingSerializationType) ? correspondingOutput === void 0 ? emptyHash() : hash256(correspondingOutput, sha2562) : emptyHash();
var encodeSigningSerializationBCH = ({ correspondingOutput, coveredBytecode, forkId = new Uint8Array([0, 0, 0]), locktime, outpointIndex, outpointTransactionHash, outputTokenPrefix, outputValue, sequenceNumber, signingSerializationType, transactionOutpoints, transactionOutputs, transactionSequenceNumbers, transactionUtxos, version }, sha2562 = sha256) => flattenBinArray([
  numberToBinUint32LE(version),
  hashPrevouts({ signingSerializationType, transactionOutpoints }, sha2562),
  hashUtxos({ signingSerializationType, transactionUtxos }, sha2562),
  hashSequence({
    signingSerializationType,
    transactionSequenceNumbers
  }, sha2562),
  outpointTransactionHash.slice().reverse(),
  numberToBinUint32LE(outpointIndex),
  outputTokenPrefix,
  bigIntToCompactSize(BigInt(coveredBytecode.length)),
  coveredBytecode,
  outputValue,
  numberToBinUint32LE(sequenceNumber),
  hashOutputs({
    correspondingOutput,
    signingSerializationType,
    transactionOutputs
  }, sha2562),
  numberToBinUint32LE(locktime),
  signingSerializationType,
  forkId
]);
var generateSigningSerializationComponentsBCH = (context) => ({
  correspondingOutput: context.inputIndex < context.transaction.outputs.length ? encodeTransactionOutput(
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    context.transaction.outputs[context.inputIndex]
  ) : void 0,
  locktime: context.transaction.locktime,
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  outpointIndex: context.transaction.inputs[context.inputIndex].outpointIndex,
  outpointTransactionHash: (
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    context.transaction.inputs[context.inputIndex].outpointTransactionHash
  ),
  outputTokenPrefix: encodeTokenPrefix(
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    context.sourceOutputs[context.inputIndex].token
  ),
  outputValue: valueSatoshisToBin(
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    context.sourceOutputs[context.inputIndex].valueSatoshis
  ),
  sequenceNumber: (
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    context.transaction.inputs[context.inputIndex].sequenceNumber
  ),
  transactionOutpoints: encodeTransactionOutpoints(context.transaction.inputs),
  transactionOutputs: encodeTransactionOutputsForSigning(context.transaction.outputs),
  transactionSequenceNumbers: encodeTransactionInputSequenceNumbersForSigning(context.transaction.inputs),
  transactionUtxos: encodeTransactionOutputsForSigning(context.sourceOutputs),
  version: context.transaction.version
});
var generateSigningSerializationBCH = (context, { coveredBytecode, signingSerializationType }, sha2562 = sha256) => encodeSigningSerializationBCH({
  ...generateSigningSerializationComponentsBCH(context),
  coveredBytecode,
  signingSerializationType
}, sha2562);
var isLegacySigningSerialization = (signingSerializationType) => {
  const forkValue = signingSerializationType >> 8;
  const newForkValue = forkValue ^ 57005 | 16711680;
  const sighashType = newForkValue << 8 | signingSerializationType & 255;
  return (sighashType & SigningSerializationFlag.forkId) === 0;
};

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/common/consensus.js
var ConsensusCommon;
(function(ConsensusCommon2) {
  ConsensusCommon2[ConsensusCommon2["maximumBytecodeLength"] = 1e4] = "maximumBytecodeLength";
  ConsensusCommon2[ConsensusCommon2["maximumDataCarrierBytes"] = 223] = "maximumDataCarrierBytes";
  ConsensusCommon2[ConsensusCommon2["maximumOperationCount"] = 201] = "maximumOperationCount";
  ConsensusCommon2[ConsensusCommon2["maximumStackDepth"] = 1e3] = "maximumStackDepth";
  ConsensusCommon2[ConsensusCommon2["maximumStackItemLength"] = 520] = "maximumStackItemLength";
  ConsensusCommon2[ConsensusCommon2["maximumStandardVersion"] = 2] = "maximumStandardVersion";
  ConsensusCommon2[ConsensusCommon2["maximumStandardUnlockingBytecodeLength"] = 1650] = "maximumStandardUnlockingBytecodeLength";
  ConsensusCommon2[ConsensusCommon2["minimumTransactionSize"] = 100] = "minimumTransactionSize";
  ConsensusCommon2[ConsensusCommon2["maximumStandardTransactionSize"] = 1e5] = "maximumStandardTransactionSize";
  ConsensusCommon2[ConsensusCommon2["maximumTransactionSize"] = 1e6] = "maximumTransactionSize";
  ConsensusCommon2[ConsensusCommon2["maximumVmNumberLength"] = 8] = "maximumVmNumberLength";
  ConsensusCommon2["minVmNumber"] = "-9223372036854775807";
  ConsensusCommon2["maxVmNumber"] = "9223372036854775807";
  ConsensusCommon2[ConsensusCommon2["schnorrSignatureLength"] = 64] = "schnorrSignatureLength";
})(ConsensusCommon || (ConsensusCommon = {}));
var SigningSerializationTypesCommon = [
  SigningSerializationTypeBCH.allOutputs,
  SigningSerializationTypeBCH.allOutputsSingleInput,
  SigningSerializationTypeBCH.correspondingOutput,
  SigningSerializationTypeBCH.correspondingOutputSingleInput,
  SigningSerializationTypeBCH.noOutputs,
  SigningSerializationTypeBCH.noOutputsSingleInput
];
var SigningSerializationTypesBCH = SigningSerializationTypesCommon;
var ConsensusBCH = ConsensusCommon;

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/common/errors.js
var import_dist145 = __toESM(require_dist(), 1);
var import_dist146 = __toESM(require_dist2(), 1);
var import_dist147 = __toESM(require_dist3(), 1);
var AuthenticationErrorCommon;
(function(AuthenticationErrorCommon2) {
  AuthenticationErrorCommon2["calledReserved"] = "Program called an unassigned, reserved operation.";
  AuthenticationErrorCommon2["calledReturn"] = "Program called an OP_RETURN operation.";
  AuthenticationErrorCommon2["calledUpgradableNop"] = "Program called a disallowed upgradable non-operation (OP_NOP1-OP_NOP10).";
  AuthenticationErrorCommon2["checkSequenceUnavailable"] = "Program called an OP_CHECKSEQUENCEVERIFY operation, but OP_CHECKSEQUENCEVERIFY requires transaction version 2 or higher.";
  AuthenticationErrorCommon2["disabledOpcode"] = "Program contains a disabled opcode.";
  AuthenticationErrorCommon2["divisionByZero"] = "Program attempted to divide a number by zero.";
  AuthenticationErrorCommon2["emptyAlternateStack"] = "Tried to read from an empty alternate stack.";
  AuthenticationErrorCommon2["emptyStack"] = "Tried to read from an empty stack.";
  AuthenticationErrorCommon2["exceededMaximumBytecodeLengthLocking"] = "The provided locking bytecode exceeds the maximum bytecode length (10,000 bytes).";
  AuthenticationErrorCommon2["exceededMaximumBytecodeLengthUnlocking"] = "The provided unlocking bytecode exceeds the maximum bytecode length (10,000 bytes).";
  AuthenticationErrorCommon2["exceededMaximumVmNumberLength"] = "Program attempted an OP_BIN2NUM operation on a byte sequence that cannot be encoded within the maximum VM Number length.";
  AuthenticationErrorCommon2["exceededMaximumStackDepth"] = "Program exceeded the maximum stack depth (1,000 items).";
  AuthenticationErrorCommon2["exceededMaximumStackItemLength"] = "Program attempted to push a stack item that exceeded the maximum stack item length (520 bytes).";
  AuthenticationErrorCommon2["exceededMaximumOperationCount"] = "Program exceeded the maximum operation count (201 operations).";
  AuthenticationErrorCommon2["exceedsMaximumMultisigPublicKeyCount"] = "Program called an OP_CHECKMULTISIG that exceeds the maximum public key count (20 public keys).";
  AuthenticationErrorCommon2["failedVerify"] = "Program failed an OP_VERIFY operation.";
  AuthenticationErrorCommon2["invalidStackIndex"] = "Tried to read from an invalid stack index.";
  AuthenticationErrorCommon2["incompatibleLocktimeType"] = "Program called an OP_CHECKLOCKTIMEVERIFY operation with an incompatible locktime type. The transaction locktime and required locktime must both refer to either a block height or a block time.";
  AuthenticationErrorCommon2["incompatibleSequenceType"] = "Program called an OP_CHECKSEQUENCEVERIFY operation with an incompatible sequence type flag. The input sequence number and required sequence number must both use the same sequence locktime type.";
  AuthenticationErrorCommon2["insufficientLength"] = "Program called an OP_NUM2BIN operation with an insufficient byte length to re-encode the provided number.";
  AuthenticationErrorCommon2["insufficientPublicKeys"] = "Program called an OP_CHECKMULTISIG operation that requires signatures from more public keys than are provided.";
  AuthenticationErrorCommon2["invalidNaturalNumber"] = "Invalid input: the key/signature count inputs for OP_CHECKMULTISIG require a natural number (n > 0).";
  AuthenticationErrorCommon2["invalidProtocolBugValue"] = 'The OP_CHECKMULTISIG protocol bug value must be a VM Number 0 (to comply with the "NULLDUMMY" rule).';
  AuthenticationErrorCommon2["invalidPublicKeyEncoding"] = "Encountered an improperly encoded public key.";
  AuthenticationErrorCommon2["invalidVmNumber"] = "Invalid input: this operation requires a valid VM Number.";
  AuthenticationErrorCommon2["invalidSignatureEncoding"] = "Encountered an improperly encoded signature.";
  AuthenticationErrorCommon2["invalidSplitIndex"] = "Program called an OP_SPLIT operation with an invalid index.";
  AuthenticationErrorCommon2["invalidTransactionInputIndex"] = "Program attempted to read from an invalid transaction input index.";
  AuthenticationErrorCommon2["invalidTransactionOutputIndex"] = "Program attempted to read from an invalid transaction output index.";
  AuthenticationErrorCommon2["invalidTransactionUtxoIndex"] = "Program attempted to read from an invalid transaction UTXO index.";
  AuthenticationErrorCommon2["locktimeDisabled"] = "Program called an OP_CHECKLOCKTIMEVERIFY operation, but locktime is disabled for this transaction.";
  AuthenticationErrorCommon2["mismatchedBitwiseOperandLength"] = "Program attempted a bitwise operation on operands of different lengths.";
  AuthenticationErrorCommon2["malformedLockingBytecode"] = "The provided locking bytecode is malformed.";
  AuthenticationErrorCommon2["malformedP2shBytecode"] = "Redeem bytecode was malformed prior to P2SH evaluation.";
  AuthenticationErrorCommon2["malformedPush"] = "Program must be long enough to push the requested number of bytes.";
  AuthenticationErrorCommon2["malformedUnlockingBytecode"] = "The provided unlocking bytecode is malformed.";
  AuthenticationErrorCommon2["negativeLocktime"] = "Program called an OP_CHECKLOCKTIMEVERIFY or OP_CHECKSEQUENCEVERIFY operation with a negative locktime.";
  AuthenticationErrorCommon2["nonEmptyControlStack"] = "The active bytecode completed with a non-empty control stack (missing `OP_ENDIF`).";
  AuthenticationErrorCommon2["nonMinimalPush"] = "Push operations must use the smallest possible encoding.";
  AuthenticationErrorCommon2["nonNullSignatureFailure"] = 'Program failed a signature verification with a non-null signature (violating the "NULLFAIL" rule).';
  AuthenticationErrorCommon2["overflowsVmNumberRange"] = "Program attempted an arithmetic operation which exceeds the range of VM Numbers.";
  AuthenticationErrorCommon2["requiresCleanStack"] = "Program completed with an unexpected number of items on the stack (must be exactly 1).";
  AuthenticationErrorCommon2["requiresPushOnly"] = "Unlocking bytecode may contain only push operations.";
  AuthenticationErrorCommon2["schnorrSizedSignatureInCheckMultiSig"] = "Program used a schnorr-sized signature (65 bytes) in an OP_CHECKMULTISIG operation.";
  AuthenticationErrorCommon2["unexpectedElse"] = "Encountered an OP_ELSE outside of an OP_IF ... OP_ENDIF block.";
  AuthenticationErrorCommon2["unexpectedEndIf"] = "Encountered an OP_ENDIF that is not following a matching OP_IF.";
  AuthenticationErrorCommon2["unknownOpcode"] = "Called an unknown opcode.";
  AuthenticationErrorCommon2["unmatchedSequenceDisable"] = "Program called an OP_CHECKSEQUENCEVERIFY operation requiring the disable flag, but the input's sequence number is missing the disable flag.";
  AuthenticationErrorCommon2["unsatisfiedLocktime"] = "Program called an OP_CHECKLOCKTIMEVERIFY operation that requires a locktime greater than the transaction's locktime.";
  AuthenticationErrorCommon2["unsatisfiedSequenceNumber"] = "Program called an OP_CHECKSEQUENCEVERIFY operation that requires a sequence number greater than the input's sequence number.";
  AuthenticationErrorCommon2["unsuccessfulEvaluation"] = "Unsuccessful evaluation: completed with a non-truthy value on top of the stack.";
})(AuthenticationErrorCommon || (AuthenticationErrorCommon = {}));
var applyError = (state, errorType, errorDetails) => ({
  ...state,
  error: state.error === void 0 ? formatError(errorType, errorDetails) : state.error
});

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/common/instruction-sets-utils.js
var import_dist154 = __toESM(require_dist(), 1);
var import_dist155 = __toESM(require_dist2(), 1);
var import_dist156 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/bch/2023/bch-2023-opcodes.js
var import_dist148 = __toESM(require_dist(), 1);
var import_dist149 = __toESM(require_dist2(), 1);
var import_dist150 = __toESM(require_dist3(), 1);
var OpcodesBCH2023;
(function(OpcodesBCH20232) {
  OpcodesBCH20232[OpcodesBCH20232["OP_0"] = 0] = "OP_0";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_1"] = 1] = "OP_PUSHBYTES_1";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_2"] = 2] = "OP_PUSHBYTES_2";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_3"] = 3] = "OP_PUSHBYTES_3";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_4"] = 4] = "OP_PUSHBYTES_4";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_5"] = 5] = "OP_PUSHBYTES_5";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_6"] = 6] = "OP_PUSHBYTES_6";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_7"] = 7] = "OP_PUSHBYTES_7";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_8"] = 8] = "OP_PUSHBYTES_8";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_9"] = 9] = "OP_PUSHBYTES_9";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_10"] = 10] = "OP_PUSHBYTES_10";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_11"] = 11] = "OP_PUSHBYTES_11";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_12"] = 12] = "OP_PUSHBYTES_12";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_13"] = 13] = "OP_PUSHBYTES_13";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_14"] = 14] = "OP_PUSHBYTES_14";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_15"] = 15] = "OP_PUSHBYTES_15";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_16"] = 16] = "OP_PUSHBYTES_16";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_17"] = 17] = "OP_PUSHBYTES_17";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_18"] = 18] = "OP_PUSHBYTES_18";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_19"] = 19] = "OP_PUSHBYTES_19";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_20"] = 20] = "OP_PUSHBYTES_20";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_21"] = 21] = "OP_PUSHBYTES_21";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_22"] = 22] = "OP_PUSHBYTES_22";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_23"] = 23] = "OP_PUSHBYTES_23";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_24"] = 24] = "OP_PUSHBYTES_24";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_25"] = 25] = "OP_PUSHBYTES_25";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_26"] = 26] = "OP_PUSHBYTES_26";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_27"] = 27] = "OP_PUSHBYTES_27";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_28"] = 28] = "OP_PUSHBYTES_28";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_29"] = 29] = "OP_PUSHBYTES_29";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_30"] = 30] = "OP_PUSHBYTES_30";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_31"] = 31] = "OP_PUSHBYTES_31";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_32"] = 32] = "OP_PUSHBYTES_32";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_33"] = 33] = "OP_PUSHBYTES_33";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_34"] = 34] = "OP_PUSHBYTES_34";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_35"] = 35] = "OP_PUSHBYTES_35";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_36"] = 36] = "OP_PUSHBYTES_36";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_37"] = 37] = "OP_PUSHBYTES_37";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_38"] = 38] = "OP_PUSHBYTES_38";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_39"] = 39] = "OP_PUSHBYTES_39";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_40"] = 40] = "OP_PUSHBYTES_40";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_41"] = 41] = "OP_PUSHBYTES_41";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_42"] = 42] = "OP_PUSHBYTES_42";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_43"] = 43] = "OP_PUSHBYTES_43";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_44"] = 44] = "OP_PUSHBYTES_44";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_45"] = 45] = "OP_PUSHBYTES_45";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_46"] = 46] = "OP_PUSHBYTES_46";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_47"] = 47] = "OP_PUSHBYTES_47";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_48"] = 48] = "OP_PUSHBYTES_48";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_49"] = 49] = "OP_PUSHBYTES_49";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_50"] = 50] = "OP_PUSHBYTES_50";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_51"] = 51] = "OP_PUSHBYTES_51";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_52"] = 52] = "OP_PUSHBYTES_52";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_53"] = 53] = "OP_PUSHBYTES_53";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_54"] = 54] = "OP_PUSHBYTES_54";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_55"] = 55] = "OP_PUSHBYTES_55";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_56"] = 56] = "OP_PUSHBYTES_56";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_57"] = 57] = "OP_PUSHBYTES_57";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_58"] = 58] = "OP_PUSHBYTES_58";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_59"] = 59] = "OP_PUSHBYTES_59";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_60"] = 60] = "OP_PUSHBYTES_60";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_61"] = 61] = "OP_PUSHBYTES_61";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_62"] = 62] = "OP_PUSHBYTES_62";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_63"] = 63] = "OP_PUSHBYTES_63";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_64"] = 64] = "OP_PUSHBYTES_64";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_65"] = 65] = "OP_PUSHBYTES_65";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_66"] = 66] = "OP_PUSHBYTES_66";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_67"] = 67] = "OP_PUSHBYTES_67";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_68"] = 68] = "OP_PUSHBYTES_68";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_69"] = 69] = "OP_PUSHBYTES_69";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_70"] = 70] = "OP_PUSHBYTES_70";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_71"] = 71] = "OP_PUSHBYTES_71";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_72"] = 72] = "OP_PUSHBYTES_72";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_73"] = 73] = "OP_PUSHBYTES_73";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_74"] = 74] = "OP_PUSHBYTES_74";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHBYTES_75"] = 75] = "OP_PUSHBYTES_75";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHDATA_1"] = 76] = "OP_PUSHDATA_1";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHDATA_2"] = 77] = "OP_PUSHDATA_2";
  OpcodesBCH20232[OpcodesBCH20232["OP_PUSHDATA_4"] = 78] = "OP_PUSHDATA_4";
  OpcodesBCH20232[OpcodesBCH20232["OP_1NEGATE"] = 79] = "OP_1NEGATE";
  OpcodesBCH20232[OpcodesBCH20232["OP_RESERVED"] = 80] = "OP_RESERVED";
  OpcodesBCH20232[OpcodesBCH20232["OP_1"] = 81] = "OP_1";
  OpcodesBCH20232[OpcodesBCH20232["OP_2"] = 82] = "OP_2";
  OpcodesBCH20232[OpcodesBCH20232["OP_3"] = 83] = "OP_3";
  OpcodesBCH20232[OpcodesBCH20232["OP_4"] = 84] = "OP_4";
  OpcodesBCH20232[OpcodesBCH20232["OP_5"] = 85] = "OP_5";
  OpcodesBCH20232[OpcodesBCH20232["OP_6"] = 86] = "OP_6";
  OpcodesBCH20232[OpcodesBCH20232["OP_7"] = 87] = "OP_7";
  OpcodesBCH20232[OpcodesBCH20232["OP_8"] = 88] = "OP_8";
  OpcodesBCH20232[OpcodesBCH20232["OP_9"] = 89] = "OP_9";
  OpcodesBCH20232[OpcodesBCH20232["OP_10"] = 90] = "OP_10";
  OpcodesBCH20232[OpcodesBCH20232["OP_11"] = 91] = "OP_11";
  OpcodesBCH20232[OpcodesBCH20232["OP_12"] = 92] = "OP_12";
  OpcodesBCH20232[OpcodesBCH20232["OP_13"] = 93] = "OP_13";
  OpcodesBCH20232[OpcodesBCH20232["OP_14"] = 94] = "OP_14";
  OpcodesBCH20232[OpcodesBCH20232["OP_15"] = 95] = "OP_15";
  OpcodesBCH20232[OpcodesBCH20232["OP_16"] = 96] = "OP_16";
  OpcodesBCH20232[OpcodesBCH20232["OP_NOP"] = 97] = "OP_NOP";
  OpcodesBCH20232[OpcodesBCH20232["OP_VER"] = 98] = "OP_VER";
  OpcodesBCH20232[OpcodesBCH20232["OP_IF"] = 99] = "OP_IF";
  OpcodesBCH20232[OpcodesBCH20232["OP_NOTIF"] = 100] = "OP_NOTIF";
  OpcodesBCH20232[OpcodesBCH20232["OP_VERIF"] = 101] = "OP_VERIF";
  OpcodesBCH20232[OpcodesBCH20232["OP_VERNOTIF"] = 102] = "OP_VERNOTIF";
  OpcodesBCH20232[OpcodesBCH20232["OP_ELSE"] = 103] = "OP_ELSE";
  OpcodesBCH20232[OpcodesBCH20232["OP_ENDIF"] = 104] = "OP_ENDIF";
  OpcodesBCH20232[OpcodesBCH20232["OP_VERIFY"] = 105] = "OP_VERIFY";
  OpcodesBCH20232[OpcodesBCH20232["OP_RETURN"] = 106] = "OP_RETURN";
  OpcodesBCH20232[OpcodesBCH20232["OP_TOALTSTACK"] = 107] = "OP_TOALTSTACK";
  OpcodesBCH20232[OpcodesBCH20232["OP_FROMALTSTACK"] = 108] = "OP_FROMALTSTACK";
  OpcodesBCH20232[OpcodesBCH20232["OP_2DROP"] = 109] = "OP_2DROP";
  OpcodesBCH20232[OpcodesBCH20232["OP_2DUP"] = 110] = "OP_2DUP";
  OpcodesBCH20232[OpcodesBCH20232["OP_3DUP"] = 111] = "OP_3DUP";
  OpcodesBCH20232[OpcodesBCH20232["OP_2OVER"] = 112] = "OP_2OVER";
  OpcodesBCH20232[OpcodesBCH20232["OP_2ROT"] = 113] = "OP_2ROT";
  OpcodesBCH20232[OpcodesBCH20232["OP_2SWAP"] = 114] = "OP_2SWAP";
  OpcodesBCH20232[OpcodesBCH20232["OP_IFDUP"] = 115] = "OP_IFDUP";
  OpcodesBCH20232[OpcodesBCH20232["OP_DEPTH"] = 116] = "OP_DEPTH";
  OpcodesBCH20232[OpcodesBCH20232["OP_DROP"] = 117] = "OP_DROP";
  OpcodesBCH20232[OpcodesBCH20232["OP_DUP"] = 118] = "OP_DUP";
  OpcodesBCH20232[OpcodesBCH20232["OP_NIP"] = 119] = "OP_NIP";
  OpcodesBCH20232[OpcodesBCH20232["OP_OVER"] = 120] = "OP_OVER";
  OpcodesBCH20232[OpcodesBCH20232["OP_PICK"] = 121] = "OP_PICK";
  OpcodesBCH20232[OpcodesBCH20232["OP_ROLL"] = 122] = "OP_ROLL";
  OpcodesBCH20232[OpcodesBCH20232["OP_ROT"] = 123] = "OP_ROT";
  OpcodesBCH20232[OpcodesBCH20232["OP_SWAP"] = 124] = "OP_SWAP";
  OpcodesBCH20232[OpcodesBCH20232["OP_TUCK"] = 125] = "OP_TUCK";
  OpcodesBCH20232[OpcodesBCH20232["OP_CAT"] = 126] = "OP_CAT";
  OpcodesBCH20232[OpcodesBCH20232["OP_SPLIT"] = 127] = "OP_SPLIT";
  OpcodesBCH20232[OpcodesBCH20232["OP_NUM2BIN"] = 128] = "OP_NUM2BIN";
  OpcodesBCH20232[OpcodesBCH20232["OP_BIN2NUM"] = 129] = "OP_BIN2NUM";
  OpcodesBCH20232[OpcodesBCH20232["OP_SIZE"] = 130] = "OP_SIZE";
  OpcodesBCH20232[OpcodesBCH20232["OP_INVERT"] = 131] = "OP_INVERT";
  OpcodesBCH20232[OpcodesBCH20232["OP_AND"] = 132] = "OP_AND";
  OpcodesBCH20232[OpcodesBCH20232["OP_OR"] = 133] = "OP_OR";
  OpcodesBCH20232[OpcodesBCH20232["OP_XOR"] = 134] = "OP_XOR";
  OpcodesBCH20232[OpcodesBCH20232["OP_EQUAL"] = 135] = "OP_EQUAL";
  OpcodesBCH20232[OpcodesBCH20232["OP_EQUALVERIFY"] = 136] = "OP_EQUALVERIFY";
  OpcodesBCH20232[OpcodesBCH20232["OP_RESERVED1"] = 137] = "OP_RESERVED1";
  OpcodesBCH20232[OpcodesBCH20232["OP_RESERVED2"] = 138] = "OP_RESERVED2";
  OpcodesBCH20232[OpcodesBCH20232["OP_1ADD"] = 139] = "OP_1ADD";
  OpcodesBCH20232[OpcodesBCH20232["OP_1SUB"] = 140] = "OP_1SUB";
  OpcodesBCH20232[OpcodesBCH20232["OP_2MUL"] = 141] = "OP_2MUL";
  OpcodesBCH20232[OpcodesBCH20232["OP_2DIV"] = 142] = "OP_2DIV";
  OpcodesBCH20232[OpcodesBCH20232["OP_NEGATE"] = 143] = "OP_NEGATE";
  OpcodesBCH20232[OpcodesBCH20232["OP_ABS"] = 144] = "OP_ABS";
  OpcodesBCH20232[OpcodesBCH20232["OP_NOT"] = 145] = "OP_NOT";
  OpcodesBCH20232[OpcodesBCH20232["OP_0NOTEQUAL"] = 146] = "OP_0NOTEQUAL";
  OpcodesBCH20232[OpcodesBCH20232["OP_ADD"] = 147] = "OP_ADD";
  OpcodesBCH20232[OpcodesBCH20232["OP_SUB"] = 148] = "OP_SUB";
  OpcodesBCH20232[OpcodesBCH20232["OP_MUL"] = 149] = "OP_MUL";
  OpcodesBCH20232[OpcodesBCH20232["OP_DIV"] = 150] = "OP_DIV";
  OpcodesBCH20232[OpcodesBCH20232["OP_MOD"] = 151] = "OP_MOD";
  OpcodesBCH20232[OpcodesBCH20232["OP_LSHIFT"] = 152] = "OP_LSHIFT";
  OpcodesBCH20232[OpcodesBCH20232["OP_RSHIFT"] = 153] = "OP_RSHIFT";
  OpcodesBCH20232[OpcodesBCH20232["OP_BOOLAND"] = 154] = "OP_BOOLAND";
  OpcodesBCH20232[OpcodesBCH20232["OP_BOOLOR"] = 155] = "OP_BOOLOR";
  OpcodesBCH20232[OpcodesBCH20232["OP_NUMEQUAL"] = 156] = "OP_NUMEQUAL";
  OpcodesBCH20232[OpcodesBCH20232["OP_NUMEQUALVERIFY"] = 157] = "OP_NUMEQUALVERIFY";
  OpcodesBCH20232[OpcodesBCH20232["OP_NUMNOTEQUAL"] = 158] = "OP_NUMNOTEQUAL";
  OpcodesBCH20232[OpcodesBCH20232["OP_LESSTHAN"] = 159] = "OP_LESSTHAN";
  OpcodesBCH20232[OpcodesBCH20232["OP_GREATERTHAN"] = 160] = "OP_GREATERTHAN";
  OpcodesBCH20232[OpcodesBCH20232["OP_LESSTHANOREQUAL"] = 161] = "OP_LESSTHANOREQUAL";
  OpcodesBCH20232[OpcodesBCH20232["OP_GREATERTHANOREQUAL"] = 162] = "OP_GREATERTHANOREQUAL";
  OpcodesBCH20232[OpcodesBCH20232["OP_MIN"] = 163] = "OP_MIN";
  OpcodesBCH20232[OpcodesBCH20232["OP_MAX"] = 164] = "OP_MAX";
  OpcodesBCH20232[OpcodesBCH20232["OP_WITHIN"] = 165] = "OP_WITHIN";
  OpcodesBCH20232[OpcodesBCH20232["OP_RIPEMD160"] = 166] = "OP_RIPEMD160";
  OpcodesBCH20232[OpcodesBCH20232["OP_SHA1"] = 167] = "OP_SHA1";
  OpcodesBCH20232[OpcodesBCH20232["OP_SHA256"] = 168] = "OP_SHA256";
  OpcodesBCH20232[OpcodesBCH20232["OP_HASH160"] = 169] = "OP_HASH160";
  OpcodesBCH20232[OpcodesBCH20232["OP_HASH256"] = 170] = "OP_HASH256";
  OpcodesBCH20232[OpcodesBCH20232["OP_CODESEPARATOR"] = 171] = "OP_CODESEPARATOR";
  OpcodesBCH20232[OpcodesBCH20232["OP_CHECKSIG"] = 172] = "OP_CHECKSIG";
  OpcodesBCH20232[OpcodesBCH20232["OP_CHECKSIGVERIFY"] = 173] = "OP_CHECKSIGVERIFY";
  OpcodesBCH20232[OpcodesBCH20232["OP_CHECKMULTISIG"] = 174] = "OP_CHECKMULTISIG";
  OpcodesBCH20232[OpcodesBCH20232["OP_CHECKMULTISIGVERIFY"] = 175] = "OP_CHECKMULTISIGVERIFY";
  OpcodesBCH20232[OpcodesBCH20232["OP_NOP1"] = 176] = "OP_NOP1";
  OpcodesBCH20232[OpcodesBCH20232["OP_CHECKLOCKTIMEVERIFY"] = 177] = "OP_CHECKLOCKTIMEVERIFY";
  OpcodesBCH20232[OpcodesBCH20232["OP_CHECKSEQUENCEVERIFY"] = 178] = "OP_CHECKSEQUENCEVERIFY";
  OpcodesBCH20232[OpcodesBCH20232["OP_NOP4"] = 179] = "OP_NOP4";
  OpcodesBCH20232[OpcodesBCH20232["OP_NOP5"] = 180] = "OP_NOP5";
  OpcodesBCH20232[OpcodesBCH20232["OP_NOP6"] = 181] = "OP_NOP6";
  OpcodesBCH20232[OpcodesBCH20232["OP_NOP7"] = 182] = "OP_NOP7";
  OpcodesBCH20232[OpcodesBCH20232["OP_NOP8"] = 183] = "OP_NOP8";
  OpcodesBCH20232[OpcodesBCH20232["OP_NOP9"] = 184] = "OP_NOP9";
  OpcodesBCH20232[OpcodesBCH20232["OP_NOP10"] = 185] = "OP_NOP10";
  OpcodesBCH20232[OpcodesBCH20232["OP_CHECKDATASIG"] = 186] = "OP_CHECKDATASIG";
  OpcodesBCH20232[OpcodesBCH20232["OP_CHECKDATASIGVERIFY"] = 187] = "OP_CHECKDATASIGVERIFY";
  OpcodesBCH20232[OpcodesBCH20232["OP_REVERSEBYTES"] = 188] = "OP_REVERSEBYTES";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN189"] = 189] = "OP_UNKNOWN189";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN190"] = 190] = "OP_UNKNOWN190";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN191"] = 191] = "OP_UNKNOWN191";
  OpcodesBCH20232[OpcodesBCH20232["OP_INPUTINDEX"] = 192] = "OP_INPUTINDEX";
  OpcodesBCH20232[OpcodesBCH20232["OP_ACTIVEBYTECODE"] = 193] = "OP_ACTIVEBYTECODE";
  OpcodesBCH20232[OpcodesBCH20232["OP_TXVERSION"] = 194] = "OP_TXVERSION";
  OpcodesBCH20232[OpcodesBCH20232["OP_TXINPUTCOUNT"] = 195] = "OP_TXINPUTCOUNT";
  OpcodesBCH20232[OpcodesBCH20232["OP_TXOUTPUTCOUNT"] = 196] = "OP_TXOUTPUTCOUNT";
  OpcodesBCH20232[OpcodesBCH20232["OP_TXLOCKTIME"] = 197] = "OP_TXLOCKTIME";
  OpcodesBCH20232[OpcodesBCH20232["OP_UTXOVALUE"] = 198] = "OP_UTXOVALUE";
  OpcodesBCH20232[OpcodesBCH20232["OP_UTXOBYTECODE"] = 199] = "OP_UTXOBYTECODE";
  OpcodesBCH20232[OpcodesBCH20232["OP_OUTPOINTTXHASH"] = 200] = "OP_OUTPOINTTXHASH";
  OpcodesBCH20232[OpcodesBCH20232["OP_OUTPOINTINDEX"] = 201] = "OP_OUTPOINTINDEX";
  OpcodesBCH20232[OpcodesBCH20232["OP_INPUTBYTECODE"] = 202] = "OP_INPUTBYTECODE";
  OpcodesBCH20232[OpcodesBCH20232["OP_INPUTSEQUENCENUMBER"] = 203] = "OP_INPUTSEQUENCENUMBER";
  OpcodesBCH20232[OpcodesBCH20232["OP_OUTPUTVALUE"] = 204] = "OP_OUTPUTVALUE";
  OpcodesBCH20232[OpcodesBCH20232["OP_OUTPUTBYTECODE"] = 205] = "OP_OUTPUTBYTECODE";
  OpcodesBCH20232[OpcodesBCH20232["OP_UTXOTOKENCATEGORY"] = 206] = "OP_UTXOTOKENCATEGORY";
  OpcodesBCH20232[OpcodesBCH20232["OP_UTXOTOKENCOMMITMENT"] = 207] = "OP_UTXOTOKENCOMMITMENT";
  OpcodesBCH20232[OpcodesBCH20232["OP_UTXOTOKENAMOUNT"] = 208] = "OP_UTXOTOKENAMOUNT";
  OpcodesBCH20232[OpcodesBCH20232["OP_OUTPUTTOKENCATEGORY"] = 209] = "OP_OUTPUTTOKENCATEGORY";
  OpcodesBCH20232[OpcodesBCH20232["OP_OUTPUTTOKENCOMMITMENT"] = 210] = "OP_OUTPUTTOKENCOMMITMENT";
  OpcodesBCH20232[OpcodesBCH20232["OP_OUTPUTTOKENAMOUNT"] = 211] = "OP_OUTPUTTOKENAMOUNT";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN212"] = 212] = "OP_UNKNOWN212";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN213"] = 213] = "OP_UNKNOWN213";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN214"] = 214] = "OP_UNKNOWN214";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN215"] = 215] = "OP_UNKNOWN215";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN216"] = 216] = "OP_UNKNOWN216";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN217"] = 217] = "OP_UNKNOWN217";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN218"] = 218] = "OP_UNKNOWN218";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN219"] = 219] = "OP_UNKNOWN219";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN220"] = 220] = "OP_UNKNOWN220";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN221"] = 221] = "OP_UNKNOWN221";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN222"] = 222] = "OP_UNKNOWN222";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN223"] = 223] = "OP_UNKNOWN223";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN224"] = 224] = "OP_UNKNOWN224";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN225"] = 225] = "OP_UNKNOWN225";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN226"] = 226] = "OP_UNKNOWN226";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN227"] = 227] = "OP_UNKNOWN227";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN228"] = 228] = "OP_UNKNOWN228";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN229"] = 229] = "OP_UNKNOWN229";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN230"] = 230] = "OP_UNKNOWN230";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN231"] = 231] = "OP_UNKNOWN231";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN232"] = 232] = "OP_UNKNOWN232";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN233"] = 233] = "OP_UNKNOWN233";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN234"] = 234] = "OP_UNKNOWN234";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN235"] = 235] = "OP_UNKNOWN235";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN236"] = 236] = "OP_UNKNOWN236";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN237"] = 237] = "OP_UNKNOWN237";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN238"] = 238] = "OP_UNKNOWN238";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN239"] = 239] = "OP_UNKNOWN239";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN240"] = 240] = "OP_UNKNOWN240";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN241"] = 241] = "OP_UNKNOWN241";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN242"] = 242] = "OP_UNKNOWN242";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN243"] = 243] = "OP_UNKNOWN243";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN244"] = 244] = "OP_UNKNOWN244";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN245"] = 245] = "OP_UNKNOWN245";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN246"] = 246] = "OP_UNKNOWN246";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN247"] = 247] = "OP_UNKNOWN247";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN248"] = 248] = "OP_UNKNOWN248";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN249"] = 249] = "OP_UNKNOWN249";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN250"] = 250] = "OP_UNKNOWN250";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN251"] = 251] = "OP_UNKNOWN251";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN252"] = 252] = "OP_UNKNOWN252";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN253"] = 253] = "OP_UNKNOWN253";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN254"] = 254] = "OP_UNKNOWN254";
  OpcodesBCH20232[OpcodesBCH20232["OP_UNKNOWN255"] = 255] = "OP_UNKNOWN255";
})(OpcodesBCH2023 || (OpcodesBCH2023 = {}));
var OpcodesBCH = OpcodesBCH2023;
var Opcodes = OpcodesBCH;

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/btc/btc-opcodes.js
var import_dist151 = __toESM(require_dist(), 1);
var import_dist152 = __toESM(require_dist2(), 1);
var import_dist153 = __toESM(require_dist3(), 1);
var OpcodesBTC;
(function(OpcodesBTC2) {
  OpcodesBTC2[OpcodesBTC2["OP_0"] = 0] = "OP_0";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_1"] = 1] = "OP_PUSHBYTES_1";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_2"] = 2] = "OP_PUSHBYTES_2";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_3"] = 3] = "OP_PUSHBYTES_3";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_4"] = 4] = "OP_PUSHBYTES_4";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_5"] = 5] = "OP_PUSHBYTES_5";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_6"] = 6] = "OP_PUSHBYTES_6";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_7"] = 7] = "OP_PUSHBYTES_7";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_8"] = 8] = "OP_PUSHBYTES_8";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_9"] = 9] = "OP_PUSHBYTES_9";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_10"] = 10] = "OP_PUSHBYTES_10";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_11"] = 11] = "OP_PUSHBYTES_11";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_12"] = 12] = "OP_PUSHBYTES_12";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_13"] = 13] = "OP_PUSHBYTES_13";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_14"] = 14] = "OP_PUSHBYTES_14";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_15"] = 15] = "OP_PUSHBYTES_15";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_16"] = 16] = "OP_PUSHBYTES_16";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_17"] = 17] = "OP_PUSHBYTES_17";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_18"] = 18] = "OP_PUSHBYTES_18";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_19"] = 19] = "OP_PUSHBYTES_19";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_20"] = 20] = "OP_PUSHBYTES_20";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_21"] = 21] = "OP_PUSHBYTES_21";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_22"] = 22] = "OP_PUSHBYTES_22";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_23"] = 23] = "OP_PUSHBYTES_23";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_24"] = 24] = "OP_PUSHBYTES_24";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_25"] = 25] = "OP_PUSHBYTES_25";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_26"] = 26] = "OP_PUSHBYTES_26";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_27"] = 27] = "OP_PUSHBYTES_27";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_28"] = 28] = "OP_PUSHBYTES_28";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_29"] = 29] = "OP_PUSHBYTES_29";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_30"] = 30] = "OP_PUSHBYTES_30";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_31"] = 31] = "OP_PUSHBYTES_31";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_32"] = 32] = "OP_PUSHBYTES_32";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_33"] = 33] = "OP_PUSHBYTES_33";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_34"] = 34] = "OP_PUSHBYTES_34";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_35"] = 35] = "OP_PUSHBYTES_35";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_36"] = 36] = "OP_PUSHBYTES_36";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_37"] = 37] = "OP_PUSHBYTES_37";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_38"] = 38] = "OP_PUSHBYTES_38";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_39"] = 39] = "OP_PUSHBYTES_39";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_40"] = 40] = "OP_PUSHBYTES_40";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_41"] = 41] = "OP_PUSHBYTES_41";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_42"] = 42] = "OP_PUSHBYTES_42";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_43"] = 43] = "OP_PUSHBYTES_43";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_44"] = 44] = "OP_PUSHBYTES_44";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_45"] = 45] = "OP_PUSHBYTES_45";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_46"] = 46] = "OP_PUSHBYTES_46";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_47"] = 47] = "OP_PUSHBYTES_47";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_48"] = 48] = "OP_PUSHBYTES_48";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_49"] = 49] = "OP_PUSHBYTES_49";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_50"] = 50] = "OP_PUSHBYTES_50";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_51"] = 51] = "OP_PUSHBYTES_51";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_52"] = 52] = "OP_PUSHBYTES_52";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_53"] = 53] = "OP_PUSHBYTES_53";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_54"] = 54] = "OP_PUSHBYTES_54";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_55"] = 55] = "OP_PUSHBYTES_55";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_56"] = 56] = "OP_PUSHBYTES_56";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_57"] = 57] = "OP_PUSHBYTES_57";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_58"] = 58] = "OP_PUSHBYTES_58";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_59"] = 59] = "OP_PUSHBYTES_59";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_60"] = 60] = "OP_PUSHBYTES_60";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_61"] = 61] = "OP_PUSHBYTES_61";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_62"] = 62] = "OP_PUSHBYTES_62";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_63"] = 63] = "OP_PUSHBYTES_63";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_64"] = 64] = "OP_PUSHBYTES_64";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_65"] = 65] = "OP_PUSHBYTES_65";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_66"] = 66] = "OP_PUSHBYTES_66";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_67"] = 67] = "OP_PUSHBYTES_67";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_68"] = 68] = "OP_PUSHBYTES_68";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_69"] = 69] = "OP_PUSHBYTES_69";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_70"] = 70] = "OP_PUSHBYTES_70";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_71"] = 71] = "OP_PUSHBYTES_71";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_72"] = 72] = "OP_PUSHBYTES_72";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_73"] = 73] = "OP_PUSHBYTES_73";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_74"] = 74] = "OP_PUSHBYTES_74";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHBYTES_75"] = 75] = "OP_PUSHBYTES_75";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHDATA_1"] = 76] = "OP_PUSHDATA_1";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHDATA_2"] = 77] = "OP_PUSHDATA_2";
  OpcodesBTC2[OpcodesBTC2["OP_PUSHDATA_4"] = 78] = "OP_PUSHDATA_4";
  OpcodesBTC2[OpcodesBTC2["OP_1NEGATE"] = 79] = "OP_1NEGATE";
  OpcodesBTC2[OpcodesBTC2["OP_RESERVED"] = 80] = "OP_RESERVED";
  OpcodesBTC2[OpcodesBTC2["OP_1"] = 81] = "OP_1";
  OpcodesBTC2[OpcodesBTC2["OP_2"] = 82] = "OP_2";
  OpcodesBTC2[OpcodesBTC2["OP_3"] = 83] = "OP_3";
  OpcodesBTC2[OpcodesBTC2["OP_4"] = 84] = "OP_4";
  OpcodesBTC2[OpcodesBTC2["OP_5"] = 85] = "OP_5";
  OpcodesBTC2[OpcodesBTC2["OP_6"] = 86] = "OP_6";
  OpcodesBTC2[OpcodesBTC2["OP_7"] = 87] = "OP_7";
  OpcodesBTC2[OpcodesBTC2["OP_8"] = 88] = "OP_8";
  OpcodesBTC2[OpcodesBTC2["OP_9"] = 89] = "OP_9";
  OpcodesBTC2[OpcodesBTC2["OP_10"] = 90] = "OP_10";
  OpcodesBTC2[OpcodesBTC2["OP_11"] = 91] = "OP_11";
  OpcodesBTC2[OpcodesBTC2["OP_12"] = 92] = "OP_12";
  OpcodesBTC2[OpcodesBTC2["OP_13"] = 93] = "OP_13";
  OpcodesBTC2[OpcodesBTC2["OP_14"] = 94] = "OP_14";
  OpcodesBTC2[OpcodesBTC2["OP_15"] = 95] = "OP_15";
  OpcodesBTC2[OpcodesBTC2["OP_16"] = 96] = "OP_16";
  OpcodesBTC2[OpcodesBTC2["OP_NOP"] = 97] = "OP_NOP";
  OpcodesBTC2[OpcodesBTC2["OP_VER"] = 98] = "OP_VER";
  OpcodesBTC2[OpcodesBTC2["OP_IF"] = 99] = "OP_IF";
  OpcodesBTC2[OpcodesBTC2["OP_NOTIF"] = 100] = "OP_NOTIF";
  OpcodesBTC2[OpcodesBTC2["OP_VERIF"] = 101] = "OP_VERIF";
  OpcodesBTC2[OpcodesBTC2["OP_VERNOTIF"] = 102] = "OP_VERNOTIF";
  OpcodesBTC2[OpcodesBTC2["OP_ELSE"] = 103] = "OP_ELSE";
  OpcodesBTC2[OpcodesBTC2["OP_ENDIF"] = 104] = "OP_ENDIF";
  OpcodesBTC2[OpcodesBTC2["OP_VERIFY"] = 105] = "OP_VERIFY";
  OpcodesBTC2[OpcodesBTC2["OP_RETURN"] = 106] = "OP_RETURN";
  OpcodesBTC2[OpcodesBTC2["OP_TOALTSTACK"] = 107] = "OP_TOALTSTACK";
  OpcodesBTC2[OpcodesBTC2["OP_FROMALTSTACK"] = 108] = "OP_FROMALTSTACK";
  OpcodesBTC2[OpcodesBTC2["OP_2DROP"] = 109] = "OP_2DROP";
  OpcodesBTC2[OpcodesBTC2["OP_2DUP"] = 110] = "OP_2DUP";
  OpcodesBTC2[OpcodesBTC2["OP_3DUP"] = 111] = "OP_3DUP";
  OpcodesBTC2[OpcodesBTC2["OP_2OVER"] = 112] = "OP_2OVER";
  OpcodesBTC2[OpcodesBTC2["OP_2ROT"] = 113] = "OP_2ROT";
  OpcodesBTC2[OpcodesBTC2["OP_2SWAP"] = 114] = "OP_2SWAP";
  OpcodesBTC2[OpcodesBTC2["OP_IFDUP"] = 115] = "OP_IFDUP";
  OpcodesBTC2[OpcodesBTC2["OP_DEPTH"] = 116] = "OP_DEPTH";
  OpcodesBTC2[OpcodesBTC2["OP_DROP"] = 117] = "OP_DROP";
  OpcodesBTC2[OpcodesBTC2["OP_DUP"] = 118] = "OP_DUP";
  OpcodesBTC2[OpcodesBTC2["OP_NIP"] = 119] = "OP_NIP";
  OpcodesBTC2[OpcodesBTC2["OP_OVER"] = 120] = "OP_OVER";
  OpcodesBTC2[OpcodesBTC2["OP_PICK"] = 121] = "OP_PICK";
  OpcodesBTC2[OpcodesBTC2["OP_ROLL"] = 122] = "OP_ROLL";
  OpcodesBTC2[OpcodesBTC2["OP_ROT"] = 123] = "OP_ROT";
  OpcodesBTC2[OpcodesBTC2["OP_SWAP"] = 124] = "OP_SWAP";
  OpcodesBTC2[OpcodesBTC2["OP_TUCK"] = 125] = "OP_TUCK";
  OpcodesBTC2[OpcodesBTC2["OP_CAT"] = 126] = "OP_CAT";
  OpcodesBTC2[OpcodesBTC2["OP_SUBSTR"] = 127] = "OP_SUBSTR";
  OpcodesBTC2[OpcodesBTC2["OP_LEFT"] = 128] = "OP_LEFT";
  OpcodesBTC2[OpcodesBTC2["OP_RIGHT"] = 129] = "OP_RIGHT";
  OpcodesBTC2[OpcodesBTC2["OP_SIZE"] = 130] = "OP_SIZE";
  OpcodesBTC2[OpcodesBTC2["OP_INVERT"] = 131] = "OP_INVERT";
  OpcodesBTC2[OpcodesBTC2["OP_AND"] = 132] = "OP_AND";
  OpcodesBTC2[OpcodesBTC2["OP_OR"] = 133] = "OP_OR";
  OpcodesBTC2[OpcodesBTC2["OP_XOR"] = 134] = "OP_XOR";
  OpcodesBTC2[OpcodesBTC2["OP_EQUAL"] = 135] = "OP_EQUAL";
  OpcodesBTC2[OpcodesBTC2["OP_EQUALVERIFY"] = 136] = "OP_EQUALVERIFY";
  OpcodesBTC2[OpcodesBTC2["OP_RESERVED1"] = 137] = "OP_RESERVED1";
  OpcodesBTC2[OpcodesBTC2["OP_RESERVED2"] = 138] = "OP_RESERVED2";
  OpcodesBTC2[OpcodesBTC2["OP_1ADD"] = 139] = "OP_1ADD";
  OpcodesBTC2[OpcodesBTC2["OP_1SUB"] = 140] = "OP_1SUB";
  OpcodesBTC2[OpcodesBTC2["OP_2MUL"] = 141] = "OP_2MUL";
  OpcodesBTC2[OpcodesBTC2["OP_2DIV"] = 142] = "OP_2DIV";
  OpcodesBTC2[OpcodesBTC2["OP_NEGATE"] = 143] = "OP_NEGATE";
  OpcodesBTC2[OpcodesBTC2["OP_ABS"] = 144] = "OP_ABS";
  OpcodesBTC2[OpcodesBTC2["OP_NOT"] = 145] = "OP_NOT";
  OpcodesBTC2[OpcodesBTC2["OP_0NOTEQUAL"] = 146] = "OP_0NOTEQUAL";
  OpcodesBTC2[OpcodesBTC2["OP_ADD"] = 147] = "OP_ADD";
  OpcodesBTC2[OpcodesBTC2["OP_SUB"] = 148] = "OP_SUB";
  OpcodesBTC2[OpcodesBTC2["OP_MUL"] = 149] = "OP_MUL";
  OpcodesBTC2[OpcodesBTC2["OP_DIV"] = 150] = "OP_DIV";
  OpcodesBTC2[OpcodesBTC2["OP_MOD"] = 151] = "OP_MOD";
  OpcodesBTC2[OpcodesBTC2["OP_LSHIFT"] = 152] = "OP_LSHIFT";
  OpcodesBTC2[OpcodesBTC2["OP_RSHIFT"] = 153] = "OP_RSHIFT";
  OpcodesBTC2[OpcodesBTC2["OP_BOOLAND"] = 154] = "OP_BOOLAND";
  OpcodesBTC2[OpcodesBTC2["OP_BOOLOR"] = 155] = "OP_BOOLOR";
  OpcodesBTC2[OpcodesBTC2["OP_NUMEQUAL"] = 156] = "OP_NUMEQUAL";
  OpcodesBTC2[OpcodesBTC2["OP_NUMEQUALVERIFY"] = 157] = "OP_NUMEQUALVERIFY";
  OpcodesBTC2[OpcodesBTC2["OP_NUMNOTEQUAL"] = 158] = "OP_NUMNOTEQUAL";
  OpcodesBTC2[OpcodesBTC2["OP_LESSTHAN"] = 159] = "OP_LESSTHAN";
  OpcodesBTC2[OpcodesBTC2["OP_GREATERTHAN"] = 160] = "OP_GREATERTHAN";
  OpcodesBTC2[OpcodesBTC2["OP_LESSTHANOREQUAL"] = 161] = "OP_LESSTHANOREQUAL";
  OpcodesBTC2[OpcodesBTC2["OP_GREATERTHANOREQUAL"] = 162] = "OP_GREATERTHANOREQUAL";
  OpcodesBTC2[OpcodesBTC2["OP_MIN"] = 163] = "OP_MIN";
  OpcodesBTC2[OpcodesBTC2["OP_MAX"] = 164] = "OP_MAX";
  OpcodesBTC2[OpcodesBTC2["OP_WITHIN"] = 165] = "OP_WITHIN";
  OpcodesBTC2[OpcodesBTC2["OP_RIPEMD160"] = 166] = "OP_RIPEMD160";
  OpcodesBTC2[OpcodesBTC2["OP_SHA1"] = 167] = "OP_SHA1";
  OpcodesBTC2[OpcodesBTC2["OP_SHA256"] = 168] = "OP_SHA256";
  OpcodesBTC2[OpcodesBTC2["OP_HASH160"] = 169] = "OP_HASH160";
  OpcodesBTC2[OpcodesBTC2["OP_HASH256"] = 170] = "OP_HASH256";
  OpcodesBTC2[OpcodesBTC2["OP_CODESEPARATOR"] = 171] = "OP_CODESEPARATOR";
  OpcodesBTC2[OpcodesBTC2["OP_CHECKSIG"] = 172] = "OP_CHECKSIG";
  OpcodesBTC2[OpcodesBTC2["OP_CHECKSIGVERIFY"] = 173] = "OP_CHECKSIGVERIFY";
  OpcodesBTC2[OpcodesBTC2["OP_CHECKMULTISIG"] = 174] = "OP_CHECKMULTISIG";
  OpcodesBTC2[OpcodesBTC2["OP_CHECKMULTISIGVERIFY"] = 175] = "OP_CHECKMULTISIGVERIFY";
  OpcodesBTC2[OpcodesBTC2["OP_NOP1"] = 176] = "OP_NOP1";
  OpcodesBTC2[OpcodesBTC2["OP_CHECKLOCKTIMEVERIFY"] = 177] = "OP_CHECKLOCKTIMEVERIFY";
  OpcodesBTC2[OpcodesBTC2["OP_CHECKSEQUENCEVERIFY"] = 178] = "OP_CHECKSEQUENCEVERIFY";
  OpcodesBTC2[OpcodesBTC2["OP_NOP4"] = 179] = "OP_NOP4";
  OpcodesBTC2[OpcodesBTC2["OP_NOP5"] = 180] = "OP_NOP5";
  OpcodesBTC2[OpcodesBTC2["OP_NOP6"] = 181] = "OP_NOP6";
  OpcodesBTC2[OpcodesBTC2["OP_NOP7"] = 182] = "OP_NOP7";
  OpcodesBTC2[OpcodesBTC2["OP_NOP8"] = 183] = "OP_NOP8";
  OpcodesBTC2[OpcodesBTC2["OP_NOP9"] = 184] = "OP_NOP9";
  OpcodesBTC2[OpcodesBTC2["OP_NOP10"] = 185] = "OP_NOP10";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN186"] = 186] = "OP_UNKNOWN186";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN187"] = 187] = "OP_UNKNOWN187";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN188"] = 188] = "OP_UNKNOWN188";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN189"] = 189] = "OP_UNKNOWN189";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN190"] = 190] = "OP_UNKNOWN190";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN191"] = 191] = "OP_UNKNOWN191";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN192"] = 192] = "OP_UNKNOWN192";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN193"] = 193] = "OP_UNKNOWN193";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN194"] = 194] = "OP_UNKNOWN194";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN195"] = 195] = "OP_UNKNOWN195";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN196"] = 196] = "OP_UNKNOWN196";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN197"] = 197] = "OP_UNKNOWN197";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN198"] = 198] = "OP_UNKNOWN198";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN199"] = 199] = "OP_UNKNOWN199";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN200"] = 200] = "OP_UNKNOWN200";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN201"] = 201] = "OP_UNKNOWN201";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN202"] = 202] = "OP_UNKNOWN202";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN203"] = 203] = "OP_UNKNOWN203";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN204"] = 204] = "OP_UNKNOWN204";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN205"] = 205] = "OP_UNKNOWN205";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN206"] = 206] = "OP_UNKNOWN206";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN207"] = 207] = "OP_UNKNOWN207";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN208"] = 208] = "OP_UNKNOWN208";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN209"] = 209] = "OP_UNKNOWN209";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN210"] = 210] = "OP_UNKNOWN210";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN211"] = 211] = "OP_UNKNOWN211";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN212"] = 212] = "OP_UNKNOWN212";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN213"] = 213] = "OP_UNKNOWN213";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN214"] = 214] = "OP_UNKNOWN214";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN215"] = 215] = "OP_UNKNOWN215";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN216"] = 216] = "OP_UNKNOWN216";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN217"] = 217] = "OP_UNKNOWN217";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN218"] = 218] = "OP_UNKNOWN218";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN219"] = 219] = "OP_UNKNOWN219";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN220"] = 220] = "OP_UNKNOWN220";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN221"] = 221] = "OP_UNKNOWN221";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN222"] = 222] = "OP_UNKNOWN222";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN223"] = 223] = "OP_UNKNOWN223";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN224"] = 224] = "OP_UNKNOWN224";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN225"] = 225] = "OP_UNKNOWN225";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN226"] = 226] = "OP_UNKNOWN226";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN227"] = 227] = "OP_UNKNOWN227";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN228"] = 228] = "OP_UNKNOWN228";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN229"] = 229] = "OP_UNKNOWN229";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN230"] = 230] = "OP_UNKNOWN230";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN231"] = 231] = "OP_UNKNOWN231";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN232"] = 232] = "OP_UNKNOWN232";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN233"] = 233] = "OP_UNKNOWN233";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN234"] = 234] = "OP_UNKNOWN234";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN235"] = 235] = "OP_UNKNOWN235";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN236"] = 236] = "OP_UNKNOWN236";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN237"] = 237] = "OP_UNKNOWN237";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN238"] = 238] = "OP_UNKNOWN238";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN239"] = 239] = "OP_UNKNOWN239";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN240"] = 240] = "OP_UNKNOWN240";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN241"] = 241] = "OP_UNKNOWN241";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN242"] = 242] = "OP_UNKNOWN242";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN243"] = 243] = "OP_UNKNOWN243";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN244"] = 244] = "OP_UNKNOWN244";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN245"] = 245] = "OP_UNKNOWN245";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN246"] = 246] = "OP_UNKNOWN246";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN247"] = 247] = "OP_UNKNOWN247";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN248"] = 248] = "OP_UNKNOWN248";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN249"] = 249] = "OP_UNKNOWN249";
  OpcodesBTC2[OpcodesBTC2["OP_SMALLINTEGER"] = 250] = "OP_SMALLINTEGER";
  OpcodesBTC2[OpcodesBTC2["OP_PUBKEYS"] = 251] = "OP_PUBKEYS";
  OpcodesBTC2[OpcodesBTC2["OP_UNKNOWN252"] = 252] = "OP_UNKNOWN252";
  OpcodesBTC2[OpcodesBTC2["OP_PUBKEYHASH"] = 253] = "OP_PUBKEYHASH";
  OpcodesBTC2[OpcodesBTC2["OP_PUBKEY"] = 254] = "OP_PUBKEY";
  OpcodesBTC2[OpcodesBTC2["OP_INVALIDOPCODE"] = 255] = "OP_INVALIDOPCODE";
})(OpcodesBTC || (OpcodesBTC = {}));

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/common/instruction-sets-utils.js
var authenticationInstructionIsMalformed = (instruction) => "malformed" in instruction;
var authenticationInstructionsAreMalformed = (instructions) => instructions.length > 0 && // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
authenticationInstructionIsMalformed(instructions[instructions.length - 1]);
var authenticationInstructionsArePushInstructions = (instructions) => instructions.every((instruction) => "data" in instruction);
var uint8Bytes = 1;
var uint16Bytes = 2;
var uint32Bytes = 4;
var decodeLittleEndianNumber = (bytecode, index2, length) => {
  const view = new DataView(bytecode.buffer, index2, length);
  const readAsLittleEndian = true;
  return length === uint8Bytes ? view.getUint8(0) : length === uint16Bytes ? view.getUint16(0, readAsLittleEndian) : view.getUint32(0, readAsLittleEndian);
};
var opcodeToPushLength = (opcode) => ({
  [
    76
    /* CommonPushOpcodes.OP_PUSHDATA_1 */
  ]: uint8Bytes,
  [
    77
    /* CommonPushOpcodes.OP_PUSHDATA_2 */
  ]: uint16Bytes,
  [
    78
    /* CommonPushOpcodes.OP_PUSHDATA_4 */
  ]: uint32Bytes
})[opcode] ?? 0;
var decodeAuthenticationInstruction = (bytecode, index2) => {
  const opcode = bytecode[index2];
  if (opcode > 78) {
    return {
      instruction: {
        opcode
      },
      nextIndex: index2 + 1
    };
  }
  const lengthBytes = opcodeToPushLength(opcode);
  if (lengthBytes !== 0 && index2 + lengthBytes >= bytecode.length) {
    const sliceStart = index2 + 1;
    const sliceEnd = sliceStart + lengthBytes;
    return {
      instruction: {
        expectedLengthBytes: lengthBytes,
        length: bytecode.slice(sliceStart, sliceEnd),
        malformed: true,
        opcode
      },
      nextIndex: sliceEnd
    };
  }
  const dataBytes = lengthBytes === 0 ? opcode : decodeLittleEndianNumber(bytecode, index2 + 1, lengthBytes);
  const dataStart = index2 + 1 + lengthBytes;
  const dataEnd = dataStart + dataBytes;
  return {
    instruction: {
      data: bytecode.slice(dataStart, dataEnd),
      ...dataEnd > bytecode.length ? {
        expectedDataBytes: dataEnd - dataStart,
        malformed: true
      } : void 0,
      opcode
    },
    nextIndex: dataEnd
  };
};
var cloneAuthenticationInstruction = (instruction) => ({
  ..."data" in instruction ? { data: instruction.data } : {},
  opcode: instruction.opcode
});
var decodeAuthenticationInstructions = (bytecode) => {
  const instructions = [];
  let i = 0;
  while (i < bytecode.length) {
    const { instruction, nextIndex } = decodeAuthenticationInstruction(bytecode, i);
    i = nextIndex;
    instructions.push(instruction);
  }
  return instructions;
};
var isMultiWordPush = (opcode) => opcode !== 0;
var formatAsmPushHex = (data) => data.length > 0 ? `0x${binToHex(data)}` : "";
var formatMissingBytesAsm = (missing) => `[missing ${missing} byte${missing === 1 ? "" : "s"}]`;
var hasMalformedLength = (instruction) => "length" in instruction;
var isPushData = (pushOpcode) => pushOpcode >= 76;
var disassembleAuthenticationInstructionMalformed = (opcodes, instruction) => `${opcodes[instruction.opcode] ?? "OP_UNKNOWN"} ${hasMalformedLength(instruction) ? `${formatAsmPushHex(instruction.length)}${formatMissingBytesAsm(instruction.expectedLengthBytes - instruction.length.length)}` : `${isPushData(instruction.opcode) ? `${instruction.expectedDataBytes} ` : ""}${formatAsmPushHex(instruction.data)}${formatMissingBytesAsm(instruction.expectedDataBytes - instruction.data.length)}`}`;
var disassembleAuthenticationInstruction = (opcodes, instruction) => `${opcodes[instruction.opcode] ?? "OP_UNKNOWN"}${"data" in instruction && isMultiWordPush(instruction.opcode) ? ` ${isPushData(instruction.opcode) ? `${instruction.data.length} ` : ""}${formatAsmPushHex(instruction.data)}` : ""}`;
var disassembleAuthenticationInstructionMaybeMalformed = (opcodes, instruction) => authenticationInstructionIsMalformed(instruction) ? disassembleAuthenticationInstructionMalformed(opcodes, instruction) : disassembleAuthenticationInstruction(opcodes, instruction);
var disassembleAuthenticationInstructionsMaybeMalformed = (opcodes, instructions) => instructions.map((instruction) => disassembleAuthenticationInstructionMaybeMalformed(opcodes, instruction)).join(" ");
var disassembleBytecode = (opcodes, bytecode) => disassembleAuthenticationInstructionsMaybeMalformed(opcodes, decodeAuthenticationInstructions(bytecode));
var disassembleBytecodeBCH = (bytecode) => disassembleAuthenticationInstructionsMaybeMalformed(OpcodesBCH, decodeAuthenticationInstructions(bytecode));
var disassembleBytecodeBTC = (bytecode) => disassembleAuthenticationInstructionsMaybeMalformed(OpcodesBTC, decodeAuthenticationInstructions(bytecode));
var generateBytecodeMap = (opcodes) => Object.entries(opcodes).filter((entry) => typeof entry[1] === "number").reduce((identifiers, pair) => ({
  ...identifiers,
  [pair[0]]: Uint8Array.of(pair[1])
}), {});
var getInstructionLengthBytes = (instruction) => {
  const { opcode } = instruction;
  const expectedLength = opcodeToPushLength(opcode);
  return expectedLength === uint8Bytes ? Uint8Array.of(instruction.data.length) : expectedLength === uint16Bytes ? numberToBinUint16LE(instruction.data.length) : numberToBinUint32LE(instruction.data.length);
};
var encodeAuthenticationInstruction = (instruction) => Uint8Array.from([
  instruction.opcode,
  ..."data" in instruction ? [
    ...isPushData(instruction.opcode) ? getInstructionLengthBytes(instruction) : [],
    ...instruction.data
  ] : []
]);
var encodeAuthenticationInstructionMalformed = (instruction) => {
  const { opcode } = instruction;
  if (hasMalformedLength(instruction)) {
    return Uint8Array.from([opcode, ...instruction.length]);
  }
  if (isPushData(opcode)) {
    return Uint8Array.from([
      opcode,
      ...opcode === 76 ? Uint8Array.of(instruction.expectedDataBytes) : opcode === 77 ? numberToBinUint16LE(instruction.expectedDataBytes) : numberToBinUint32LE(instruction.expectedDataBytes),
      ...instruction.data
    ]);
  }
  return Uint8Array.from([opcode, ...instruction.data]);
};
var encodeAuthenticationInstructionMaybeMalformed = (instruction) => authenticationInstructionIsMalformed(instruction) ? encodeAuthenticationInstructionMalformed(instruction) : encodeAuthenticationInstruction(instruction);
var encodeAuthenticationInstructions = (instructions) => flattenBinArray(instructions.map(encodeAuthenticationInstruction));
var encodeAuthenticationInstructionsMaybeMalformed = (instructions) => flattenBinArray(instructions.map(encodeAuthenticationInstructionMaybeMalformed));
var VmNumberError;
(function(VmNumberError2) {
  VmNumberError2["outOfRange"] = "Failed to decode VM Number: overflows VM Number range.";
  VmNumberError2["requiresMinimal"] = "Failed to decode VM Number: the number is not minimally-encoded.";
})(VmNumberError || (VmNumberError = {}));
var isVmNumberError = (value) => value === VmNumberError.outOfRange || value === VmNumberError.requiresMinimal;
var typicalMaximumVmNumberByteLength = 8;
var vmNumberToBigInt = (bytes, { maximumVmNumberByteLength: maximumVmNumberByteLength2 = typicalMaximumVmNumberByteLength, requireMinimalEncoding = true } = {
  maximumVmNumberByteLength: typicalMaximumVmNumberByteLength,
  requireMinimalEncoding: true
}) => {
  if (bytes.length === 0) {
    return 0n;
  }
  if (bytes.length > maximumVmNumberByteLength2) {
    return VmNumberError.outOfRange;
  }
  const mostSignificantByte = bytes[bytes.length - 1];
  const secondMostSignificantByte = bytes[bytes.length - 1 - 1];
  const allButTheSignBit = 127;
  const justTheSignBit = 128;
  if (requireMinimalEncoding && // eslint-disable-next-line no-bitwise
  (mostSignificantByte & allButTheSignBit) === 0 && // eslint-disable-next-line no-bitwise, @typescript-eslint/no-non-null-assertion
  (bytes.length <= 1 || (secondMostSignificantByte & justTheSignBit) === 0)) {
    return VmNumberError.requiresMinimal;
  }
  const bitsPerByte = 8;
  const signFlippingByte = 128;
  let result = 0n;
  for (let byte = 0; byte < bytes.length; byte++) {
    result |= BigInt(bytes[byte]) << BigInt(byte * bitsPerByte);
  }
  const isNegative2 = (bytes[bytes.length - 1] & signFlippingByte) !== 0;
  return isNegative2 ? -(result & ~(BigInt(signFlippingByte) << BigInt(bitsPerByte * (bytes.length - 1)))) : result;
};
var bigIntToVmNumber = (integer) => {
  if (integer === 0n) {
    return new Uint8Array();
  }
  const bytes = [];
  const isNegative2 = integer < 0;
  const byteStates = 255;
  const bitsPerByte = 8;
  let remaining = isNegative2 ? -integer : integer;
  while (remaining > 0) {
    bytes.push(Number(remaining & BigInt(byteStates)));
    remaining >>= BigInt(bitsPerByte);
  }
  const signFlippingByte = 128;
  if ((bytes[bytes.length - 1] & signFlippingByte) > 0) {
    bytes.push(isNegative2 ? signFlippingByte : 0);
  } else if (isNegative2) {
    bytes[bytes.length - 1] |= signFlippingByte;
  }
  return new Uint8Array(bytes);
};
var stackItemIsTruthy = (item) => {
  const signFlippingByte = 128;
  for (let i = 0; i < item.length; i++) {
    if (item[i] !== 0) {
      if (i === item.length - 1 && item[i] === signFlippingByte) {
        return false;
      }
      return true;
    }
  }
  return false;
};
var booleanToVmNumber = (value) => value ? bigIntToVmNumber(1n) : bigIntToVmNumber(0n);
var isPushOperation = (opcode) => opcode <= 96;
var isPushOnly = (bytecode) => {
  const instructions = decodeAuthenticationInstructions(bytecode);
  return instructions.every((instruction) => isPushOperation(instruction.opcode));
};
var isPushOnlyAccurate = (bytecode) => {
  const instructions = decodeAuthenticationInstructions(bytecode);
  return !authenticationInstructionsAreMalformed(instructions) && authenticationInstructionsArePushInstructions(instructions);
};
var isArbitraryDataOutput = (lockingBytecode) => lockingBytecode.length >= 1 && lockingBytecode[0] === 106 && isPushOnly(lockingBytecode.slice(1));
var getMinimumFee = (length, feeRateSatsPerKb) => {
  if (length < 1n)
    return 0n;
  const truncated = length * feeRateSatsPerKb / BigInt(
    1e3
    /* Dust.bytesPerKb */
  );
  return truncated === 0n ? 1n : truncated;
};
var getDustThreshold = (output, dustRelayFeeSatPerKb = BigInt(
  1e3
  /* Dust.standardDustRelayFee */
)) => {
  if (isArbitraryDataOutput(output.lockingBytecode)) {
    return 0n;
  }
  const encodedOutputLength = encodeTransactionOutput(output).length;
  const expectedTotalLength = encodedOutputLength + 148;
  return BigInt(
    3
    /* Dust.minimumFeeMultiple */
  ) * getMinimumFee(BigInt(expectedTotalLength), dustRelayFeeSatPerKb);
};
var isDustOutput = (output, dustRelayFeeSatPerKb = BigInt(
  1e3
  /* Dust.standardDustRelayFee */
)) => output.valueSatoshis < getDustThreshold(output, dustRelayFeeSatPerKb);
var isValidUncompressedPublicKeyEncoding = (publicKey) => publicKey.length === 65 && publicKey[0] === 4;
var isValidCompressedPublicKeyEncoding = (publicKey) => publicKey.length === 33 && (publicKey[0] === 2 || publicKey[0] === 3);
var isValidPublicKeyEncoding = (publicKey) => isValidCompressedPublicKeyEncoding(publicKey) || isValidUncompressedPublicKeyEncoding(publicKey);
var pushNumberOpcodeToNumber = (opcode) => {
  if (opcode === 0) {
    return 0;
  }
  if (opcode === 79) {
    return -1;
  }
  if (!Number.isInteger(opcode) || opcode < 81 || opcode > 96) {
    return false;
  }
  return opcode - 80;
};
var isSimpleMultisig = (lockingBytecode) => {
  const instructions = decodeAuthenticationInstructions(lockingBytecode);
  if (authenticationInstructionsAreMalformed(instructions)) {
    return false;
  }
  const lastIndex = instructions.length - 1;
  if (instructions.length < 4 || // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  instructions[lastIndex].opcode !== 174) {
    return false;
  }
  const m = pushNumberOpcodeToNumber(instructions[0].opcode);
  const n = pushNumberOpcodeToNumber(
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    instructions[lastIndex - 1].opcode
  );
  if (n === false || m === false) {
    return false;
  }
  const publicKeyInstructions = instructions.slice(
    1,
    -2
    /* Multisig.keyEnd */
  );
  if (!authenticationInstructionsArePushInstructions(publicKeyInstructions)) {
    return false;
  }
  const publicKeys = publicKeyInstructions.map((instruction) => instruction.data);
  if (publicKeys.some((key) => !isValidPublicKeyEncoding(key))) {
    return false;
  }
  return { m, n, publicKeys };
};
var isStandardMultisig = (lockingBytecode) => {
  const multisigProperties = isSimpleMultisig(lockingBytecode);
  if (multisigProperties === false) {
    return false;
  }
  const { m, n } = multisigProperties;
  if (n < 1 || n > 3 || m < 1 || m > n) {
    return false;
  }
  return true;
};
var isStandardOutputBytecode = (lockingBytecode) => isPayToPublicKeyHash(lockingBytecode) || isPayToScriptHash20(lockingBytecode) || isPayToPublicKey(lockingBytecode) || isArbitraryDataOutput(lockingBytecode) || isStandardMultisig(lockingBytecode);
var isStandardOutputBytecode2023 = (lockingBytecode) => isPayToPublicKeyHash(lockingBytecode) || isPayToScriptHash20(lockingBytecode) || isPayToScriptHash32(lockingBytecode) || isPayToPublicKey(lockingBytecode) || isArbitraryDataOutput(lockingBytecode) || isStandardMultisig(lockingBytecode);
var isWitnessProgram = (bytecode) => {
  const correctLength = bytecode.length >= 4 && bytecode.length <= 42;
  const validVersionPush = bytecode[0] === 0 || // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  bytecode[0] >= 81 && bytecode[0] <= 96;
  const correctLengthByte = (
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    bytecode[1] + 2 === bytecode.length
  );
  return correctLength && validVersionPush && correctLengthByte;
};

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/common/combinators.js
var incrementOperationCount = (operation) => (state) => {
  const nextState = operation(state);
  nextState.operationCount += 1;
  return nextState;
};
var conditionallyEvaluate = (operation) => (state) => state.controlStack.every((item) => item) ? operation(state) : state;
var mapOverOperations = (combinators, operationMap) => Object.keys(operationMap).reduce((result, opcode) => ({
  ...result,
  [opcode]: combinators.reduce(
    (op, combinator) => combinator(op),
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    operationMap[Number(opcode)]
  )
}), {});
var useOneStackItem = (state, operation) => {
  const item = state.stack.pop();
  if (item === void 0) {
    return applyError(state, AuthenticationErrorCommon.emptyStack);
  }
  return operation(state, [item]);
};
var useTwoStackItems = (state, operation) => useOneStackItem(state, (nextState, [valueTwo]) => useOneStackItem(nextState, (lastState, [valueTop]) => operation(lastState, [valueTop, valueTwo])));
var useThreeStackItems = (state, operation) => useOneStackItem(state, (nextState, [valueThree]) => useTwoStackItems(nextState, (lastState, [valueTop, valueTwo]) => operation(lastState, [valueTop, valueTwo, valueThree])));
var useFourStackItems = (state, operation) => useTwoStackItems(state, (nextState, [valueThree, valueFour]) => useTwoStackItems(nextState, (lastState, [valueTop, valueTwo]) => operation(lastState, [valueTop, valueTwo, valueThree, valueFour])));
var useSixStackItems = (state, operation) => useFourStackItems(state, (nextState, [valueThree, valueFour, valueFive, valueSix]) => useTwoStackItems(nextState, (lastState, [valueTop, valueTwo]) => operation(lastState, [
  valueTop,
  valueTwo,
  valueThree,
  valueFour,
  valueFive,
  valueSix
])));
var typicalMaximumVmNumberByteLength2 = 8;
var useOneVmNumber = (state, operation, { maximumVmNumberByteLength: maximumVmNumberByteLength2 = typicalMaximumVmNumberByteLength2, requireMinimalEncoding = true } = {
  maximumVmNumberByteLength: typicalMaximumVmNumberByteLength2,
  requireMinimalEncoding: true
}) => useOneStackItem(state, (nextState, [item]) => {
  const value = vmNumberToBigInt(item, {
    maximumVmNumberByteLength: maximumVmNumberByteLength2,
    requireMinimalEncoding
  });
  if (isVmNumberError(value)) {
    return applyError(state, AuthenticationErrorCommon.invalidVmNumber);
  }
  return operation(nextState, [value]);
});
var useTwoVmNumbers = (state, operation, { maximumVmNumberByteLength: maximumVmNumberByteLength2 = typicalMaximumVmNumberByteLength2, requireMinimalEncoding = true } = {
  maximumVmNumberByteLength: typicalMaximumVmNumberByteLength2,
  requireMinimalEncoding: true
}) => useOneVmNumber(state, (nextState, [secondValue]) => useOneVmNumber(nextState, (lastState, [firstValue]) => operation(lastState, [firstValue, secondValue]), {
  maximumVmNumberByteLength: maximumVmNumberByteLength2,
  requireMinimalEncoding
}), {
  maximumVmNumberByteLength: maximumVmNumberByteLength2,
  requireMinimalEncoding
});
var useThreeVmNumbers = (state, operation, { maximumVmNumberByteLength: maximumVmNumberByteLength2 = typicalMaximumVmNumberByteLength2, requireMinimalEncoding = true } = {
  maximumVmNumberByteLength: typicalMaximumVmNumberByteLength2,
  requireMinimalEncoding: true
}) => useTwoVmNumbers(state, (nextState, [secondValue, thirdValue]) => useOneVmNumber(nextState, (lastState, [firstValue]) => operation(lastState, [firstValue, secondValue, thirdValue]), {
  maximumVmNumberByteLength: maximumVmNumberByteLength2,
  requireMinimalEncoding
}), {
  maximumVmNumberByteLength: maximumVmNumberByteLength2,
  requireMinimalEncoding
});
var pushToStack = (state, ...data) => {
  state.stack.push(...data);
  return state;
};
var pushToStackChecked = (state, item, maximumLength = ConsensusCommon.maximumStackItemLength) => {
  if (item.length > maximumLength) {
    return applyError(state, `${AuthenticationErrorCommon.exceededMaximumStackItemLength} Item length: ${item.length} bytes.`);
  }
  state.stack.push(item);
  return state;
};
var pushToStackVmNumber = (state, vmNumber) => pushToStack(state, bigIntToVmNumber(vmNumber));
var pushToStackVmNumberChecked = (state, vmNumber, minVmNumber = BigInt(ConsensusCommon.minVmNumber), maxVmNumber = BigInt(ConsensusCommon.maxVmNumber)) => {
  if (vmNumber > maxVmNumber || vmNumber < minVmNumber) {
    return applyError(state, AuthenticationErrorCommon.overflowsVmNumberRange);
  }
  return pushToStackVmNumber(state, vmNumber);
};
var combineOperations = (firstOperation, secondOperation) => (state) => secondOperation(firstOperation(state));

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/common/flow-control.js
var import_dist160 = __toESM(require_dist(), 1);
var import_dist161 = __toESM(require_dist2(), 1);
var import_dist162 = __toESM(require_dist3(), 1);
var opVerify = (state) => useOneStackItem(state, (nextState, [item]) => stackItemIsTruthy(item) ? nextState : applyError(nextState, AuthenticationErrorCommon.failedVerify));
var reservedOperation = (state) => applyError(state, AuthenticationErrorCommon.calledReserved);
var opReturn = (state) => applyError(state, AuthenticationErrorCommon.calledReturn);
var opIf = (state) => {
  if (state.controlStack.every((item) => item)) {
    return useOneStackItem(state, (nextState, [item]) => {
      nextState.controlStack.push(stackItemIsTruthy(item));
      return state;
    });
  }
  state.controlStack.push(false);
  return state;
};
var opNotIf = (state) => {
  if (state.controlStack.every((item) => item)) {
    return useOneStackItem(state, (nextState, [item]) => {
      nextState.controlStack.push(!stackItemIsTruthy(item));
      return state;
    });
  }
  state.controlStack.push(false);
  return state;
};
var opEndIf = (state) => {
  const element = state.controlStack.pop();
  if (element === void 0) {
    return applyError(state, AuthenticationErrorCommon.unexpectedEndIf);
  }
  return state;
};
var opElse = (state) => {
  const top = state.controlStack[state.controlStack.length - 1];
  if (top === void 0) {
    return applyError(state, AuthenticationErrorCommon.unexpectedElse);
  }
  state.controlStack[state.controlStack.length - 1] = !top;
  return state;
};

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/common/arithmetic.js
var op1Add = (state) => useOneVmNumber(state, (nextState, [value]) => pushToStackVmNumberChecked(nextState, value + 1n));
var op1Sub = (state) => useOneVmNumber(state, (nextState, [value]) => pushToStack(nextState, bigIntToVmNumber(value - 1n)));
var opNegate = (state) => useOneVmNumber(state, (nextState, [value]) => pushToStack(nextState, bigIntToVmNumber(-value)));
var opAbs = (state) => useOneVmNumber(state, (nextState, [value]) => pushToStack(nextState, bigIntToVmNumber(value < 0 ? -value : value)));
var opNot = (state) => useOneVmNumber(state, (nextState, [value]) => pushToStack(nextState, value === 0n ? bigIntToVmNumber(1n) : bigIntToVmNumber(0n)));
var op0NotEqual = (state) => useOneVmNumber(state, (nextState, [value]) => pushToStack(nextState, value === 0n ? bigIntToVmNumber(0n) : bigIntToVmNumber(1n)));
var opAdd = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStackVmNumberChecked(nextState, firstValue + secondValue));
var opSub = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, bigIntToVmNumber(firstValue - secondValue)));
var opBoolAnd = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToVmNumber(firstValue !== 0n && secondValue !== 0n)));
var opBoolOr = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToVmNumber(firstValue !== 0n || secondValue !== 0n)));
var opNumEqual = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToVmNumber(firstValue === secondValue)));
var opNumEqualVerify = combineOperations(opNumEqual, opVerify);
var opNumNotEqual = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToVmNumber(firstValue !== secondValue)));
var opLessThan = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToVmNumber(firstValue < secondValue)));
var opLessThanOrEqual = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToVmNumber(firstValue <= secondValue)));
var opGreaterThan = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToVmNumber(firstValue > secondValue)));
var opGreaterThanOrEqual = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToVmNumber(firstValue >= secondValue)));
var opMin = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, bigIntToVmNumber(firstValue < secondValue ? firstValue : secondValue)));
var opMax = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, bigIntToVmNumber(firstValue > secondValue ? firstValue : secondValue)));
var opWithin = (state) => useThreeVmNumbers(state, (nextState, [firstValue, secondValue, thirdValue]) => pushToStack(nextState, booleanToVmNumber(secondValue <= firstValue && firstValue < thirdValue)));
var opMul = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStackVmNumberChecked(nextState, firstValue * secondValue));
var opDiv = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => secondValue === 0n ? applyError(nextState, AuthenticationErrorCommon.divisionByZero) : pushToStack(nextState, bigIntToVmNumber(firstValue / secondValue)));
var opMod = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => secondValue === 0n ? applyError(nextState, AuthenticationErrorCommon.divisionByZero) : pushToStack(nextState, bigIntToVmNumber(firstValue % secondValue)));

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/common/bitwise.js
var import_dist166 = __toESM(require_dist(), 1);
var import_dist167 = __toESM(require_dist2(), 1);
var import_dist168 = __toESM(require_dist3(), 1);
var opEqual = (state) => useTwoStackItems(state, (nextState, [element1, element2]) => pushToStack(nextState, booleanToVmNumber(binsAreEqual(element1, element2))));
var opEqualVerify = combineOperations(opEqual, opVerify);
var bitwiseOperation = (combine) => (state) => useTwoStackItems(state, (nextState, [a, b]) => a.length === b.length ? pushToStack(nextState, combine(a, b)) : applyError(nextState, AuthenticationErrorCommon.mismatchedBitwiseOperandLength));
var opAnd = bitwiseOperation((a, b) => a.map((v, i) => v & b[i]));
var opOr = bitwiseOperation((a, b) => a.map((v, i) => v | b[i]));
var opXor = bitwiseOperation((a, b) => a.map((v, i) => v ^ b[i]));

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/common/common-types.js
var import_dist169 = __toESM(require_dist(), 1);
var import_dist170 = __toESM(require_dist2(), 1);
var import_dist171 = __toESM(require_dist3(), 1);
var undefinedOperation = conditionallyEvaluate((state) => applyError(state, AuthenticationErrorCommon.unknownOpcode));
var checkLimitsCommon = (operation) => (state) => {
  const nextState = operation(state);
  return nextState.stack.length + nextState.alternateStack.length > ConsensusCommon.maximumStackDepth ? applyError(nextState, AuthenticationErrorCommon.exceededMaximumStackDepth) : nextState.operationCount > ConsensusCommon.maximumOperationCount ? applyError(nextState, AuthenticationErrorCommon.exceededMaximumOperationCount) : nextState;
};
var cloneStack = (stack) => stack.map((item) => item.slice());
var createAuthenticationProgramStateCommon = ({ program, instructions, stack }) => ({
  alternateStack: [],
  controlStack: [],
  instructions,
  ip: 0,
  lastCodeSeparator: -1,
  operationCount: 0,
  program,
  signatureOperationsCount: 0,
  signedMessages: [],
  stack
});
var cloneAuthenticationProgramCommon = (program) => ({
  inputIndex: program.inputIndex,
  sourceOutputs: cloneTransactionOutputsCommon(program.sourceOutputs),
  transaction: cloneTransactionCommon(program.transaction)
});
var cloneAuthenticationProgramStateCommon = (state) => ({
  ...state.error === void 0 ? {} : { error: state.error },
  alternateStack: cloneStack(state.alternateStack),
  controlStack: state.controlStack.slice(),
  instructions: state.instructions.map(cloneAuthenticationInstruction),
  ip: state.ip,
  lastCodeSeparator: state.lastCodeSeparator,
  operationCount: state.operationCount,
  program: cloneAuthenticationProgramCommon(state.program),
  signatureOperationsCount: state.signatureOperationsCount,
  signedMessages: state.signedMessages.map((item) => ({
    digest: item.digest.slice(),
    ..."serialization" in item ? { serialization: item.serialization.slice() } : { message: item.message.slice() }
  })),
  stack: cloneStack(state.stack)
});
var cloneAuthenticationProgramStateBCH = cloneAuthenticationProgramStateCommon;
var cloneAuthenticationProgramState = cloneAuthenticationProgramStateBCH;
var sha256HashLength = 32;
var createCompilationContextCommonTesting = ({ sourceOutputs, inputs, locktime, version, outputs } = {}) => ({
  inputIndex: 0,
  sourceOutputs: sourceOutputs ? sourceOutputs : [
    {
      lockingBytecode: Uint8Array.from([]),
      valueSatoshis: 0xffffffffffffffffn
    }
  ],
  transaction: {
    inputs: inputs ? inputs : [
      {
        outpointIndex: 0,
        outpointTransactionHash: new Uint8Array(sha256HashLength).fill(1),
        sequenceNumber: 0,
        unlockingBytecode: void 0
      }
    ],
    locktime: locktime === void 0 ? 0 : locktime,
    outputs: outputs === void 0 ? [
      {
        lockingBytecode: Uint8Array.from([]),
        valueSatoshis: 0xffffffffffffffffn
      }
    ] : outputs,
    version: version === void 0 ? 0 : version
  }
});

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/common/crypto.js
var import_dist175 = __toESM(require_dist(), 1);
var import_dist176 = __toESM(require_dist2(), 1);
var import_dist177 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/common/encoding.js
var import_dist172 = __toESM(require_dist(), 1);
var import_dist173 = __toESM(require_dist2(), 1);
var import_dist174 = __toESM(require_dist3(), 1);
var isNegative = (value) => (
  // eslint-disable-next-line no-bitwise, @typescript-eslint/no-non-null-assertion
  (value & 128) !== 0
);
var hasUnnecessaryPadding = (length, firstByte, secondByte) => length > 1 && firstByte === 0 && !isNegative(secondByte);
var isValidInteger = (signature, tagIndex, length, valueIndex) => signature[tagIndex] === 2 && length !== 0 && !isNegative(signature[valueIndex]) && !hasUnnecessaryPadding(length, signature[valueIndex], signature[valueIndex + 1]);
var isValidSignatureEncodingDER = (signature) => {
  const correctLengthRange = signature.length > 8 && signature.length < 72;
  const correctSequenceTagType = signature[
    0
    /* DER.sequenceTagIndex */
  ] === 48;
  const correctSequenceLength = signature[
    1
    /* DER.sequenceLengthIndex */
  ] === signature.length - 2;
  const rLength = signature[
    3
    /* DER.rLengthIndex */
  ];
  if (rLength === void 0) {
    return false;
  }
  const consistentRLength = rLength <= signature.length - 7;
  const rIsValid = isValidInteger(
    signature,
    2,
    rLength,
    4
    /* DER.rValueIndex */
  );
  const sTagIndex = 4 + rLength;
  const sLengthIndex = sTagIndex + 1;
  const sLength = signature[sLengthIndex];
  if (sLength === void 0) {
    return false;
  }
  const sValueIndex = sLengthIndex + 1;
  const consistentSLength = sValueIndex + sLength === signature.length;
  const sIsValid = isValidInteger(signature, sTagIndex, sLength, sValueIndex);
  return correctLengthRange && correctSequenceTagType && correctSequenceLength && consistentRLength && rIsValid && consistentSLength && sIsValid;
};
var isValidSignatureEncodingBCHTransaction = (transactionSignature, validSigningSerializationTypes) => transactionSignature.length === 0 || validSigningSerializationTypes.includes(
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  transactionSignature[transactionSignature.length - 1]
) && (transactionSignature.length === ConsensusCommon.schnorrSignatureLength + 1 || isValidSignatureEncodingDER(transactionSignature.slice(0, transactionSignature.length - 1)));
var decodeBitcoinSignature = (encodedSignature) => ({
  signature: encodedSignature.slice(0, -1),
  signingSerializationType: encodedSignature.slice(-1)
});

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/common/crypto.js
var opRipemd160 = ({ ripemd160: ripemd1602 } = { ripemd160 }) => (state) => useOneStackItem(state, (nextState, [value]) => pushToStack(nextState, ripemd1602.hash(value)));
var opSha1 = ({ sha1: sha12 } = { sha1 }) => (state) => useOneStackItem(state, (nextState, [value]) => pushToStack(nextState, sha12.hash(value)));
var opSha256 = ({ sha256: sha2562 } = { sha256 }) => (state) => useOneStackItem(state, (nextState, [value]) => pushToStack(nextState, sha2562.hash(value)));
var opHash160 = ({ ripemd160: ripemd1602, sha256: sha2562 } = { ripemd160, sha256 }) => (state) => useOneStackItem(state, (nextState, [value]) => pushToStack(nextState, ripemd1602.hash(sha2562.hash(value))));
var opHash256 = ({ sha256: sha2562 } = { sha256 }) => (state) => useOneStackItem(state, (nextState, [value]) => pushToStack(nextState, hash256(value, sha2562)));
var opCodeSeparator = (state) => {
  state.lastCodeSeparator = state.ip;
  return state;
};
var opCheckSig = ({ secp256k1: secp256k12, sha256: sha2562 } = { secp256k1, sha256 }) => (s) => (
  // eslint-disable-next-line complexity
  useTwoStackItems(s, (state, [bitcoinEncodedSignature, publicKey]) => {
    if (!isValidPublicKeyEncoding(publicKey)) {
      return applyError(state, AuthenticationErrorCommon.invalidPublicKeyEncoding);
    }
    if (!isValidSignatureEncodingBCHTransaction(bitcoinEncodedSignature, SigningSerializationTypesBCH)) {
      return applyError(state, AuthenticationErrorCommon.invalidSignatureEncoding, `Transaction signature (including signing serialization): ${binToHex(bitcoinEncodedSignature)}`);
    }
    const coveredBytecode = encodeAuthenticationInstructions(state.instructions).subarray(state.lastCodeSeparator + 1);
    const { signingSerializationType, signature } = decodeBitcoinSignature(bitcoinEncodedSignature);
    const serialization = generateSigningSerializationBCH(state.program, { coveredBytecode, signingSerializationType }, sha2562);
    const digest = hash256(serialization, sha2562);
    state.signedMessages.push({ digest, serialization });
    const useSchnorr = signature.length === ConsensusCommon.schnorrSignatureLength;
    const success = useSchnorr ? secp256k12.verifySignatureSchnorr(signature, publicKey, digest) : secp256k12.verifySignatureDERLowS(signature, publicKey, digest);
    return !success && signature.length !== 0 ? applyError(state, AuthenticationErrorCommon.nonNullSignatureFailure) : pushToStack(state, booleanToVmNumber(success));
  })
);
var opCheckMultiSig = ({ secp256k1: secp256k12, sha256: sha2562 } = { secp256k1, sha256 }) => (s) => useOneVmNumber(s, (state, publicKeysValue) => {
  const potentialPublicKeys = Number(publicKeysValue);
  if (potentialPublicKeys < 0) {
    return applyError(state, AuthenticationErrorCommon.invalidNaturalNumber);
  }
  if (potentialPublicKeys > 20) {
    return applyError(state, AuthenticationErrorCommon.exceedsMaximumMultisigPublicKeyCount);
  }
  const publicKeys = (
    // eslint-disable-next-line functional/immutable-data
    potentialPublicKeys > 0 ? state.stack.splice(-potentialPublicKeys) : []
  );
  state.operationCount += potentialPublicKeys;
  return state.operationCount > ConsensusCommon.maximumOperationCount ? applyError(state, AuthenticationErrorCommon.exceededMaximumOperationCount) : useOneVmNumber(state, (nextState, approvingKeys) => {
    const requiredApprovingPublicKeys = Number(approvingKeys);
    if (requiredApprovingPublicKeys < 0) {
      return applyError(nextState, AuthenticationErrorCommon.invalidNaturalNumber);
    }
    if (requiredApprovingPublicKeys > potentialPublicKeys) {
      return applyError(nextState, AuthenticationErrorCommon.insufficientPublicKeys);
    }
    const signatures = requiredApprovingPublicKeys > 0 ? (
      // eslint-disable-next-line functional/immutable-data
      nextState.stack.splice(-requiredApprovingPublicKeys)
    ) : [];
    return useOneStackItem(
      nextState,
      // eslint-disable-next-line complexity
      (finalState, [protocolBugValue]) => {
        if (protocolBugValue.length !== 0) {
          return applyError(finalState, AuthenticationErrorCommon.invalidProtocolBugValue);
        }
        const coveredBytecode = encodeAuthenticationInstructions(finalState.instructions).subarray(finalState.lastCodeSeparator + 1);
        let approvingPublicKeys = 0;
        let remainingSignatures = signatures.length;
        let remainingPublicKeys = publicKeys.length;
        while (remainingSignatures > 0 && remainingPublicKeys > 0 && approvingPublicKeys + remainingPublicKeys >= remainingSignatures && approvingPublicKeys !== requiredApprovingPublicKeys) {
          const publicKey = publicKeys[remainingPublicKeys - 1];
          const bitcoinEncodedSignature = (
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            signatures[remainingSignatures - 1]
          );
          if (!isValidPublicKeyEncoding(publicKey)) {
            return applyError(finalState, AuthenticationErrorCommon.invalidPublicKeyEncoding);
          }
          if (!isValidSignatureEncodingBCHTransaction(bitcoinEncodedSignature, SigningSerializationTypesBCH)) {
            return applyError(finalState, AuthenticationErrorCommon.invalidSignatureEncoding, `Transaction signature (including signing serialization type): ${binToHex(bitcoinEncodedSignature)}`);
          }
          const { signingSerializationType, signature } = decodeBitcoinSignature(bitcoinEncodedSignature);
          const serialization = generateSigningSerializationBCH(state.program, { coveredBytecode, signingSerializationType }, sha2562);
          const digest = hash256(serialization, sha2562);
          finalState.signedMessages.push({ digest, serialization });
          if (signature.length === ConsensusCommon.schnorrSignatureLength) {
            return applyError(finalState, AuthenticationErrorCommon.schnorrSizedSignatureInCheckMultiSig);
          }
          const signed = secp256k12.verifySignatureDERLowS(signature, publicKey, digest);
          if (signed) {
            approvingPublicKeys += 1;
            remainingSignatures -= 1;
          }
          remainingPublicKeys -= 1;
        }
        const success = approvingPublicKeys === requiredApprovingPublicKeys;
        if (!success && !signatures.every((signature) => signature.length === 0)) {
          return applyError(finalState, AuthenticationErrorCommon.nonNullSignatureFailure);
        }
        return pushToStack(finalState, booleanToVmNumber(success));
      }
    );
  });
});
var opCheckSigVerify = ({ secp256k1: secp256k12, sha256: sha2562 } = { secp256k1, sha256 }) => combineOperations(opCheckSig({ secp256k1: secp256k12, sha256: sha2562 }), opVerify);
var opCheckMultiSigVerify = ({ secp256k1: secp256k12, sha256: sha2562 }) => combineOperations(opCheckMultiSig({ secp256k1: secp256k12, sha256: sha2562 }), opVerify);
var isValidSignatureEncodingBCHRaw = (signature) => signature.length === 0 || signature.length === ConsensusCommon.schnorrSignatureLength || isValidSignatureEncodingDER(signature);
var opCheckDataSig = ({ secp256k1: secp256k12, sha256: sha2562 }) => (state) => (
  // eslint-disable-next-line complexity
  useThreeStackItems(state, (nextState, [signature, message, publicKey]) => {
    if (!isValidSignatureEncodingBCHRaw(signature)) {
      return applyError(nextState, AuthenticationErrorCommon.invalidSignatureEncoding, `Data signature: ${binToHex(signature)}`);
    }
    if (!isValidPublicKeyEncoding(publicKey)) {
      return applyError(nextState, AuthenticationErrorCommon.invalidPublicKeyEncoding);
    }
    const digest = sha2562.hash(message);
    nextState.signedMessages.push({ digest, message });
    const useSchnorr = signature.length === ConsensusCommon.schnorrSignatureLength;
    const success = useSchnorr ? secp256k12.verifySignatureSchnorr(signature, publicKey, digest) : secp256k12.verifySignatureDERLowS(signature, publicKey, digest);
    return !success && signature.length !== 0 ? applyError(nextState, AuthenticationErrorCommon.nonNullSignatureFailure) : pushToStack(nextState, booleanToVmNumber(success));
  })
);
var opCheckDataSigVerify = ({ secp256k1: secp256k12, sha256: sha2562 } = { secp256k1, sha256 }) => combineOperations(opCheckDataSig({ secp256k1: secp256k12, sha256: sha2562 }), opVerify);
var opReverseBytes = (state) => useOneStackItem(state, (nextState, [item]) => pushToStack(nextState, item.slice().reverse()));

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/common/format.js
var import_dist178 = __toESM(require_dist(), 1);
var import_dist179 = __toESM(require_dist2(), 1);
var import_dist180 = __toESM(require_dist3(), 1);
var opCat = (state) => useTwoStackItems(state, (nextState, [a, b]) => pushToStackChecked(nextState, flattenBinArray([a, b])));
var opSplit = (state) => useOneVmNumber(state, (nextState, value) => {
  const index2 = Number(value);
  return useOneStackItem(nextState, (finalState, [item]) => index2 < 0 || index2 > item.length ? applyError(finalState, AuthenticationErrorCommon.invalidSplitIndex) : pushToStack(finalState, item.slice(0, index2), item.slice(index2)));
});
var padMinimallyEncodedVmNumber = (vmNumber, length) => {
  let signBit = 0;
  if (vmNumber.length > 0) {
    signBit = vmNumber[vmNumber.length - 1] & 128;
    vmNumber[vmNumber.length - 1] &= 128 - 1;
  }
  const result = Array.from(vmNumber);
  while (result.length < length - 1) {
    result.push(0);
  }
  result.push(signBit);
  return Uint8Array.from(result);
};
var opNum2Bin = (state) => useOneVmNumber(state, (nextState, value) => {
  const targetLength = Number(value);
  return targetLength > ConsensusCommon.maximumStackItemLength ? applyError(nextState, `${AuthenticationErrorCommon.exceededMaximumStackItemLength} Item length: ${targetLength} bytes.`) : useOneVmNumber(nextState, (finalState, [target]) => {
    const minimallyEncoded = bigIntToVmNumber(target);
    return minimallyEncoded.length > targetLength ? applyError(finalState, AuthenticationErrorCommon.insufficientLength) : minimallyEncoded.length === targetLength ? pushToStack(finalState, minimallyEncoded) : pushToStack(finalState, padMinimallyEncodedVmNumber(minimallyEncoded, targetLength));
  }, {
    maximumVmNumberByteLength: (
      // TODO: is this right?
      ConsensusCommon.maximumStackItemLength
    ),
    requireMinimalEncoding: false
  });
});
var opBin2Num = (state) => useOneVmNumber(state, (nextState, [target]) => {
  const minimallyEncoded = bigIntToVmNumber(target);
  return minimallyEncoded.length > ConsensusCommon.maximumVmNumberLength ? applyError(nextState, AuthenticationErrorCommon.exceededMaximumVmNumberLength) : pushToStack(nextState, minimallyEncoded);
}, {
  // TODO: is this right?
  maximumVmNumberByteLength: ConsensusCommon.maximumStackItemLength,
  requireMinimalEncoding: false
});

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/common/inspection.js
var import_dist181 = __toESM(require_dist(), 1);
var import_dist182 = __toESM(require_dist2(), 1);
var import_dist183 = __toESM(require_dist3(), 1);
var opInputIndex = (state) => pushToStackVmNumberChecked(state, BigInt(state.program.inputIndex));
var opActiveBytecode = (state) => pushToStackChecked(state, encodeAuthenticationInstructions(state.instructions.slice(state.lastCodeSeparator + 1)));
var opTxVersion = (state) => pushToStackVmNumberChecked(state, BigInt(int32UnsignedToSigned(state.program.transaction.version)));
var opTxInputCount = (state) => pushToStackVmNumberChecked(state, BigInt(state.program.transaction.inputs.length));
var opTxOutputCount = (state) => pushToStackVmNumberChecked(state, BigInt(state.program.transaction.outputs.length));
var opTxLocktime = (state) => pushToStackVmNumberChecked(state, BigInt(state.program.transaction.locktime));
var useTransactionUtxo = (state, operation) => useOneVmNumber(state, (nextState, [index2]) => {
  const utxo = nextState.program.sourceOutputs[Number(index2)];
  if (utxo === void 0) {
    return applyError(nextState, AuthenticationErrorCommon.invalidTransactionUtxoIndex);
  }
  return operation(state, [utxo]);
});
var opUtxoValue = (state) => useTransactionUtxo(state, (nextState, [utxo]) => pushToStackVmNumberChecked(nextState, utxo.valueSatoshis));
var opUtxoBytecode = (state) => useTransactionUtxo(state, (nextState, [utxo]) => pushToStackChecked(nextState, utxo.lockingBytecode.slice()));
var useTransactionInput = (state, operation) => useOneVmNumber(state, (nextState, [index2]) => {
  const input = nextState.program.transaction.inputs[Number(index2)];
  if (input === void 0) {
    return applyError(nextState, AuthenticationErrorCommon.invalidTransactionInputIndex);
  }
  return operation(state, [input]);
});
var opOutpointTxHash = (state) => useTransactionInput(state, (nextState, [input]) => pushToStackChecked(nextState, input.outpointTransactionHash.slice().reverse()));
var opOutpointIndex = (state) => useTransactionInput(state, (nextState, [input]) => pushToStackVmNumberChecked(nextState, BigInt(input.outpointIndex)));
var opInputBytecode = (state) => useTransactionInput(state, (nextState, [input]) => pushToStackChecked(nextState, input.unlockingBytecode.slice()));
var opInputSequenceNumber = (state) => useTransactionInput(state, (nextState, [input]) => pushToStackVmNumberChecked(nextState, BigInt(input.sequenceNumber)));
var useTransactionOutput = (state, operation) => useOneVmNumber(state, (nextState, [index2]) => {
  const input = nextState.program.transaction.outputs[Number(index2)];
  if (input === void 0) {
    return applyError(nextState, AuthenticationErrorCommon.invalidTransactionOutputIndex);
  }
  return operation(state, [input]);
});
var opOutputValue = (state) => useTransactionOutput(state, (nextState, [output]) => pushToStackVmNumberChecked(nextState, output.valueSatoshis));
var opOutputBytecode = (state) => useTransactionOutput(state, (nextState, [output]) => pushToStackChecked(nextState, output.lockingBytecode.slice()));

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/common/instruction-sets-types.js
var import_dist184 = __toESM(require_dist(), 1);
var import_dist185 = __toESM(require_dist2(), 1);
var import_dist186 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/common/nop.js
var import_dist187 = __toESM(require_dist(), 1);
var import_dist188 = __toESM(require_dist2(), 1);
var import_dist189 = __toESM(require_dist3(), 1);
var opNop = (state) => state;
var opNopDisallowed = (state) => applyError(state, AuthenticationErrorCommon.calledUpgradableNop);
var disabledOperation = (state) => applyError(state, AuthenticationErrorCommon.unknownOpcode);

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/common/push.js
var import_dist190 = __toESM(require_dist(), 1);
var import_dist191 = __toESM(require_dist2(), 1);
var import_dist192 = __toESM(require_dist3(), 1);
var encodeDataPush = (data) => data.length <= 75 ? data.length === 0 ? Uint8Array.of(0) : data.length === 1 ? (
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  data[0] !== 0 && data[0] <= 16 ? Uint8Array.of(
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    data[0] + 80
    /* PushOperationConstants.pushNumberOpcodesOffset */
  ) : data[0] === 129 ? Uint8Array.of(
    79
    /* PushOperationConstants.OP_1NEGATE */
  ) : Uint8Array.from([1, ...data])
) : Uint8Array.from([data.length, ...data]) : data.length <= 255 ? Uint8Array.from([
  76,
  data.length,
  ...data
]) : data.length <= 65535 ? Uint8Array.from([
  77,
  ...numberToBinUint16LE(data.length),
  ...data
]) : Uint8Array.from([
  78,
  ...numberToBinUint32LE(data.length),
  ...data
]);
var isMinimalDataPush = (opcode, data) => {
  if (data.length === 0) {
    return opcode === 0;
  }
  if (data.length === 1) {
    if (data[0] >= 1 && data[0] <= 16) {
      return (
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        opcode === data[0] + 80
      );
    }
    if (data[0] === 129) {
      return opcode === 79;
    }
    return true;
  }
  if (data.length <= 75) {
    return opcode === data.length;
  }
  if (data.length <= 255) {
    return opcode === 76;
  }
  if (data.length <= 65535) {
    return opcode === 77;
  }
  if (data.length <= 4294967295) {
    return opcode === 78;
  }
  return false;
};
var executionIsActive = (state) => state.controlStack.every((item) => item);
var pushOperation = (maximumPushSize = ConsensusCommon.maximumStackItemLength) => (state) => {
  const instruction = state.instructions[state.ip];
  return instruction.data.length > maximumPushSize ? applyError(state, `${AuthenticationErrorCommon.exceededMaximumStackItemLength} Item length: ${instruction.data.length} bytes.`) : executionIsActive(state) ? isMinimalDataPush(instruction.opcode, instruction.data) ? pushToStack(state, instruction.data) : applyError(state, AuthenticationErrorCommon.nonMinimalPush) : state;
};
var pushNumberOperation = (number) => {
  const value = bigIntToVmNumber(BigInt(number));
  return (state) => pushToStack(state, value);
};

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/common/stack.js
var import_dist193 = __toESM(require_dist(), 1);
var import_dist194 = __toESM(require_dist2(), 1);
var import_dist195 = __toESM(require_dist3(), 1);
var opToAltStack = (state) => useOneStackItem(state, (nextState, [item]) => {
  nextState.alternateStack.push(item);
  return nextState;
});
var opFromAltStack = (state) => {
  const item = state.alternateStack.pop();
  if (item === void 0) {
    return applyError(state, AuthenticationErrorCommon.emptyAlternateStack);
  }
  return pushToStack(state, item);
};
var op2Drop = (state) => useTwoStackItems(state, (nextState) => nextState);
var op2Dup = (state) => useTwoStackItems(state, (nextState, [a, b]) => pushToStack(nextState, a, b, a.slice(), b.slice()));
var op3Dup = (state) => useThreeStackItems(state, (nextState, [a, b, c]) => pushToStack(nextState, a, b, c, a.slice(), b.slice(), c.slice()));
var op2Over = (state) => useFourStackItems(state, (nextState, [a, b, c, d]) => pushToStack(nextState, a, b, c, d, a.slice(), b.slice()));
var op2Rot = (state) => useSixStackItems(state, (nextState, [a, b, c, d, e, f]) => pushToStack(nextState, c, d, e, f, a, b));
var op2Swap = (state) => useFourStackItems(state, (nextState, [a, b, c, d]) => pushToStack(nextState, c, d, a, b));
var opIfDup = (state) => useOneStackItem(state, (nextState, [item]) => pushToStack(nextState, ...stackItemIsTruthy(item) ? [item, item.slice()] : [item]));
var opDepth = (state) => pushToStack(state, bigIntToVmNumber(BigInt(state.stack.length)));
var opDrop = (state) => useOneStackItem(state, (nextState) => nextState);
var opDup = (state) => useOneStackItem(state, (nextState, [item]) => pushToStack(nextState, item, item.slice()));
var opNip = (state) => useTwoStackItems(state, (nextState, [, b]) => pushToStack(nextState, b));
var opOver = (state) => useTwoStackItems(state, (nextState, [a, b]) => pushToStack(nextState, a, b, a.slice()));
var opPick = (state) => useOneVmNumber(state, (nextState, depth) => {
  const item = nextState.stack[nextState.stack.length - 1 - Number(depth)];
  if (item === void 0) {
    return applyError(state, AuthenticationErrorCommon.invalidStackIndex);
  }
  return pushToStack(nextState, item.slice());
});
var opRoll = (state) => useOneVmNumber(state, (nextState, depth) => {
  const index2 = nextState.stack.length - 1 - Number(depth);
  if (index2 < 0 || index2 > nextState.stack.length - 1) {
    return applyError(state, AuthenticationErrorCommon.invalidStackIndex);
  }
  return pushToStack(nextState, nextState.stack.splice(index2, 1)[0]);
});
var opRot = (state) => useThreeStackItems(state, (nextState, [a, b, c]) => pushToStack(nextState, b, c, a));
var opSwap = (state) => useTwoStackItems(state, (nextState, [a, b]) => pushToStack(nextState, b, a));
var opTuck = (state) => useTwoStackItems(state, (nextState, [a, b]) => pushToStack(nextState, b.slice(), a, b));
var opSize = (state) => useOneStackItem(state, (nextState, [item]) => pushToStack(nextState, item, bigIntToVmNumber(BigInt(item.length))));

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/common/time.js
var import_dist196 = __toESM(require_dist(), 1);
var import_dist197 = __toESM(require_dist2(), 1);
var import_dist198 = __toESM(require_dist3(), 1);
var useLocktime = (state, operation) => {
  const item = state.stack[state.stack.length - 1];
  if (item === void 0) {
    return applyError(state, AuthenticationErrorCommon.emptyStack);
  }
  const decodedLocktime = vmNumberToBigInt(item, {
    maximumVmNumberByteLength: 5,
    requireMinimalEncoding: true
  });
  if (isVmNumberError(decodedLocktime)) {
    return applyError(state, AuthenticationErrorCommon.invalidVmNumber);
  }
  const locktime = Number(decodedLocktime);
  if (locktime < 0) {
    return applyError(state, AuthenticationErrorCommon.negativeLocktime);
  }
  return operation(state, locktime);
};
var locktimeTypesAreCompatible = (locktime, requiredLocktime) => locktime < 5e8 && requiredLocktime < 5e8 || locktime >= 5e8 && requiredLocktime >= 5e8;
var opCheckLockTimeVerify = (state) => useLocktime(state, (nextState, requiredLocktime) => {
  if (!locktimeTypesAreCompatible(nextState.program.transaction.locktime, requiredLocktime)) {
    return applyError(nextState, AuthenticationErrorCommon.incompatibleLocktimeType);
  }
  if (requiredLocktime > nextState.program.transaction.locktime) {
    return applyError(nextState, AuthenticationErrorCommon.unsatisfiedLocktime);
  }
  const { sequenceNumber } = (
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    nextState.program.transaction.inputs[nextState.program.inputIndex]
  );
  if (sequenceNumber === 4294967295) {
    return applyError(nextState, AuthenticationErrorCommon.locktimeDisabled);
  }
  return nextState;
});
var includesFlag = (value, flag) => (value & flag) !== 0;
var opCheckSequenceVerify = (state) => useLocktime(
  state,
  // eslint-disable-next-line complexity
  (nextState, requiredSequence) => {
    const { sequenceNumber } = (
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      nextState.program.transaction.inputs[nextState.program.inputIndex]
    );
    const sequenceLocktimeDisabled = includesFlag(
      requiredSequence,
      2147483648
      /* Constants.sequenceLocktimeDisableFlag */
    );
    if (sequenceLocktimeDisabled) {
      return nextState;
    }
    if (nextState.program.transaction.version < 2) {
      return applyError(nextState, AuthenticationErrorCommon.checkSequenceUnavailable);
    }
    if (includesFlag(
      sequenceNumber,
      2147483648
      /* Constants.sequenceLocktimeDisableFlag */
    )) {
      return applyError(nextState, AuthenticationErrorCommon.unmatchedSequenceDisable);
    }
    if (includesFlag(
      requiredSequence,
      4194304
      /* Constants.sequenceLocktimeTypeFlag */
    ) !== includesFlag(
      sequenceNumber,
      4194304
      /* Constants.sequenceLocktimeTypeFlag */
    )) {
      return applyError(nextState, AuthenticationErrorCommon.incompatibleSequenceType);
    }
    if (
      // eslint-disable-next-line no-bitwise
      (requiredSequence & 65535) > // eslint-disable-next-line no-bitwise
      (sequenceNumber & 65535)
    ) {
      return applyError(nextState, AuthenticationErrorCommon.unsatisfiedSequenceNumber);
    }
    return nextState;
  }
);

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/bch/2023/bch-2023.js
var import_dist226 = __toESM(require_dist(), 1);
var import_dist227 = __toESM(require_dist2(), 1);
var import_dist228 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/bch/2023/bch-2023-consensus.js
var import_dist202 = __toESM(require_dist(), 1);
var import_dist203 = __toESM(require_dist2(), 1);
var import_dist204 = __toESM(require_dist3(), 1);
var ConsensusBCH2023;
(function(ConsensusBCH20232) {
  ConsensusBCH20232[ConsensusBCH20232["maximumBytecodeLength"] = 1e4] = "maximumBytecodeLength";
  ConsensusBCH20232[ConsensusBCH20232["maximumDataCarrierBytes"] = 223] = "maximumDataCarrierBytes";
  ConsensusBCH20232[ConsensusBCH20232["maximumOperationCount"] = 201] = "maximumOperationCount";
  ConsensusBCH20232[ConsensusBCH20232["maximumStackDepth"] = 1e3] = "maximumStackDepth";
  ConsensusBCH20232[ConsensusBCH20232["maximumStackItemLength"] = 520] = "maximumStackItemLength";
  ConsensusBCH20232[ConsensusBCH20232["maximumStandardVersion"] = 2] = "maximumStandardVersion";
  ConsensusBCH20232[ConsensusBCH20232["maximumStandardUnlockingBytecodeLength"] = 1650] = "maximumStandardUnlockingBytecodeLength";
  ConsensusBCH20232[ConsensusBCH20232["minimumTransactionSize"] = 65] = "minimumTransactionSize";
  ConsensusBCH20232[ConsensusBCH20232["maximumStandardTransactionSize"] = 1e5] = "maximumStandardTransactionSize";
  ConsensusBCH20232[ConsensusBCH20232["maximumTransactionSize"] = 1e6] = "maximumTransactionSize";
  ConsensusBCH20232[ConsensusBCH20232["maximumVmNumberLength"] = 8] = "maximumVmNumberLength";
  ConsensusBCH20232["minVmNumber"] = "-9223372036854775807";
  ConsensusBCH20232["maxVmNumber"] = "9223372036854775807";
  ConsensusBCH20232[ConsensusBCH20232["schnorrSignatureLength"] = 64] = "schnorrSignatureLength";
  ConsensusBCH20232[ConsensusBCH20232["maximumCommitmentLength"] = 40] = "maximumCommitmentLength";
})(ConsensusBCH2023 || (ConsensusBCH2023 = {}));
var SigningSerializationTypesBCH2023 = [
  ...SigningSerializationTypesBCH,
  SigningSerializationTypeBCH.allOutputsAllUtxos,
  SigningSerializationTypeBCH.correspondingOutputAllUtxos,
  SigningSerializationTypeBCH.noOutputsAllUtxos
];

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/bch/2023/bch-2023-crypto.js
var import_dist205 = __toESM(require_dist(), 1);
var import_dist206 = __toESM(require_dist2(), 1);
var import_dist207 = __toESM(require_dist3(), 1);
var opCheckSigBCH2023 = ({ secp256k1: secp256k12, sha256: sha2562 } = { secp256k1, sha256 }) => (s) => (
  // eslint-disable-next-line complexity
  useTwoStackItems(s, (state, [bitcoinEncodedSignature, publicKey]) => {
    if (!isValidPublicKeyEncoding(publicKey)) {
      return applyError(state, AuthenticationErrorCommon.invalidPublicKeyEncoding);
    }
    if (!isValidSignatureEncodingBCHTransaction(bitcoinEncodedSignature, SigningSerializationTypesBCH2023)) {
      return applyError(state, AuthenticationErrorCommon.invalidSignatureEncoding, `Transaction signature (including signing serialization): ${binToHex(bitcoinEncodedSignature)}`);
    }
    const coveredBytecode = encodeAuthenticationInstructions(state.instructions).subarray(state.lastCodeSeparator + 1);
    const { signingSerializationType, signature } = decodeBitcoinSignature(bitcoinEncodedSignature);
    const serialization = generateSigningSerializationBCH(state.program, { coveredBytecode, signingSerializationType }, sha2562);
    const digest = hash256(serialization, sha2562);
    state.signedMessages.push({ digest, serialization });
    const useSchnorr = signature.length === ConsensusCommon.schnorrSignatureLength;
    const success = useSchnorr ? secp256k12.verifySignatureSchnorr(signature, publicKey, digest) : secp256k12.verifySignatureDERLowS(signature, publicKey, digest);
    return !success && signature.length !== 0 ? applyError(state, AuthenticationErrorCommon.nonNullSignatureFailure) : pushToStack(state, booleanToVmNumber(success));
  })
);
var opCheckMultiSigBCH2023 = ({ secp256k1: secp256k12, sha256: sha2562 } = { secp256k1, sha256 }) => (s) => useOneVmNumber(s, (state, publicKeysValue) => {
  const potentialPublicKeys = Number(publicKeysValue);
  if (potentialPublicKeys < 0) {
    return applyError(state, AuthenticationErrorCommon.invalidNaturalNumber);
  }
  if (potentialPublicKeys > 20) {
    return applyError(state, AuthenticationErrorCommon.exceedsMaximumMultisigPublicKeyCount);
  }
  const publicKeys = (
    // eslint-disable-next-line functional/immutable-data
    potentialPublicKeys > 0 ? state.stack.splice(-potentialPublicKeys) : []
  );
  state.operationCount += potentialPublicKeys;
  return state.operationCount > ConsensusCommon.maximumOperationCount ? applyError(state, AuthenticationErrorCommon.exceededMaximumOperationCount) : useOneVmNumber(state, (nextState, approvingKeys) => {
    const requiredApprovingPublicKeys = Number(approvingKeys);
    if (requiredApprovingPublicKeys < 0) {
      return applyError(nextState, AuthenticationErrorCommon.invalidNaturalNumber);
    }
    if (requiredApprovingPublicKeys > potentialPublicKeys) {
      return applyError(nextState, AuthenticationErrorCommon.insufficientPublicKeys);
    }
    const signatures = requiredApprovingPublicKeys > 0 ? (
      // eslint-disable-next-line functional/immutable-data
      nextState.stack.splice(-requiredApprovingPublicKeys)
    ) : [];
    return useOneStackItem(
      nextState,
      // eslint-disable-next-line complexity
      (finalState, [protocolBugValue]) => {
        if (protocolBugValue.length !== 0) {
          return applyError(finalState, AuthenticationErrorCommon.invalidProtocolBugValue);
        }
        const coveredBytecode = encodeAuthenticationInstructions(finalState.instructions).subarray(finalState.lastCodeSeparator + 1);
        let approvingPublicKeys = 0;
        let remainingSignatures = signatures.length;
        let remainingPublicKeys = publicKeys.length;
        while (remainingSignatures > 0 && remainingPublicKeys > 0 && approvingPublicKeys + remainingPublicKeys >= remainingSignatures && approvingPublicKeys !== requiredApprovingPublicKeys) {
          const publicKey = publicKeys[remainingPublicKeys - 1];
          const bitcoinEncodedSignature = (
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            signatures[remainingSignatures - 1]
          );
          if (!isValidPublicKeyEncoding(publicKey)) {
            return applyError(finalState, AuthenticationErrorCommon.invalidPublicKeyEncoding);
          }
          if (!isValidSignatureEncodingBCHTransaction(bitcoinEncodedSignature, SigningSerializationTypesBCH2023)) {
            return applyError(finalState, AuthenticationErrorCommon.invalidSignatureEncoding, `Transaction signature (including signing serialization type): ${binToHex(bitcoinEncodedSignature)}`);
          }
          const { signingSerializationType, signature } = decodeBitcoinSignature(bitcoinEncodedSignature);
          const serialization = generateSigningSerializationBCH(state.program, { coveredBytecode, signingSerializationType }, sha2562);
          const digest = hash256(serialization, sha2562);
          finalState.signedMessages.push({ digest, serialization });
          if (signature.length === ConsensusCommon.schnorrSignatureLength) {
            return applyError(finalState, AuthenticationErrorCommon.schnorrSizedSignatureInCheckMultiSig);
          }
          const signed = secp256k12.verifySignatureDERLowS(signature, publicKey, digest);
          if (signed) {
            approvingPublicKeys += 1;
            remainingSignatures -= 1;
          }
          remainingPublicKeys -= 1;
        }
        const success = approvingPublicKeys === requiredApprovingPublicKeys;
        if (!success && !signatures.every((signature) => signature.length === 0)) {
          return applyError(finalState, AuthenticationErrorCommon.nonNullSignatureFailure);
        }
        return pushToStack(finalState, booleanToVmNumber(success));
      }
    );
  });
});
var opCheckSigVerifyBCH2023 = ({ secp256k1: secp256k12, sha256: sha2562 } = { secp256k1, sha256 }) => combineOperations(opCheckSigBCH2023({ secp256k1: secp256k12, sha256: sha2562 }), opVerify);
var opCheckMultiSigVerifyBCH2023 = ({ secp256k1: secp256k12, sha256: sha2562 }) => combineOperations(opCheckMultiSigBCH2023({ secp256k1: secp256k12, sha256: sha2562 }), opVerify);

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/bch/2023/bch-2023-descriptions.js
var import_dist208 = __toESM(require_dist(), 1);
var import_dist209 = __toESM(require_dist2(), 1);
var import_dist210 = __toESM(require_dist3(), 1);
var OpcodeDescriptionsBCH2023;
(function(OpcodeDescriptionsBCH20232) {
  OpcodeDescriptionsBCH20232["OP_0"] = "Push the VM Number 0 onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_1"] = "Push the next byte onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_2"] = "Push the next 2 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_3"] = "Push the next 3 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_4"] = "Push the next 4 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_5"] = "Push the next 5 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_6"] = "Push the next 6 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_7"] = "Push the next 7 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_8"] = "Push the next 8 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_9"] = "Push the next 9 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_10"] = "Push the next 10 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_11"] = "Push the next 11 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_12"] = "Push the next 12 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_13"] = "Push the next 13 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_14"] = "Push the next 14 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_15"] = "Push the next 15 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_16"] = "Push the next 16 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_17"] = "Push the next 17 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_18"] = "Push the next 18 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_19"] = "Push the next 19 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_20"] = "Push the next 20 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_21"] = "Push the next 21 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_22"] = "Push the next 22 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_23"] = "Push the next 23 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_24"] = "Push the next 24 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_25"] = "Push the next 25 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_26"] = "Push the next 26 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_27"] = "Push the next 27 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_28"] = "Push the next 28 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_29"] = "Push the next 29 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_30"] = "Push the next 30 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_31"] = "Push the next 31 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_32"] = "Push the next 32 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_33"] = "Push the next 33 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_34"] = "Push the next 34 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_35"] = "Push the next 35 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_36"] = "Push the next 36 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_37"] = "Push the next 37 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_38"] = "Push the next 38 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_39"] = "Push the next 39 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_40"] = "Push the next 40 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_41"] = "Push the next 41 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_42"] = "Push the next 42 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_43"] = "Push the next 43 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_44"] = "Push the next 44 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_45"] = "Push the next 45 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_46"] = "Push the next 46 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_47"] = "Push the next 47 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_48"] = "Push the next 48 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_49"] = "Push the next 49 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_50"] = "Push the next 50 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_51"] = "Push the next 51 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_52"] = "Push the next 52 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_53"] = "Push the next 53 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_54"] = "Push the next 54 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_55"] = "Push the next 55 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_56"] = "Push the next 56 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_57"] = "Push the next 57 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_58"] = "Push the next 58 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_59"] = "Push the next 59 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_60"] = "Push the next 60 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_61"] = "Push the next 61 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_62"] = "Push the next 62 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_63"] = "Push the next 63 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_64"] = "Push the next 64 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_65"] = "Push the next 65 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_66"] = "Push the next 66 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_67"] = "Push the next 67 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_68"] = "Push the next 68 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_69"] = "Push the next 69 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_70"] = "Push the next 70 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_71"] = "Push the next 71 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_72"] = "Push the next 72 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_73"] = "Push the next 73 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_74"] = "Push the next 74 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHBYTES_75"] = "Push the next 75 bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHDATA_1"] = "Read the next Uint8 and push that number of bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHDATA_2"] = "Read the next little-endian Uint16 and push that number of bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_PUSHDATA_4"] = "Read the next little-endian Uint32 and push that number of bytes onto the stack.";
  OpcodeDescriptionsBCH20232["OP_1NEGATE"] = "Push the VM Number -1 onto the stack.";
  OpcodeDescriptionsBCH20232["OP_RESERVED"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED does not count toward the opcode limit.";
  OpcodeDescriptionsBCH20232["OP_1"] = "Push a 1 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH20232["OP_2"] = "Push a 2 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH20232["OP_3"] = "Push a 3 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH20232["OP_4"] = "Push a 4 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH20232["OP_5"] = "Push a 5 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH20232["OP_6"] = "Push a 6 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH20232["OP_7"] = "Push a 7 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH20232["OP_8"] = "Push a 8 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH20232["OP_9"] = "Push a 9 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH20232["OP_10"] = "Push a 10 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH20232["OP_11"] = "Push a 11 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH20232["OP_12"] = "Push a 12 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH20232["OP_13"] = "Push a 13 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH20232["OP_14"] = "Push a 14 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH20232["OP_15"] = "Push a 15 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH20232["OP_16"] = "Push a 16 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH20232["OP_NOP"] = "No operation. Note: OP_NOP counts toward the opcode limit.";
  OpcodeDescriptionsBCH20232["OP_VER"] = "Error unless found in an unexecuted conditional branch. Note: OP_VER counts toward the opcode limit. (Historically, this pushed a protocol version number to the stack.)";
  OpcodeDescriptionsBCH20232["OP_IF"] = 'Pop the top item from the stack. If it is not "truthy", skip evaluation until a matching OP_ELSE or OP_ENDIF.';
  OpcodeDescriptionsBCH20232["OP_NOTIF"] = 'Pop the top item from the stack. If it is "truthy", skip evaluation until a matching OP_ELSE or OP_ENDIF.';
  OpcodeDescriptionsBCH20232["OP_VERIF"] = "Error, even when found in an unexecuted conditional branch. (Historically, this was a combination of OP_VER and OP_IF.)";
  OpcodeDescriptionsBCH20232["OP_VERNOTIF"] = "Error, even when found in an unexecuted conditional branch. (Historically, this was a combination of OP_VER and OP_NOTIF.)";
  OpcodeDescriptionsBCH20232["OP_ELSE"] = "Invert conditional evaluation within the current OP_IF ... OP_ENDIF block. (If evaluation is enabled, disable it, if it is disabled, enable it.)";
  OpcodeDescriptionsBCH20232["OP_ENDIF"] = "End the current OP_IF/OP_NOTIF ... OP_ENDIF block.";
  OpcodeDescriptionsBCH20232["OP_VERIFY"] = `Pop the top item from the stack and error if it isn't "truthy".`;
  OpcodeDescriptionsBCH20232["OP_RETURN"] = "Error when executed.";
  OpcodeDescriptionsBCH20232["OP_TOALTSTACK"] = "Pop the top item from the stack and push it onto the alternate stack.";
  OpcodeDescriptionsBCH20232["OP_FROMALTSTACK"] = "Pop the top item from the alternate stack and push it onto the stack.";
  OpcodeDescriptionsBCH20232["OP_2DROP"] = "Pop the top 2 items from the stack and discard them.";
  OpcodeDescriptionsBCH20232["OP_2DUP"] = "Duplicate the top 2 items on the stack. (E.g. [a, b] -> [a, b, a, b])";
  OpcodeDescriptionsBCH20232["OP_3DUP"] = "Duplicate the top 3 items on the stack. (E.g. [a, b, c] -> [a, b, c, a, b, c])";
  OpcodeDescriptionsBCH20232["OP_2OVER"] = "Duplicate the 2 items beginning at a depth of 2 on the stack. (E.g. [a, b, c, d] -> [a, b, c, d, a, b])";
  OpcodeDescriptionsBCH20232["OP_2ROT"] = "Rotate the top 6 items on the stack, bringing the fifth and sixth items to the top. (E.g. [a, b, c, d, e, f] -> [c, d, e, f, a, b])";
  OpcodeDescriptionsBCH20232["OP_2SWAP"] = "Swap the positions of the top two pairs of items on the stack. (E.g. [a, b, c, d] -> [c, d, a, b])";
  OpcodeDescriptionsBCH20232["OP_IFDUP"] = 'If the top item on the stack is "truthy", duplicate it.';
  OpcodeDescriptionsBCH20232["OP_DEPTH"] = "Push the current number of stack items as a VM Number.";
  OpcodeDescriptionsBCH20232["OP_DROP"] = "Pop the top item from the stack and discard it. (E.g. [a] -> [])";
  OpcodeDescriptionsBCH20232["OP_DUP"] = "Duplicate the top item on the stack. (E.g. [a] -> [a, a])";
  OpcodeDescriptionsBCH20232["OP_NIP"] = "Remove the second-to-top item from the stack. (E.g. [a, b] -> [b])";
  OpcodeDescriptionsBCH20232["OP_OVER"] = "Duplicate the second-to-top item on the stack. (E.g. [a, b] -> [a, b, a])";
  OpcodeDescriptionsBCH20232["OP_PICK"] = "Pop the top item from the stack as a VM Number. Duplicate the item at that depth (zero-indexed), placing it on top of the stack. (E.g. [a, b, c, 2] -> [a, b, c, a])";
  OpcodeDescriptionsBCH20232["OP_ROLL"] = "Pop the top item from the stack as a VM Number. Move the item at that depth (zero-indexed) to the top of the stack. (E.g. [a, b, c, 2] -> [b, c, a])";
  OpcodeDescriptionsBCH20232["OP_ROT"] = "Rotate the top 3 items on the stack, bringing the third item to the top. (E.g. [a, b, c] -> [b, c, a])";
  OpcodeDescriptionsBCH20232["OP_SWAP"] = "Swap the top two items on the stack. (E.g. [a, b] -> [b, a])";
  OpcodeDescriptionsBCH20232["OP_TUCK"] = "Duplicate the item at the top of the stack, inserting it below the second-to-top item. (E.g. [a, b] -> [b, a, b])";
  OpcodeDescriptionsBCH20232["OP_CAT"] = "Pop the top 2 items from the stack and concatenate them, pushing the result.";
  OpcodeDescriptionsBCH20232["OP_SPLIT"] = "Pop the top item from the stack as an index (VM Number) and the next item as a byte array. Split the byte array into two stack items at the index (zero-based), pushing the results.";
  OpcodeDescriptionsBCH20232["OP_NUM2BIN"] = "Pop the top item from the stack as an item length (VM Number) and the next item as a VM Number (without encoding restrictions). Re-encode the number using a byte array of the provided length, filling any unused bytes with zeros, then push the result. (If the requested length is too short to encode the number, error.)";
  OpcodeDescriptionsBCH20232["OP_BIN2NUM"] = "Pop the top item from the stack as a VM Number without encoding restrictions. Minimally-encode the number and push the result. (If the number can't be encoded in 4 bytes or less, error.)";
  OpcodeDescriptionsBCH20232["OP_SIZE"] = "Push the byte-length of the top stack item as a VM Number.";
  OpcodeDescriptionsBCH20232["OP_INVERT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this flipped all the bits in a stack item.)";
  OpcodeDescriptionsBCH20232["OP_AND"] = "Pop the top 2 items from the stack and perform a bitwise AND on each byte, pushing the result. If the length of the items are not equal, error.";
  OpcodeDescriptionsBCH20232["OP_OR"] = "Pop the top 2 items from the stack and perform a bitwise OR on each byte, pushing the result. If the length of the items are not equal, error.";
  OpcodeDescriptionsBCH20232["OP_XOR"] = "Pop the top 2 items from the stack and perform a bitwise XOR on each byte, pushing the result. If the length of the items are not equal, error.";
  OpcodeDescriptionsBCH20232["OP_EQUAL"] = "Pop the top two items from the stack and compare them byte-by-byte. If they are the same, push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsBCH20232["OP_EQUALVERIFY"] = "Pop the top two items from the stack and compare them byte-by-byte. If the values are different, error. (This operation is a combination of OP_EQUAL followed by OP_VERIFY.)";
  OpcodeDescriptionsBCH20232["OP_RESERVED1"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED1 counts toward the opcode limit.";
  OpcodeDescriptionsBCH20232["OP_RESERVED2"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED2 counts toward the opcode limit.";
  OpcodeDescriptionsBCH20232["OP_1ADD"] = "Pop the top item from the stack as a VM Number, add 1, then push the result.";
  OpcodeDescriptionsBCH20232["OP_1SUB"] = "Pop the top item from the stack as a VM Number, subtract 1, then push the result.";
  OpcodeDescriptionsBCH20232["OP_2MUL"] = "Error, even when found in an unexecuted conditional branch. (Historically, this multiplied a VM Number by 2.)";
  OpcodeDescriptionsBCH20232["OP_2DIV"] = "Error, even when found in an unexecuted conditional branch. (Historically, this divided a VM Number by 2.)";
  OpcodeDescriptionsBCH20232["OP_NEGATE"] = "Pop the top item from the stack as a VM Number, negate it, then push the result.";
  OpcodeDescriptionsBCH20232["OP_ABS"] = "Pop the top item from the stack as a VM Number, take its absolute value, then push the result.";
  OpcodeDescriptionsBCH20232["OP_NOT"] = "Pop the top item from the stack as a VM Number. If its value is 0, push a 1 (VM Number), otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH20232["OP_0NOTEQUAL"] = "Pop the top item from the stack as a VM Number. If its value is not 0, push a 1 (VM Number), otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH20232["OP_ADD"] = "Pop the top two items from the stack as VM Numbers. Add them, then push the result.";
  OpcodeDescriptionsBCH20232["OP_SUB"] = "Pop the top two items from the stack as VM Numbers. Subtract the top item from the second item, then push the result.";
  OpcodeDescriptionsBCH20232["OP_MUL"] = "Pop the top two items from the stack as VM Numbers. Multiply them, then push the result.";
  OpcodeDescriptionsBCH20232["OP_DIV"] = "Pop the top item from the stack as a denominator (VM Number) and the next as a numerator (VM Number). Divide and push the result to the stack.";
  OpcodeDescriptionsBCH20232["OP_MOD"] = "Pop the top item from the stack as a denominator (VM Number) and the next as a numerator (VM Number). Divide and push the remainder to the stack.";
  OpcodeDescriptionsBCH20232["OP_LSHIFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a sign-preserving, left bit shift.)";
  OpcodeDescriptionsBCH20232["OP_RSHIFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a sign-preserving, right bit shift.)";
  OpcodeDescriptionsBCH20232["OP_BOOLAND"] = "Pop the top two items from the stack as VM Numbers. If neither value is a 0 (VM Number), push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH20232["OP_BOOLOR"] = "Pop the top two items from the stack as VM Numbers. If either value is a 1 (VM Number), push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH20232["OP_NUMEQUAL"] = "Pop the top two items from the stack as VM Numbers. If the values are equal, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH20232["OP_NUMEQUALVERIFY"] = "Pop the top two items from the stack as VM Numbers. If the values are different, error. (This operation is a combination of OP_NUMEQUAL followed by OP_VERIFY.)";
  OpcodeDescriptionsBCH20232["OP_NUMNOTEQUAL"] = "Pop the top two items from the stack as VM Numbers. If the values are not equal, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH20232["OP_LESSTHAN"] = "Pop the top two items from the stack as VM Numbers. If the second item is less than top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH20232["OP_GREATERTHAN"] = "Pop the top two items from the stack as VM Numbers. If the second item is greater than top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH20232["OP_LESSTHANOREQUAL"] = "Pop the top two items from the stack as VM Numbers. If the second item is less than or equal to the top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH20232["OP_GREATERTHANOREQUAL"] = "Pop the top two items from the stack as VM Numbers. If the second item is greater than or equal to the top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH20232["OP_MIN"] = "Pop the top two items from the stack as VM Numbers. Push the smaller of the two numbers.";
  OpcodeDescriptionsBCH20232["OP_MAX"] = "Pop the top two items from the stack as VM Numbers. Push the larger of the two numbers.";
  OpcodeDescriptionsBCH20232["OP_WITHIN"] = "Pop the top three items from the stack as VM Numbers. If the top number is within the range defined by the following two numbers (left-inclusive), push a 1 (VM Number). Otherwise, push a 0 (VM Number). (E.g. for [a, b, c]: if (b <= a), and (a < c), [1]. Else [0].)";
  OpcodeDescriptionsBCH20232["OP_RIPEMD160"] = "Pop the top item from the stack and pass it through ripemd160, pushing the result onto the stack.";
  OpcodeDescriptionsBCH20232["OP_SHA1"] = "Pop the top item from the stack and pass it through sha1, pushing the result onto the stack.";
  OpcodeDescriptionsBCH20232["OP_SHA256"] = "Pop the top item from the stack and pass it through sha256, pushing the result onto the stack.";
  OpcodeDescriptionsBCH20232["OP_HASH160"] = "Pop the top item from the stack and pass it through sha256, then ripemd160, pushing the result onto the stack.";
  OpcodeDescriptionsBCH20232["OP_HASH256"] = "Pop the top item from the stack and pass it through sha256 twice, pushing the result onto the stack.";
  OpcodeDescriptionsBCH20232["OP_CODESEPARATOR"] = "Update the value of lastCodeSeparator to the instruction pointer's current value. (This reduces the coverage of signing serializations used in signature verification operations.)";
  OpcodeDescriptionsBCH20232["OP_CHECKSIG"] = "Pop the top two items from the stack. Treat the top as a signature and the second as a public key. If the signature is valid, push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsBCH20232["OP_CHECKSIGVERIFY"] = "Pop the top two items from the stack. Treat the top as a signature and the second as a public key. If the signature is not valid, error. (This operation is a combination of OP_CHECKSIG followed by OP_VERIFY.)";
  OpcodeDescriptionsBCH20232["OP_CHECKMULTISIG"] = "Pop items from the stack: first pop the VM Number of public keys, then pop each of those public keys. Next, pop the VM Number of required signatures, then pop each of those signatures. Finally, pop a final VM Number that must be 0 due to a protocol bug. Checking each signature against each public key in order, if all signatures are valid – and the required number of signatures have been provided – push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsBCH20232["OP_CHECKMULTISIGVERIFY"] = "Pop items from the stack: first pop the VM Number of public keys, then pop each of those public keys. Next, pop the VM Number of required signatures, then pop each of those signatures. Finally, (due to a protocol bug) pop an unused final VM Number that must be 0. Checking each signature against each public key in order, if any signatures are invalid – or the required number of signatures have not been provided – error. (This operation is a combination of OP_CHECKMULTISIG followed by OP_VERIFY.)";
  OpcodeDescriptionsBCH20232["OP_NOP1"] = "No operation (reserved for future expansion). Note: OP_NOP1 counts toward the opcode limit.";
  OpcodeDescriptionsBCH20232["OP_CHECKLOCKTIMEVERIFY"] = "Verify the transaction occurs after an absolute block time or height: read the top item on the stack as a VM Number (without removing it), and compare it to the transaction's locktime. If the required locktime has not passed, or if locktime has been disabled for this input by a maximized sequence number, error.";
  OpcodeDescriptionsBCH20232["OP_CHECKSEQUENCEVERIFY"] = `Verify the transaction occurs after the output being spent has "aged" by a relative block time or block height since it was created: read the top item on the stack as a VM Number (without removing it), and compare it to the age encoded in the input's sequence number. If the required relative locktime has not passed, or if relative locktime has been disabled by the sequence number or the transaction version, error.`;
  OpcodeDescriptionsBCH20232["OP_NOP4"] = "No operation (reserved for future expansion). Note: OP_NOP4 counts toward the opcode limit.";
  OpcodeDescriptionsBCH20232["OP_NOP6"] = "No operation (reserved for future expansion). Note: OP_NOP6 counts toward the opcode limit.";
  OpcodeDescriptionsBCH20232["OP_NOP5"] = "No operation (reserved for future expansion). Note: OP_NOP5 counts toward the opcode limit.";
  OpcodeDescriptionsBCH20232["OP_NOP7"] = "No operation (reserved for future expansion). Note: OP_NOP7 counts toward the opcode limit.";
  OpcodeDescriptionsBCH20232["OP_NOP8"] = "No operation (reserved for future expansion). Note: OP_NOP8 counts toward the opcode limit.";
  OpcodeDescriptionsBCH20232["OP_NOP9"] = "No operation (reserved for future expansion). Note: OP_NOP9 counts toward the opcode limit.";
  OpcodeDescriptionsBCH20232["OP_NOP10"] = "No operation (reserved for future expansion). Note: OP_NOP10 counts toward the opcode limit.";
  OpcodeDescriptionsBCH20232["OP_CHECKDATASIG"] = "Pop the top 3 items from the stack. Treat the top as a public key, the second as a message, and the third as a signature. If the signature is valid, push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsBCH20232["OP_CHECKDATASIGVERIFY"] = "Pop the top 3 items from the stack. Treat the top as a public key, the second as a message, and the third as a signature. If the signature is not valid, error. (This operation is a combination of OP_CHECKDATASIG followed by OP_VERIFY.)";
  OpcodeDescriptionsBCH20232["OP_REVERSEBYTES"] = "Pop the top item from the stack and reverse it, pushing the result.";
  OpcodeDescriptionsBCH20232["OP_INPUTINDEX"] = "Push the index of the input being evaluated to the stack as a VM Number.";
  OpcodeDescriptionsBCH20232["OP_ACTIVEBYTECODE"] = "Push the bytecode currently being evaluated, beginning after the last executed OP_CODESEPARATOR, to the stack. For Pay-to-Script-Hash (P2SH) evaluations, this is the redeem bytecode of the Unspent Transaction Output (UTXO) being spent; for all other evaluations, this is the locking bytecode of the UTXO being spent.";
  OpcodeDescriptionsBCH20232["OP_TXVERSION"] = "Push the version of the current transaction to the stack as a VM Number.";
  OpcodeDescriptionsBCH20232["OP_TXINPUTCOUNT"] = "Push the count of inputs in the current transaction to the stack as a VM Number.";
  OpcodeDescriptionsBCH20232["OP_TXOUTPUTCOUNT"] = "Push the count of outputs in the current transaction to the stack as a VM Number.";
  OpcodeDescriptionsBCH20232["OP_TXLOCKTIME"] = "Push the locktime of the current transaction to the stack as a VM Number.";
  OpcodeDescriptionsBCH20232["OP_UTXOVALUE"] = "Pop the top item from the stack as an input index (VM Number). Push the value (in satoshis) of the Unspent Transaction Output (UTXO) spent by that input to the stack as a VM Number.";
  OpcodeDescriptionsBCH20232["OP_UTXOBYTECODE"] = "Pop the top item from the stack as an input index (VM Number). Push the full locking bytecode of the Unspent Transaction Output (UTXO) spent by that input to the stack.";
  OpcodeDescriptionsBCH20232["OP_OUTPOINTTXHASH"] = "Pop the top item from the stack as an input index (VM Number). From that input, push the outpoint transaction hash – the hash of the transaction that created the Unspent Transaction Output (UTXO) that is being spent – to the stack in OP_HASH256 byte order.";
  OpcodeDescriptionsBCH20232["OP_OUTPOINTINDEX"] = "Pop the top item from the stack as an input index (VM Number). From that input, push the outpoint index – the index of the output in the transaction that created the Unspent Transaction Output (UTXO) that is being spent – to the stack as a VM Number.";
  OpcodeDescriptionsBCH20232["OP_INPUTBYTECODE"] = "Pop the top item from the stack as an input index (VM Number). Push the unlocking bytecode of the input at that index to the stack.";
  OpcodeDescriptionsBCH20232["OP_INPUTSEQUENCENUMBER"] = "Pop the top item from the stack as an input index (VM Number). Push the sequence number of the input at that index to the stack as a VM Number.";
  OpcodeDescriptionsBCH20232["OP_OUTPUTVALUE"] = "Pop the top item from the stack as an output index (VM Number). Push the value (in satoshis) of the output at that index to the stack as a VM Number.";
  OpcodeDescriptionsBCH20232["OP_OUTPUTBYTECODE"] = "Pop the top item from the stack as an output index (VM Number). Push the locking bytecode of the output at that index to the stack.";
  OpcodeDescriptionsBCH20232["OP_UTXOTOKENCATEGORY"] = "Pop the top item from the stack as an input index (VM Number). If the Unspent Transaction Output (UTXO) spent by that input includes no tokens, push a 0 (VM Number) to the stack. If the UTXO does not include a non-fungible token with a capability, push the UTXO's token category, otherwise, push the concatenation of the token category and capability, where the mutable capability is represented by 1 (VM Number) and the minting capability is represented by 2 (VM Number).";
  OpcodeDescriptionsBCH20232["OP_UTXOTOKENCOMMITMENT"] = "Pop the top item from the stack as an input index (VM Number). Push the token commitment of the Unspent Transaction Output (UTXO) spent by that input to the stack. If the UTXO does not include a non-fungible token, or if it includes a non-fungible token with a zero-length commitment, push a 0 (VM Number).";
  OpcodeDescriptionsBCH20232["OP_UTXOTOKENAMOUNT"] = "Pop the top item from the stack as an input index (VM Number). Push the fungible token amount of the Unspent Transaction Output (UTXO) spent by that input to the stack as a VM Number. If the UTXO includes no fungible tokens, push a 0 (VM Number).";
  OpcodeDescriptionsBCH20232["OP_OUTPUTTOKENCATEGORY"] = "Pop the top item from the stack as an output index (VM Number). If the output spent by that input includes no tokens, push a 0 (VM Number) to the stack. If the output does not include a non-fungible token with a capability, push the output's token category, otherwise, push the concatenation of the token category and capability, where the mutable capability is represented by 1 (VM Number) and the minting capability is represented by 2 (VM Number).";
  OpcodeDescriptionsBCH20232["OP_OUTPUTTOKENCOMMITMENT"] = "Pop the top item from the stack as an output index (VM Number). Push the token commitment of the output at that index to the stack. If the output does not include a non-fungible token, or if it includes a non-fungible token with a zero-length commitment, push a 0 (VM Number).";
  OpcodeDescriptionsBCH20232["OP_OUTPUTTOKENAMOUNT"] = "Pop the top item from the stack as an output index (VM Number). Push the fungible token amount of the output at that index to the stack as a VM Number. If the output includes no fungible tokens, push a 0 (VM Number).";
})(OpcodeDescriptionsBCH2023 || (OpcodeDescriptionsBCH2023 = {}));
var OpcodeDescriptionsBCH = OpcodeDescriptionsBCH2023;
var OpcodeDescriptions = OpcodeDescriptionsBCH;

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/bch/2023/bch-2023-errors.js
var import_dist211 = __toESM(require_dist(), 1);
var import_dist212 = __toESM(require_dist2(), 1);
var import_dist213 = __toESM(require_dist3(), 1);
var AuthenticationErrorBCH2023;
(function(AuthenticationErrorBCH20232) {
  AuthenticationErrorBCH20232["exceededMaximumVmNumberLength"] = "Program attempted an OP_BIN2NUM operation on a byte sequence that cannot be encoded within the maximum VM Number length (8 bytes).";
})(AuthenticationErrorBCH2023 || (AuthenticationErrorBCH2023 = {}));
var AuthenticationErrorBCH = AuthenticationErrorBCH2023;

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/bch/2023/bch-2023-instruction-set.js
var import_dist217 = __toESM(require_dist(), 1);
var import_dist218 = __toESM(require_dist2(), 1);
var import_dist219 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/bch/2023/bch-2023-tokens.js
var import_dist214 = __toESM(require_dist(), 1);
var import_dist215 = __toESM(require_dist2(), 1);
var import_dist216 = __toESM(require_dist3(), 1);
var extractGenesisCategories = (inputs) => inputs.reduce((agg, input) => input.outpointIndex === 0 ? [...agg, binToHex(input.outpointTransactionHash)] : agg, []);
var extractSourceOutputTokenData = (sourceOutputs) => sourceOutputs.reduce(
  // eslint-disable-next-line complexity
  (agg, sourceOutput) => {
    if (sourceOutput.token === void 0)
      return agg;
    const categoryHex = binToHex(sourceOutput.token.category);
    return {
      availableImmutableTokens: [
        ...agg.availableImmutableTokens,
        ...sourceOutput.token.nft?.capability === "none" ? [
          {
            categoryHex: binToHex(sourceOutput.token.category),
            commitmentHex: binToHex(sourceOutput.token.nft.commitment)
          }
        ] : []
      ],
      availableMutableTokensByCategory: sourceOutput.token.nft?.capability === "mutable" ? {
        ...agg.availableMutableTokensByCategory,
        [categoryHex]: (agg.availableMutableTokensByCategory[categoryHex] ?? 0) + 1
      } : agg.availableMutableTokensByCategory,
      availableSumsByCategory: {
        ...agg.availableSumsByCategory,
        [categoryHex]: (agg.availableSumsByCategory[categoryHex] ?? 0n) + sourceOutput.token.amount
      },
      inputMintingCategories: [
        ...agg.inputMintingCategories,
        ...sourceOutput.token.nft?.capability === "minting" ? [binToHex(sourceOutput.token.category)] : []
      ]
    };
  },
  {
    availableImmutableTokens: [],
    availableMutableTokensByCategory: {},
    availableSumsByCategory: {},
    inputMintingCategories: []
  }
);
var extractTransactionOutputTokenData = (outputs) => outputs.reduce(
  // eslint-disable-next-line complexity
  (agg, output) => {
    if (output.token === void 0)
      return agg;
    const categoryHex = binToHex(output.token.category);
    return {
      outputImmutableTokens: [
        ...agg.outputImmutableTokens,
        ...output.token.nft?.capability === "none" ? [
          {
            categoryHex: binToHex(output.token.category),
            commitmentHex: binToHex(output.token.nft.commitment)
          }
        ] : []
      ],
      outputMintingCategories: [
        ...agg.outputMintingCategories,
        ...output.token.nft?.capability === "minting" ? [binToHex(output.token.category)] : []
      ],
      outputMutableTokensByCategory: output.token.nft?.capability === "mutable" ? {
        ...agg.outputMutableTokensByCategory,
        [categoryHex]: (agg.outputMutableTokensByCategory[categoryHex] ?? 0) + 1
      } : agg.outputMutableTokensByCategory,
      outputSumsByCategory: {
        ...agg.outputSumsByCategory,
        [categoryHex]: (agg.outputSumsByCategory[categoryHex] ?? 0n) + output.token.amount
      }
    };
  },
  {
    outputImmutableTokens: [],
    outputMintingCategories: [],
    outputMutableTokensByCategory: {},
    outputSumsByCategory: {}
  }
);
var verifyTransactionTokens = (transaction, sourceOutputs) => {
  const excessiveCommitment = [...sourceOutputs, ...transaction.outputs].find((output) => output.token?.nft?.commitment !== void 0 && output.token.nft.commitment.length > ConsensusBCH2023.maximumCommitmentLength);
  if (excessiveCommitment !== void 0) {
    return `Transaction violates token validation: a token commitment exceeds the consensus limit of ${ConsensusBCH2023.maximumCommitmentLength} bytes. Excessive token commitment length: ${// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    excessiveCommitment.token.nft.commitment.length}`;
  }
  const genesisCategories = extractGenesisCategories(transaction.inputs);
  const { availableSumsByCategory, availableMutableTokensByCategory, inputMintingCategories, availableImmutableTokens } = extractSourceOutputTokenData(sourceOutputs);
  const { outputSumsByCategory, outputMutableTokensByCategory, outputMintingCategories, outputImmutableTokens } = extractTransactionOutputTokenData(transaction.outputs);
  const availableMintingCategories = [
    ...genesisCategories,
    ...inputMintingCategories
  ];
  const missingMintingCategory = outputMintingCategories.find((category) => !availableMintingCategories.includes(category));
  if (missingMintingCategory !== void 0) {
    return `Transaction violates token validation: the transaction outputs include a minting token that is not substantiated by the transaction's inputs. Invalid output minting token category: ${missingMintingCategory}`;
  }
  for (const [categoryHex, sum] of Object.entries(outputSumsByCategory)) {
    if (sum > BigInt(ConsensusBCH2023.maxVmNumber)) {
      return `Transaction violates token validation: the transaction outputs include a sum of fungible tokens for a category exceeding the maximum supply (${ConsensusBCH2023.maxVmNumber}). Category: ${categoryHex}, total amount: ${sum.toString()}.`;
    }
    const availableSum = availableSumsByCategory[categoryHex];
    if (availableSum === void 0 && sum > 0 && !genesisCategories.includes(categoryHex)) {
      return `Transaction violates token validation: the transaction creates new fungible tokens for a category without a matching genesis input. Category: ${categoryHex}, tokens created: ${sum}`;
    }
    if (availableSum !== void 0 && sum > availableSum) {
      return `Transaction violates token validation: the sum of fungible tokens in the transaction's outputs exceed that of the transactions inputs for a category. Category: ${categoryHex}, input amount: ${availableSum}, output amount: ${sum}`;
    }
  }
  const remainingMutableTokens = Object.entries(outputMutableTokensByCategory).reduce((agg, [categoryHex, sum]) => {
    if (availableMintingCategories.includes(categoryHex)) {
      return agg;
    }
    return { ...agg, [categoryHex]: (agg[categoryHex] ?? 0) - sum };
  }, availableMutableTokensByCategory);
  for (const [categoryHex, sum] of Object.entries(remainingMutableTokens)) {
    if (sum < 0) {
      return `Transaction violates token validation: the transaction creates more mutable tokens than are available for a category without a matching minting token. Category: ${categoryHex}, excess mutable tokens: ${0 - sum}`;
    }
  }
  const { unmatchedImmutableTokens } = outputImmutableTokens.reduce((agg, token) => {
    const { categoryHex, commitmentHex } = token;
    if (availableMintingCategories.includes(categoryHex)) {
      return agg;
    }
    const firstMatch = availableImmutableTokens.findIndex((available) => available.categoryHex === categoryHex && available.commitmentHex === commitmentHex);
    if (firstMatch === -1) {
      return {
        availableImmutableTokens: agg.availableImmutableTokens,
        unmatchedImmutableTokens: [...agg.unmatchedImmutableTokens, token]
      };
    }
    agg.availableImmutableTokens.splice(firstMatch, 1);
    return agg;
  }, {
    availableImmutableTokens,
    unmatchedImmutableTokens: []
  });
  const requiredMutableTokens = unmatchedImmutableTokens.reduce((agg, token) => ({
    ...agg,
    [token.categoryHex]: (agg[token.categoryHex] ?? 0) + 1
  }), {});
  for (const [categoryHex, required] of Object.entries(requiredMutableTokens)) {
    const available = remainingMutableTokens[categoryHex] ?? 0;
    if (available < required) {
      return `Transaction violates token validation: the transaction creates an immutable token for a category without a matching minting token or sufficient mutable tokens. Category ${categoryHex}, available mutable tokens: ${available}, new immutable tokens: ${required}`;
    }
  }
  return true;
};
var pushTokenExtendedCategory = (state, utxo) => {
  const { token } = utxo;
  if (token === void 0) {
    return pushToStackVmNumber(state, 0n);
  }
  const capabilityByte = token.nft?.capability === "minting" ? [
    2
    /* Constants.mintingCapabilityByte */
  ] : token.nft?.capability === "mutable" ? [
    1
    /* Constants.mutableCapabilityByte */
  ] : [];
  const extendedCategory = flattenBinArray([
    token.category.slice().reverse(),
    Uint8Array.from(capabilityByte)
  ]);
  return pushToStackChecked(state, extendedCategory);
};
var pushTokenCommitment = (state, utxo) => {
  const { token } = utxo;
  if (token === void 0 || token.nft === void 0) {
    return pushToStackVmNumber(state, 0n);
  }
  return pushToStackChecked(state, token.nft.commitment);
};
var pushTokenAmount = (state, utxo) => {
  const { token } = utxo;
  if (token === void 0) {
    return pushToStackVmNumber(state, 0n);
  }
  return pushToStackVmNumberChecked(state, token.amount);
};
var opUtxoTokenCategory = (state) => useTransactionUtxo(state, (nextState, [utxo]) => pushTokenExtendedCategory(nextState, utxo));
var opUtxoTokenCommitment = (state) => useTransactionUtxo(state, (nextState, [utxo]) => pushTokenCommitment(nextState, utxo));
var opUtxoTokenAmount = (state) => useTransactionUtxo(state, (nextState, [utxo]) => pushTokenAmount(nextState, utxo));
var opOutputTokenCategory = (state) => useTransactionOutput(state, (nextState, [output]) => pushTokenExtendedCategory(nextState, output));
var opOutputTokenCommitment = (state) => useTransactionOutput(state, (nextState, [output]) => pushTokenCommitment(nextState, output));
var opOutputTokenAmount = (state) => useTransactionOutput(state, (nextState, [output]) => pushTokenAmount(nextState, output));

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/bch/2023/bch-2023-instruction-set.js
var createInstructionSetBCH2023 = (standard = true, { ripemd160: ripemd1602, secp256k1: secp256k12, sha1: sha12, sha256: sha2562 } = {
  ripemd160,
  secp256k1,
  sha1,
  sha256
}) => {
  const conditionallyPush = pushOperation();
  return {
    clone: cloneAuthenticationProgramStateBCH,
    continue: (state) => state.error === void 0 && state.ip < state.instructions.length,
    // eslint-disable-next-line complexity
    evaluate: (program, stateEvaluate) => {
      const { unlockingBytecode } = (
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        program.transaction.inputs[program.inputIndex]
      );
      const { lockingBytecode } = program.sourceOutputs[program.inputIndex];
      const unlockingInstructions = decodeAuthenticationInstructions(unlockingBytecode);
      const lockingInstructions = decodeAuthenticationInstructions(lockingBytecode);
      const initialState = createAuthenticationProgramStateCommon({
        instructions: unlockingInstructions,
        program,
        stack: []
      });
      if (unlockingBytecode.length > ConsensusBCH2023.maximumBytecodeLength) {
        return applyError(initialState, `The provided unlocking bytecode (${unlockingBytecode.length} bytes) exceeds the maximum bytecode length (${ConsensusBCH2023.maximumBytecodeLength} bytes).`);
      }
      if (authenticationInstructionsAreMalformed(unlockingInstructions)) {
        return applyError(initialState, AuthenticationErrorCommon.malformedUnlockingBytecode);
      }
      if (!isPushOnly(unlockingBytecode)) {
        return applyError(initialState, AuthenticationErrorCommon.requiresPushOnly);
      }
      if (lockingBytecode.length > ConsensusBCH2023.maximumBytecodeLength) {
        return applyError(initialState, AuthenticationErrorCommon.exceededMaximumBytecodeLengthLocking);
      }
      if (authenticationInstructionsAreMalformed(lockingInstructions)) {
        return applyError(initialState, AuthenticationErrorCommon.malformedLockingBytecode);
      }
      const unlockingResult = stateEvaluate(initialState);
      if (unlockingResult.error !== void 0) {
        return unlockingResult;
      }
      if (unlockingResult.controlStack.length !== 0) {
        return applyError(initialState, AuthenticationErrorCommon.nonEmptyControlStack);
      }
      const lockingResult = stateEvaluate(createAuthenticationProgramStateCommon({
        instructions: lockingInstructions,
        program,
        stack: unlockingResult.stack
      }));
      const p2sh20 = isPayToScriptHash20(lockingBytecode);
      const p2sh32 = isPayToScriptHash32(lockingBytecode);
      if (!p2sh20 && !p2sh32) {
        return lockingResult;
      }
      const p2shStack = cloneStack(unlockingResult.stack);
      const p2shScript = p2shStack.pop() ?? Uint8Array.of();
      if (p2sh20 && p2shStack.length === 0 && isWitnessProgram(p2shScript)) {
        return lockingResult;
      }
      const p2shInstructions = decodeAuthenticationInstructions(p2shScript);
      return authenticationInstructionsAreMalformed(p2shInstructions) ? {
        ...lockingResult,
        error: AuthenticationErrorCommon.malformedP2shBytecode
      } : stateEvaluate(createAuthenticationProgramStateCommon({
        instructions: p2shInstructions,
        program,
        stack: p2shStack
      }));
    },
    every: (state) => (
      // TODO: implement sigchecks https://gitlab.com/bitcoin-cash-node/bchn-sw/bitcoincash-upgrade-specifications/-/blob/master/spec/2020-05-15-sigchecks.md
      state.stack.length + state.alternateStack.length > ConsensusBCH2023.maximumStackDepth ? applyError(state, AuthenticationErrorCommon.exceededMaximumStackDepth) : state.operationCount > ConsensusBCH2023.maximumOperationCount ? applyError(state, AuthenticationErrorCommon.exceededMaximumOperationCount) : state
    ),
    operations: {
      [OpcodesBCH2023.OP_0]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_1]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_2]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_3]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_4]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_5]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_6]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_7]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_8]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_9]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_10]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_11]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_12]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_13]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_14]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_15]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_16]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_17]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_18]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_19]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_20]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_21]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_22]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_23]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_24]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_25]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_26]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_27]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_28]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_29]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_30]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_31]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_32]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_33]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_34]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_35]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_36]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_37]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_38]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_39]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_40]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_41]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_42]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_43]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_44]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_45]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_46]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_47]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_48]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_49]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_50]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_51]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_52]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_53]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_54]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_55]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_56]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_57]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_58]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_59]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_60]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_61]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_62]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_63]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_64]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_65]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_66]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_67]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_68]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_69]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_70]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_71]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_72]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_73]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_74]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHBYTES_75]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHDATA_1]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHDATA_2]: conditionallyPush,
      [OpcodesBCH2023.OP_PUSHDATA_4]: conditionallyPush,
      [OpcodesBCH2023.OP_1NEGATE]: conditionallyEvaluate(pushNumberOperation(-1)),
      [OpcodesBCH2023.OP_RESERVED]: conditionallyEvaluate(reservedOperation),
      [OpcodesBCH2023.OP_1]: conditionallyEvaluate(pushNumberOperation(1)),
      /* eslint-disable @typescript-eslint/no-magic-numbers */
      [OpcodesBCH2023.OP_2]: conditionallyEvaluate(pushNumberOperation(2)),
      [OpcodesBCH2023.OP_3]: conditionallyEvaluate(pushNumberOperation(3)),
      [OpcodesBCH2023.OP_4]: conditionallyEvaluate(pushNumberOperation(4)),
      [OpcodesBCH2023.OP_5]: conditionallyEvaluate(pushNumberOperation(5)),
      [OpcodesBCH2023.OP_6]: conditionallyEvaluate(pushNumberOperation(6)),
      [OpcodesBCH2023.OP_7]: conditionallyEvaluate(pushNumberOperation(7)),
      [OpcodesBCH2023.OP_8]: conditionallyEvaluate(pushNumberOperation(8)),
      [OpcodesBCH2023.OP_9]: conditionallyEvaluate(pushNumberOperation(9)),
      [OpcodesBCH2023.OP_10]: conditionallyEvaluate(pushNumberOperation(10)),
      [OpcodesBCH2023.OP_11]: conditionallyEvaluate(pushNumberOperation(11)),
      [OpcodesBCH2023.OP_12]: conditionallyEvaluate(pushNumberOperation(12)),
      [OpcodesBCH2023.OP_13]: conditionallyEvaluate(pushNumberOperation(13)),
      [OpcodesBCH2023.OP_14]: conditionallyEvaluate(pushNumberOperation(14)),
      [OpcodesBCH2023.OP_15]: conditionallyEvaluate(pushNumberOperation(15)),
      [OpcodesBCH2023.OP_16]: conditionallyEvaluate(pushNumberOperation(16)),
      /* eslint-enable @typescript-eslint/no-magic-numbers */
      ...mapOverOperations([incrementOperationCount], {
        [OpcodesBCH2023.OP_NOP]: conditionallyEvaluate(opNop),
        [OpcodesBCH2023.OP_VER]: conditionallyEvaluate(reservedOperation),
        [OpcodesBCH2023.OP_IF]: opIf,
        [OpcodesBCH2023.OP_NOTIF]: opNotIf,
        [OpcodesBCH2023.OP_VERIF]: reservedOperation,
        [OpcodesBCH2023.OP_VERNOTIF]: reservedOperation,
        [OpcodesBCH2023.OP_ELSE]: opElse,
        [OpcodesBCH2023.OP_ENDIF]: opEndIf,
        [OpcodesBCH2023.OP_VERIFY]: conditionallyEvaluate(opVerify),
        [OpcodesBCH2023.OP_RETURN]: conditionallyEvaluate(opReturn),
        [OpcodesBCH2023.OP_TOALTSTACK]: conditionallyEvaluate(opToAltStack),
        [OpcodesBCH2023.OP_FROMALTSTACK]: conditionallyEvaluate(opFromAltStack),
        [OpcodesBCH2023.OP_2DROP]: conditionallyEvaluate(op2Drop),
        [OpcodesBCH2023.OP_2DUP]: conditionallyEvaluate(op2Dup),
        [OpcodesBCH2023.OP_3DUP]: conditionallyEvaluate(op3Dup),
        [OpcodesBCH2023.OP_2OVER]: conditionallyEvaluate(op2Over),
        [OpcodesBCH2023.OP_2ROT]: conditionallyEvaluate(op2Rot),
        [OpcodesBCH2023.OP_2SWAP]: conditionallyEvaluate(op2Swap),
        [OpcodesBCH2023.OP_IFDUP]: conditionallyEvaluate(opIfDup),
        [OpcodesBCH2023.OP_DEPTH]: conditionallyEvaluate(opDepth),
        [OpcodesBCH2023.OP_DROP]: conditionallyEvaluate(opDrop),
        [OpcodesBCH2023.OP_DUP]: conditionallyEvaluate(opDup),
        [OpcodesBCH2023.OP_NIP]: conditionallyEvaluate(opNip),
        [OpcodesBCH2023.OP_OVER]: conditionallyEvaluate(opOver),
        [OpcodesBCH2023.OP_PICK]: conditionallyEvaluate(opPick),
        [OpcodesBCH2023.OP_ROLL]: conditionallyEvaluate(opRoll),
        [OpcodesBCH2023.OP_ROT]: conditionallyEvaluate(opRot),
        [OpcodesBCH2023.OP_SWAP]: conditionallyEvaluate(opSwap),
        [OpcodesBCH2023.OP_TUCK]: conditionallyEvaluate(opTuck),
        [OpcodesBCH2023.OP_CAT]: conditionallyEvaluate(opCat),
        [OpcodesBCH2023.OP_SPLIT]: conditionallyEvaluate(opSplit),
        [OpcodesBCH2023.OP_NUM2BIN]: conditionallyEvaluate(opNum2Bin),
        [OpcodesBCH2023.OP_BIN2NUM]: conditionallyEvaluate(opBin2Num),
        [OpcodesBCH2023.OP_SIZE]: conditionallyEvaluate(opSize),
        [OpcodesBCH2023.OP_INVERT]: disabledOperation,
        [OpcodesBCH2023.OP_AND]: conditionallyEvaluate(opAnd),
        [OpcodesBCH2023.OP_OR]: conditionallyEvaluate(opOr),
        [OpcodesBCH2023.OP_XOR]: conditionallyEvaluate(opXor),
        [OpcodesBCH2023.OP_EQUAL]: conditionallyEvaluate(opEqual),
        [OpcodesBCH2023.OP_EQUALVERIFY]: conditionallyEvaluate(opEqualVerify),
        [OpcodesBCH2023.OP_RESERVED1]: conditionallyEvaluate(reservedOperation),
        [OpcodesBCH2023.OP_RESERVED2]: conditionallyEvaluate(reservedOperation),
        [OpcodesBCH2023.OP_1ADD]: conditionallyEvaluate(op1Add),
        [OpcodesBCH2023.OP_1SUB]: conditionallyEvaluate(op1Sub),
        [OpcodesBCH2023.OP_2MUL]: disabledOperation,
        [OpcodesBCH2023.OP_2DIV]: disabledOperation,
        [OpcodesBCH2023.OP_NEGATE]: conditionallyEvaluate(opNegate),
        [OpcodesBCH2023.OP_ABS]: conditionallyEvaluate(opAbs),
        [OpcodesBCH2023.OP_NOT]: conditionallyEvaluate(opNot),
        [OpcodesBCH2023.OP_0NOTEQUAL]: conditionallyEvaluate(op0NotEqual),
        [OpcodesBCH2023.OP_ADD]: conditionallyEvaluate(opAdd),
        [OpcodesBCH2023.OP_SUB]: conditionallyEvaluate(opSub),
        [OpcodesBCH2023.OP_MUL]: conditionallyEvaluate(opMul),
        [OpcodesBCH2023.OP_DIV]: conditionallyEvaluate(opDiv),
        [OpcodesBCH2023.OP_MOD]: conditionallyEvaluate(opMod),
        [OpcodesBCH2023.OP_LSHIFT]: disabledOperation,
        [OpcodesBCH2023.OP_RSHIFT]: disabledOperation,
        [OpcodesBCH2023.OP_BOOLAND]: conditionallyEvaluate(opBoolAnd),
        [OpcodesBCH2023.OP_BOOLOR]: conditionallyEvaluate(opBoolOr),
        [OpcodesBCH2023.OP_NUMEQUAL]: conditionallyEvaluate(opNumEqual),
        [OpcodesBCH2023.OP_NUMEQUALVERIFY]: conditionallyEvaluate(opNumEqualVerify),
        [OpcodesBCH2023.OP_NUMNOTEQUAL]: conditionallyEvaluate(opNumNotEqual),
        [OpcodesBCH2023.OP_LESSTHAN]: conditionallyEvaluate(opLessThan),
        [OpcodesBCH2023.OP_GREATERTHAN]: conditionallyEvaluate(opGreaterThan),
        [OpcodesBCH2023.OP_LESSTHANOREQUAL]: conditionallyEvaluate(opLessThanOrEqual),
        [OpcodesBCH2023.OP_GREATERTHANOREQUAL]: conditionallyEvaluate(opGreaterThanOrEqual),
        [OpcodesBCH2023.OP_MIN]: conditionallyEvaluate(opMin),
        [OpcodesBCH2023.OP_MAX]: conditionallyEvaluate(opMax),
        [OpcodesBCH2023.OP_WITHIN]: conditionallyEvaluate(opWithin),
        [OpcodesBCH2023.OP_RIPEMD160]: conditionallyEvaluate(opRipemd160({ ripemd160: ripemd1602 })),
        [OpcodesBCH2023.OP_SHA1]: conditionallyEvaluate(opSha1({ sha1: sha12 })),
        [OpcodesBCH2023.OP_SHA256]: conditionallyEvaluate(opSha256({ sha256: sha2562 })),
        [OpcodesBCH2023.OP_HASH160]: conditionallyEvaluate(opHash160({ ripemd160: ripemd1602, sha256: sha2562 })),
        [OpcodesBCH2023.OP_HASH256]: conditionallyEvaluate(opHash256({ sha256: sha2562 })),
        [OpcodesBCH2023.OP_CODESEPARATOR]: conditionallyEvaluate(opCodeSeparator),
        [OpcodesBCH2023.OP_CHECKSIG]: conditionallyEvaluate(opCheckSigBCH2023({ secp256k1: secp256k12, sha256: sha2562 })),
        [OpcodesBCH2023.OP_CHECKSIGVERIFY]: conditionallyEvaluate(opCheckSigVerifyBCH2023({ secp256k1: secp256k12, sha256: sha2562 })),
        [OpcodesBCH2023.OP_CHECKMULTISIG]: conditionallyEvaluate(opCheckMultiSigBCH2023({ secp256k1: secp256k12, sha256: sha2562 })),
        [OpcodesBCH2023.OP_CHECKMULTISIGVERIFY]: conditionallyEvaluate(opCheckMultiSigVerifyBCH2023({ secp256k1: secp256k12, sha256: sha2562 })),
        ...standard ? {
          [OpcodesBCH2023.OP_NOP1]: conditionallyEvaluate(opNopDisallowed),
          [OpcodesBCH2023.OP_CHECKLOCKTIMEVERIFY]: conditionallyEvaluate(opCheckLockTimeVerify),
          [OpcodesBCH2023.OP_CHECKSEQUENCEVERIFY]: conditionallyEvaluate(opCheckSequenceVerify),
          [OpcodesBCH2023.OP_NOP4]: conditionallyEvaluate(opNopDisallowed),
          [OpcodesBCH2023.OP_NOP5]: conditionallyEvaluate(opNopDisallowed),
          [OpcodesBCH2023.OP_NOP6]: conditionallyEvaluate(opNopDisallowed),
          [OpcodesBCH2023.OP_NOP7]: conditionallyEvaluate(opNopDisallowed),
          [OpcodesBCH2023.OP_NOP8]: conditionallyEvaluate(opNopDisallowed),
          [OpcodesBCH2023.OP_NOP9]: conditionallyEvaluate(opNopDisallowed),
          [OpcodesBCH2023.OP_NOP10]: conditionallyEvaluate(opNopDisallowed)
        } : {
          [OpcodesBCH2023.OP_NOP1]: conditionallyEvaluate(opNop),
          [OpcodesBCH2023.OP_CHECKLOCKTIMEVERIFY]: conditionallyEvaluate(opCheckLockTimeVerify),
          [OpcodesBCH2023.OP_CHECKSEQUENCEVERIFY]: conditionallyEvaluate(opCheckSequenceVerify),
          [OpcodesBCH2023.OP_NOP4]: conditionallyEvaluate(opNop),
          [OpcodesBCH2023.OP_NOP5]: conditionallyEvaluate(opNop),
          [OpcodesBCH2023.OP_NOP6]: conditionallyEvaluate(opNop),
          [OpcodesBCH2023.OP_NOP7]: conditionallyEvaluate(opNop),
          [OpcodesBCH2023.OP_NOP8]: conditionallyEvaluate(opNop),
          [OpcodesBCH2023.OP_NOP9]: conditionallyEvaluate(opNop),
          [OpcodesBCH2023.OP_NOP10]: conditionallyEvaluate(opNop)
        },
        [OpcodesBCH2023.OP_CHECKDATASIG]: conditionallyEvaluate(opCheckDataSig({ secp256k1: secp256k12, sha256: sha2562 })),
        [OpcodesBCH2023.OP_CHECKDATASIGVERIFY]: conditionallyEvaluate(opCheckDataSigVerify({ secp256k1: secp256k12, sha256: sha2562 })),
        [OpcodesBCH2023.OP_REVERSEBYTES]: conditionallyEvaluate(opReverseBytes),
        [OpcodesBCH2023.OP_INPUTINDEX]: conditionallyEvaluate(opInputIndex),
        [OpcodesBCH2023.OP_ACTIVEBYTECODE]: conditionallyEvaluate(opActiveBytecode),
        [OpcodesBCH2023.OP_TXVERSION]: conditionallyEvaluate(opTxVersion),
        [OpcodesBCH2023.OP_TXINPUTCOUNT]: conditionallyEvaluate(opTxInputCount),
        [OpcodesBCH2023.OP_TXOUTPUTCOUNT]: conditionallyEvaluate(opTxOutputCount),
        [OpcodesBCH2023.OP_TXLOCKTIME]: conditionallyEvaluate(opTxLocktime),
        [OpcodesBCH2023.OP_UTXOVALUE]: conditionallyEvaluate(opUtxoValue),
        [OpcodesBCH2023.OP_UTXOBYTECODE]: conditionallyEvaluate(opUtxoBytecode),
        [OpcodesBCH2023.OP_OUTPOINTTXHASH]: conditionallyEvaluate(opOutpointTxHash),
        [OpcodesBCH2023.OP_OUTPOINTINDEX]: conditionallyEvaluate(opOutpointIndex),
        [OpcodesBCH2023.OP_INPUTBYTECODE]: conditionallyEvaluate(opInputBytecode),
        [OpcodesBCH2023.OP_INPUTSEQUENCENUMBER]: conditionallyEvaluate(opInputSequenceNumber),
        [OpcodesBCH2023.OP_OUTPUTVALUE]: conditionallyEvaluate(opOutputValue),
        [OpcodesBCH2023.OP_OUTPUTBYTECODE]: conditionallyEvaluate(opOutputBytecode),
        [OpcodesBCH2023.OP_UTXOTOKENCATEGORY]: conditionallyEvaluate(opUtxoTokenCategory),
        [OpcodesBCH2023.OP_UTXOTOKENCOMMITMENT]: conditionallyEvaluate(opUtxoTokenCommitment),
        [OpcodesBCH2023.OP_UTXOTOKENAMOUNT]: conditionallyEvaluate(opUtxoTokenAmount),
        [OpcodesBCH2023.OP_OUTPUTTOKENCATEGORY]: conditionallyEvaluate(opOutputTokenCategory),
        [OpcodesBCH2023.OP_OUTPUTTOKENCOMMITMENT]: conditionallyEvaluate(opOutputTokenCommitment),
        [OpcodesBCH2023.OP_OUTPUTTOKENAMOUNT]: conditionallyEvaluate(opOutputTokenAmount)
      })
    },
    success: (state) => {
      if (state.error !== void 0) {
        return state.error;
      }
      if (state.controlStack.length !== 0) {
        return AuthenticationErrorCommon.nonEmptyControlStack;
      }
      if (state.stack.length !== 1) {
        return AuthenticationErrorCommon.requiresCleanStack;
      }
      if (!stackItemIsTruthy(state.stack[0])) {
        return AuthenticationErrorCommon.unsuccessfulEvaluation;
      }
      return true;
    },
    undefined: undefinedOperation,
    // eslint-disable-next-line complexity
    verify: ({ sourceOutputs, transaction }, evaluate, stateSuccess) => {
      if (transaction.inputs.length === 0) {
        return "Transactions must have at least one input.";
      }
      if (transaction.outputs.length === 0) {
        return "Transactions must have at least one output.";
      }
      if (transaction.inputs.length !== sourceOutputs.length) {
        return "Unable to verify transaction: a single spent output must be provided for each transaction input.";
      }
      const transactionSize = encodeTransactionBCH(transaction).length;
      if (transactionSize < ConsensusBCH2023.minimumTransactionSize) {
        return `Invalid transaction size: the transaction is ${transactionSize} bytes, but transactions must be no smaller than ${ConsensusBCH2023.minimumTransactionSize} bytes to prevent an exploit of the transaction Merkle tree design.`;
      }
      if (transactionSize > ConsensusBCH2023.maximumTransactionSize) {
        return `Transaction exceeds maximum size: the transaction is ${transactionSize} bytes, but the maximum transaction size is ${ConsensusBCH2023.maximumTransactionSize} bytes.`;
      }
      const inputValue = sourceOutputs.reduce((sum, utxo) => sum + utxo.valueSatoshis, 0n);
      const outputValue = transaction.outputs.reduce((sum, output) => sum + output.valueSatoshis, 0n);
      if (outputValue > inputValue) {
        return `Unable to verify transaction: the sum of transaction outputs exceeds the sum of transaction inputs. Input value: ${inputValue}, output value: ${outputValue}`;
      }
      const outpointList = transaction.inputs.map((input) => `outpointTransactionHash: ${binToHex(input.outpointTransactionHash)}, outpointIndex: ${input.outpointIndex}`);
      const firstDuplicate = outpointList.find((outpoint, index2) => outpointList.lastIndexOf(outpoint) !== index2);
      if (firstDuplicate !== void 0) {
        return `Unable to verify transaction: the transaction attempts to spend the same outpoint in multiple inputs. ${firstDuplicate}`;
      }
      if (standard) {
        if (transaction.version < 1 || transaction.version > ConsensusBCH2023.maximumStandardVersion) {
          return `Standard transactions must have a version no less than 1 and no greater than ${ConsensusBCH2023.maximumStandardVersion}.`;
        }
        if (transactionSize > ConsensusBCH2023.maximumStandardTransactionSize) {
          return `Transaction exceeds maximum standard size: this transaction is ${transactionSize} bytes, but the maximum standard transaction size is ${ConsensusBCH2023.maximumStandardTransactionSize} bytes.`;
        }
        for (const [index2, output] of sourceOutputs.entries()) {
          if (!isStandardOutputBytecode2023(output.lockingBytecode)) {
            return `Standard transactions may only spend standard output types, but source output ${index2} is non-standard.`;
          }
        }
        let totalArbitraryDataBytes = 0;
        for (const [index2, output] of transaction.outputs.entries()) {
          if (!isStandardOutputBytecode2023(output.lockingBytecode)) {
            return `Standard transactions may only create standard output types, but transaction output ${index2} is non-standard.`;
          }
          if (isArbitraryDataOutput(output.lockingBytecode)) {
            totalArbitraryDataBytes += output.lockingBytecode.length + 1;
          }
          if (isDustOutput(output)) {
            return `Standard transactions may not have dust outputs, but transaction output ${index2} is a dust output. Output ${index2} must have a value of at least ${getDustThreshold(output)} satoshis. Current value: ${output.valueSatoshis}`;
          }
        }
        if (totalArbitraryDataBytes > ConsensusBCH2023.maximumDataCarrierBytes) {
          return `Standard transactions may carry no more than ${ConsensusBCH2023.maximumDataCarrierBytes} bytes in arbitrary data outputs; this transaction includes ${totalArbitraryDataBytes} bytes of arbitrary data.`;
        }
        for (const [index2, input] of transaction.inputs.entries()) {
          if (input.unlockingBytecode.length > ConsensusBCH2023.maximumStandardUnlockingBytecodeLength) {
            return `Input index ${index2} is non-standard: the unlocking bytecode (${input.unlockingBytecode.length} bytes) exceeds the maximum standard unlocking bytecode length (${ConsensusBCH2023.maximumStandardUnlockingBytecodeLength} bytes).`;
          }
          if (!isPushOnly(input.unlockingBytecode)) {
            return `Input index ${index2} is non-standard: unlocking bytecode may contain only push operations.`;
          }
        }
      }
      const tokenValidationResult = verifyTransactionTokens(transaction, sourceOutputs);
      if (tokenValidationResult !== true) {
        return tokenValidationResult;
      }
      for (const index2 of transaction.inputs.keys()) {
        const state = evaluate({
          inputIndex: index2,
          sourceOutputs,
          transaction
        });
        const result = stateSuccess(state);
        if (typeof result === "string") {
          return `Error in evaluating input index ${index2}: ${result}`;
        }
      }
      return true;
    }
  };
};
var createInstructionSetBCH = createInstructionSetBCH2023;

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/bch/2023/bch-2023-vm.js
var import_dist223 = __toESM(require_dist(), 1);
var import_dist224 = __toESM(require_dist2(), 1);
var import_dist225 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/vm/virtual-machine.js
var import_dist220 = __toESM(require_dist(), 1);
var import_dist221 = __toESM(require_dist2(), 1);
var import_dist222 = __toESM(require_dist3(), 1);
var createAuthenticationVirtualMachine = (instructionSet) => {
  const availableOpcodes = 256;
  const operators = range(availableOpcodes).map((codepoint) => instructionSet.operations[codepoint] === void 0 ? instructionSet.undefined : instructionSet.operations[codepoint]);
  const getCodepoint = (state) => state.instructions[state.ip];
  const after = (state) => {
    state.ip += 1;
    return state;
  };
  const getOperation = (state) => (
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    operators[getCodepoint(state).opcode]
  );
  const noOp = (state) => state;
  const stateEvery = instructionSet.every ?? noOp;
  const stateStepMutate = (state) => {
    const operator = getOperation(state);
    return after(stateEvery(operator(state)));
  };
  const stateContinue = instructionSet.continue;
  const untilComplete = (state, stepFunction) => {
    while (stateContinue(state)) {
      state = stepFunction(state);
    }
    return state;
  };
  const stateClone = instructionSet.clone;
  const { success } = instructionSet;
  const stateEvaluate = (state) => untilComplete(stateClone(state), stateStepMutate);
  const stateDebugStep = (state) => {
    const operator = getOperation(state);
    return after(stateEvery(operator(stateClone(state))));
  };
  const stateDebug = (state) => {
    const trace = [];
    trace.push(state);
    untilComplete(state, (currentState) => {
      const nextState = stateDebugStep(currentState);
      trace.push(nextState);
      return nextState;
    });
    return trace;
  };
  const stateStep = (state) => stateStepMutate(stateClone(state));
  const evaluate = (program) => instructionSet.evaluate(program, stateEvaluate);
  const debug = (program) => {
    const results = [];
    const proxyDebug = (state) => {
      const debugResult = stateDebug(state);
      results.push(...debugResult);
      return debugResult[debugResult.length - 1] ?? state;
    };
    const finalResult = instructionSet.evaluate(program, proxyDebug);
    return [...results, finalResult];
  };
  const verify = (resolvedTransaction) => instructionSet.verify(resolvedTransaction, evaluate, success);
  return {
    debug,
    evaluate,
    stateClone,
    stateContinue,
    stateDebug,
    stateEvaluate,
    stateStep,
    stateStepMutate,
    stateSuccess: success,
    verify
  };
};

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/bch/2023/bch-2023-vm.js
var createVirtualMachineBCH2023 = (standard = true) => createAuthenticationVirtualMachine(createInstructionSetBCH2023(standard));
var createVirtualMachineBCH = createVirtualMachineBCH2023;

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/bch/2022/bch-2022-instruction-set.js
var createInstructionSetBCH2022 = (standard = true, { ripemd160: ripemd1602, secp256k1: secp256k12, sha1: sha12, sha256: sha2562 } = {
  ripemd160,
  secp256k1,
  sha1,
  sha256
}) => {
  const conditionallyPush = pushOperation();
  return {
    clone: cloneAuthenticationProgramStateBCH,
    continue: (state) => state.error === void 0 && state.ip < state.instructions.length,
    // eslint-disable-next-line complexity
    evaluate: (program, stateEvaluate) => {
      const { unlockingBytecode } = (
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        program.transaction.inputs[program.inputIndex]
      );
      const { lockingBytecode } = program.sourceOutputs[program.inputIndex];
      const unlockingInstructions = decodeAuthenticationInstructions(unlockingBytecode);
      const lockingInstructions = decodeAuthenticationInstructions(lockingBytecode);
      const initialState = createAuthenticationProgramStateCommon({
        instructions: unlockingInstructions,
        program,
        stack: []
      });
      if (unlockingBytecode.length > ConsensusBCH.maximumBytecodeLength) {
        return applyError(initialState, `The provided unlocking bytecode (${unlockingBytecode.length} bytes) exceeds the maximum bytecode length (${ConsensusBCH.maximumBytecodeLength} bytes).`);
      }
      if (authenticationInstructionsAreMalformed(unlockingInstructions)) {
        return applyError(initialState, AuthenticationErrorCommon.malformedUnlockingBytecode);
      }
      if (!isPushOnly(unlockingBytecode)) {
        return applyError(initialState, AuthenticationErrorCommon.requiresPushOnly);
      }
      if (lockingBytecode.length > ConsensusBCH.maximumBytecodeLength) {
        return applyError(initialState, AuthenticationErrorCommon.exceededMaximumBytecodeLengthLocking);
      }
      if (authenticationInstructionsAreMalformed(lockingInstructions)) {
        return applyError(initialState, AuthenticationErrorCommon.malformedLockingBytecode);
      }
      const unlockingResult = stateEvaluate(initialState);
      if (unlockingResult.error !== void 0) {
        return unlockingResult;
      }
      if (unlockingResult.controlStack.length !== 0) {
        return applyError(initialState, AuthenticationErrorCommon.nonEmptyControlStack);
      }
      const lockingResult = stateEvaluate(createAuthenticationProgramStateCommon({
        instructions: lockingInstructions,
        program,
        stack: unlockingResult.stack
      }));
      if (!isPayToScriptHash20(lockingBytecode)) {
        return lockingResult;
      }
      const p2shStack = cloneStack(unlockingResult.stack);
      const p2shScript = p2shStack.pop() ?? Uint8Array.of();
      if (p2shStack.length === 0 && isWitnessProgram(p2shScript)) {
        return lockingResult;
      }
      const p2shInstructions = decodeAuthenticationInstructions(p2shScript);
      return authenticationInstructionsAreMalformed(p2shInstructions) ? {
        ...lockingResult,
        error: AuthenticationErrorCommon.malformedP2shBytecode
      } : stateEvaluate(createAuthenticationProgramStateCommon({
        instructions: p2shInstructions,
        program,
        stack: p2shStack
      }));
    },
    every: (state) => (
      // TODO: implement sigchecks https://gitlab.com/bitcoin-cash-node/bchn-sw/bitcoincash-upgrade-specifications/-/blob/master/spec/2020-05-15-sigchecks.md
      state.stack.length + state.alternateStack.length > ConsensusBCH.maximumStackDepth ? applyError(state, AuthenticationErrorCommon.exceededMaximumStackDepth) : state.operationCount > ConsensusBCH.maximumOperationCount ? applyError(state, AuthenticationErrorCommon.exceededMaximumOperationCount) : state
    ),
    operations: {
      [OpcodesBCH.OP_0]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_1]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_2]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_3]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_4]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_5]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_6]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_7]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_8]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_9]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_10]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_11]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_12]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_13]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_14]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_15]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_16]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_17]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_18]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_19]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_20]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_21]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_22]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_23]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_24]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_25]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_26]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_27]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_28]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_29]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_30]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_31]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_32]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_33]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_34]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_35]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_36]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_37]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_38]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_39]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_40]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_41]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_42]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_43]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_44]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_45]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_46]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_47]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_48]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_49]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_50]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_51]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_52]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_53]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_54]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_55]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_56]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_57]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_58]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_59]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_60]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_61]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_62]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_63]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_64]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_65]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_66]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_67]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_68]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_69]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_70]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_71]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_72]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_73]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_74]: conditionallyPush,
      [OpcodesBCH.OP_PUSHBYTES_75]: conditionallyPush,
      [OpcodesBCH.OP_PUSHDATA_1]: conditionallyPush,
      [OpcodesBCH.OP_PUSHDATA_2]: conditionallyPush,
      [OpcodesBCH.OP_PUSHDATA_4]: conditionallyPush,
      [OpcodesBCH.OP_1NEGATE]: conditionallyEvaluate(pushNumberOperation(-1)),
      [OpcodesBCH.OP_RESERVED]: conditionallyEvaluate(reservedOperation),
      [OpcodesBCH.OP_1]: conditionallyEvaluate(pushNumberOperation(1)),
      /* eslint-disable @typescript-eslint/no-magic-numbers */
      [OpcodesBCH.OP_2]: conditionallyEvaluate(pushNumberOperation(2)),
      [OpcodesBCH.OP_3]: conditionallyEvaluate(pushNumberOperation(3)),
      [OpcodesBCH.OP_4]: conditionallyEvaluate(pushNumberOperation(4)),
      [OpcodesBCH.OP_5]: conditionallyEvaluate(pushNumberOperation(5)),
      [OpcodesBCH.OP_6]: conditionallyEvaluate(pushNumberOperation(6)),
      [OpcodesBCH.OP_7]: conditionallyEvaluate(pushNumberOperation(7)),
      [OpcodesBCH.OP_8]: conditionallyEvaluate(pushNumberOperation(8)),
      [OpcodesBCH.OP_9]: conditionallyEvaluate(pushNumberOperation(9)),
      [OpcodesBCH.OP_10]: conditionallyEvaluate(pushNumberOperation(10)),
      [OpcodesBCH.OP_11]: conditionallyEvaluate(pushNumberOperation(11)),
      [OpcodesBCH.OP_12]: conditionallyEvaluate(pushNumberOperation(12)),
      [OpcodesBCH.OP_13]: conditionallyEvaluate(pushNumberOperation(13)),
      [OpcodesBCH.OP_14]: conditionallyEvaluate(pushNumberOperation(14)),
      [OpcodesBCH.OP_15]: conditionallyEvaluate(pushNumberOperation(15)),
      [OpcodesBCH.OP_16]: conditionallyEvaluate(pushNumberOperation(16)),
      /* eslint-enable @typescript-eslint/no-magic-numbers */
      ...mapOverOperations([incrementOperationCount], {
        [OpcodesBCH.OP_NOP]: conditionallyEvaluate(opNop),
        [OpcodesBCH.OP_VER]: conditionallyEvaluate(reservedOperation),
        [OpcodesBCH.OP_IF]: opIf,
        [OpcodesBCH.OP_NOTIF]: opNotIf,
        [OpcodesBCH.OP_VERIF]: reservedOperation,
        [OpcodesBCH.OP_VERNOTIF]: reservedOperation,
        [OpcodesBCH.OP_ELSE]: opElse,
        [OpcodesBCH.OP_ENDIF]: opEndIf,
        [OpcodesBCH.OP_VERIFY]: conditionallyEvaluate(opVerify),
        [OpcodesBCH.OP_RETURN]: conditionallyEvaluate(opReturn),
        [OpcodesBCH.OP_TOALTSTACK]: conditionallyEvaluate(opToAltStack),
        [OpcodesBCH.OP_FROMALTSTACK]: conditionallyEvaluate(opFromAltStack),
        [OpcodesBCH.OP_2DROP]: conditionallyEvaluate(op2Drop),
        [OpcodesBCH.OP_2DUP]: conditionallyEvaluate(op2Dup),
        [OpcodesBCH.OP_3DUP]: conditionallyEvaluate(op3Dup),
        [OpcodesBCH.OP_2OVER]: conditionallyEvaluate(op2Over),
        [OpcodesBCH.OP_2ROT]: conditionallyEvaluate(op2Rot),
        [OpcodesBCH.OP_2SWAP]: conditionallyEvaluate(op2Swap),
        [OpcodesBCH.OP_IFDUP]: conditionallyEvaluate(opIfDup),
        [OpcodesBCH.OP_DEPTH]: conditionallyEvaluate(opDepth),
        [OpcodesBCH.OP_DROP]: conditionallyEvaluate(opDrop),
        [OpcodesBCH.OP_DUP]: conditionallyEvaluate(opDup),
        [OpcodesBCH.OP_NIP]: conditionallyEvaluate(opNip),
        [OpcodesBCH.OP_OVER]: conditionallyEvaluate(opOver),
        [OpcodesBCH.OP_PICK]: conditionallyEvaluate(opPick),
        [OpcodesBCH.OP_ROLL]: conditionallyEvaluate(opRoll),
        [OpcodesBCH.OP_ROT]: conditionallyEvaluate(opRot),
        [OpcodesBCH.OP_SWAP]: conditionallyEvaluate(opSwap),
        [OpcodesBCH.OP_TUCK]: conditionallyEvaluate(opTuck),
        [OpcodesBCH.OP_CAT]: conditionallyEvaluate(opCat),
        [OpcodesBCH.OP_SPLIT]: conditionallyEvaluate(opSplit),
        [OpcodesBCH.OP_NUM2BIN]: conditionallyEvaluate(opNum2Bin),
        [OpcodesBCH.OP_BIN2NUM]: conditionallyEvaluate(opBin2Num),
        [OpcodesBCH.OP_SIZE]: conditionallyEvaluate(opSize),
        [OpcodesBCH.OP_INVERT]: disabledOperation,
        [OpcodesBCH.OP_AND]: conditionallyEvaluate(opAnd),
        [OpcodesBCH.OP_OR]: conditionallyEvaluate(opOr),
        [OpcodesBCH.OP_XOR]: conditionallyEvaluate(opXor),
        [OpcodesBCH.OP_EQUAL]: conditionallyEvaluate(opEqual),
        [OpcodesBCH.OP_EQUALVERIFY]: conditionallyEvaluate(opEqualVerify),
        [OpcodesBCH.OP_RESERVED1]: conditionallyEvaluate(reservedOperation),
        [OpcodesBCH.OP_RESERVED2]: conditionallyEvaluate(reservedOperation),
        [OpcodesBCH.OP_1ADD]: conditionallyEvaluate(op1Add),
        [OpcodesBCH.OP_1SUB]: conditionallyEvaluate(op1Sub),
        [OpcodesBCH.OP_2MUL]: disabledOperation,
        [OpcodesBCH.OP_2DIV]: disabledOperation,
        [OpcodesBCH.OP_NEGATE]: conditionallyEvaluate(opNegate),
        [OpcodesBCH.OP_ABS]: conditionallyEvaluate(opAbs),
        [OpcodesBCH.OP_NOT]: conditionallyEvaluate(opNot),
        [OpcodesBCH.OP_0NOTEQUAL]: conditionallyEvaluate(op0NotEqual),
        [OpcodesBCH.OP_ADD]: conditionallyEvaluate(opAdd),
        [OpcodesBCH.OP_SUB]: conditionallyEvaluate(opSub),
        [OpcodesBCH.OP_MUL]: conditionallyEvaluate(opMul),
        [OpcodesBCH.OP_DIV]: conditionallyEvaluate(opDiv),
        [OpcodesBCH.OP_MOD]: conditionallyEvaluate(opMod),
        [OpcodesBCH.OP_LSHIFT]: disabledOperation,
        [OpcodesBCH.OP_RSHIFT]: disabledOperation,
        [OpcodesBCH.OP_BOOLAND]: conditionallyEvaluate(opBoolAnd),
        [OpcodesBCH.OP_BOOLOR]: conditionallyEvaluate(opBoolOr),
        [OpcodesBCH.OP_NUMEQUAL]: conditionallyEvaluate(opNumEqual),
        [OpcodesBCH.OP_NUMEQUALVERIFY]: conditionallyEvaluate(opNumEqualVerify),
        [OpcodesBCH.OP_NUMNOTEQUAL]: conditionallyEvaluate(opNumNotEqual),
        [OpcodesBCH.OP_LESSTHAN]: conditionallyEvaluate(opLessThan),
        [OpcodesBCH.OP_GREATERTHAN]: conditionallyEvaluate(opGreaterThan),
        [OpcodesBCH.OP_LESSTHANOREQUAL]: conditionallyEvaluate(opLessThanOrEqual),
        [OpcodesBCH.OP_GREATERTHANOREQUAL]: conditionallyEvaluate(opGreaterThanOrEqual),
        [OpcodesBCH.OP_MIN]: conditionallyEvaluate(opMin),
        [OpcodesBCH.OP_MAX]: conditionallyEvaluate(opMax),
        [OpcodesBCH.OP_WITHIN]: conditionallyEvaluate(opWithin),
        [OpcodesBCH.OP_RIPEMD160]: conditionallyEvaluate(opRipemd160({ ripemd160: ripemd1602 })),
        [OpcodesBCH.OP_SHA1]: conditionallyEvaluate(opSha1({ sha1: sha12 })),
        [OpcodesBCH.OP_SHA256]: conditionallyEvaluate(opSha256({ sha256: sha2562 })),
        [OpcodesBCH.OP_HASH160]: conditionallyEvaluate(opHash160({ ripemd160: ripemd1602, sha256: sha2562 })),
        [OpcodesBCH.OP_HASH256]: conditionallyEvaluate(opHash256({ sha256: sha2562 })),
        [OpcodesBCH.OP_CODESEPARATOR]: conditionallyEvaluate(opCodeSeparator),
        [OpcodesBCH.OP_CHECKSIG]: conditionallyEvaluate(opCheckSig({ secp256k1: secp256k12, sha256: sha2562 })),
        [OpcodesBCH.OP_CHECKSIGVERIFY]: conditionallyEvaluate(opCheckSigVerify({ secp256k1: secp256k12, sha256: sha2562 })),
        [OpcodesBCH.OP_CHECKMULTISIG]: conditionallyEvaluate(opCheckMultiSig({ secp256k1: secp256k12, sha256: sha2562 })),
        [OpcodesBCH.OP_CHECKMULTISIGVERIFY]: conditionallyEvaluate(opCheckMultiSigVerify({ secp256k1: secp256k12, sha256: sha2562 })),
        ...standard ? {
          [OpcodesBCH.OP_NOP1]: conditionallyEvaluate(opNopDisallowed),
          [OpcodesBCH.OP_CHECKLOCKTIMEVERIFY]: conditionallyEvaluate(opCheckLockTimeVerify),
          [OpcodesBCH.OP_CHECKSEQUENCEVERIFY]: conditionallyEvaluate(opCheckSequenceVerify),
          [OpcodesBCH.OP_NOP4]: conditionallyEvaluate(opNopDisallowed),
          [OpcodesBCH.OP_NOP5]: conditionallyEvaluate(opNopDisallowed),
          [OpcodesBCH.OP_NOP6]: conditionallyEvaluate(opNopDisallowed),
          [OpcodesBCH.OP_NOP7]: conditionallyEvaluate(opNopDisallowed),
          [OpcodesBCH.OP_NOP8]: conditionallyEvaluate(opNopDisallowed),
          [OpcodesBCH.OP_NOP9]: conditionallyEvaluate(opNopDisallowed),
          [OpcodesBCH.OP_NOP10]: conditionallyEvaluate(opNopDisallowed)
        } : {
          [OpcodesBCH.OP_NOP1]: conditionallyEvaluate(opNop),
          [OpcodesBCH.OP_CHECKLOCKTIMEVERIFY]: conditionallyEvaluate(opCheckLockTimeVerify),
          [OpcodesBCH.OP_CHECKSEQUENCEVERIFY]: conditionallyEvaluate(opCheckSequenceVerify),
          [OpcodesBCH.OP_NOP4]: conditionallyEvaluate(opNop),
          [OpcodesBCH.OP_NOP5]: conditionallyEvaluate(opNop),
          [OpcodesBCH.OP_NOP6]: conditionallyEvaluate(opNop),
          [OpcodesBCH.OP_NOP7]: conditionallyEvaluate(opNop),
          [OpcodesBCH.OP_NOP8]: conditionallyEvaluate(opNop),
          [OpcodesBCH.OP_NOP9]: conditionallyEvaluate(opNop),
          [OpcodesBCH.OP_NOP10]: conditionallyEvaluate(opNop)
        },
        [OpcodesBCH.OP_CHECKDATASIG]: conditionallyEvaluate(opCheckDataSig({ secp256k1: secp256k12, sha256: sha2562 })),
        [OpcodesBCH.OP_CHECKDATASIGVERIFY]: conditionallyEvaluate(opCheckDataSigVerify({ secp256k1: secp256k12, sha256: sha2562 })),
        [OpcodesBCH.OP_REVERSEBYTES]: conditionallyEvaluate(opReverseBytes),
        [OpcodesBCH.OP_INPUTINDEX]: conditionallyEvaluate(opInputIndex),
        [OpcodesBCH.OP_ACTIVEBYTECODE]: conditionallyEvaluate(opActiveBytecode),
        [OpcodesBCH.OP_TXVERSION]: conditionallyEvaluate(opTxVersion),
        [OpcodesBCH.OP_TXINPUTCOUNT]: conditionallyEvaluate(opTxInputCount),
        [OpcodesBCH.OP_TXOUTPUTCOUNT]: conditionallyEvaluate(opTxOutputCount),
        [OpcodesBCH.OP_TXLOCKTIME]: conditionallyEvaluate(opTxLocktime),
        [OpcodesBCH.OP_UTXOVALUE]: conditionallyEvaluate(opUtxoValue),
        [OpcodesBCH.OP_UTXOBYTECODE]: conditionallyEvaluate(opUtxoBytecode),
        [OpcodesBCH.OP_OUTPOINTTXHASH]: conditionallyEvaluate(opOutpointTxHash),
        [OpcodesBCH.OP_OUTPOINTINDEX]: conditionallyEvaluate(opOutpointIndex),
        [OpcodesBCH.OP_INPUTBYTECODE]: conditionallyEvaluate(opInputBytecode),
        [OpcodesBCH.OP_INPUTSEQUENCENUMBER]: conditionallyEvaluate(opInputSequenceNumber),
        [OpcodesBCH.OP_OUTPUTVALUE]: conditionallyEvaluate(opOutputValue),
        [OpcodesBCH.OP_OUTPUTBYTECODE]: conditionallyEvaluate(opOutputBytecode)
      })
    },
    success: (state) => {
      if (state.error !== void 0) {
        return state.error;
      }
      if (state.controlStack.length !== 0) {
        return AuthenticationErrorCommon.nonEmptyControlStack;
      }
      if (state.stack.length !== 1) {
        return AuthenticationErrorCommon.requiresCleanStack;
      }
      if (!stackItemIsTruthy(state.stack[0])) {
        return AuthenticationErrorCommon.unsuccessfulEvaluation;
      }
      return true;
    },
    undefined: undefinedOperation,
    // eslint-disable-next-line complexity
    verify: ({ sourceOutputs, transaction }, evaluate, stateSuccess) => {
      if (transaction.inputs.length === 0) {
        return "Transactions must have at least one input.";
      }
      if (transaction.outputs.length === 0) {
        return "Transactions must have at least one output.";
      }
      if (transaction.inputs.length !== sourceOutputs.length) {
        return "Unable to verify transaction: a single spent output must be provided for each transaction input.";
      }
      const transactionSize = encodeTransactionBCH(transaction).length;
      if (transactionSize < ConsensusBCH.minimumTransactionSize) {
        return `Transaction does not meet minimum size: the transaction is ${transactionSize} bytes, but the minimum transaction size is ${ConsensusBCH.minimumTransactionSize} bytes.`;
      }
      if (transactionSize > ConsensusBCH.maximumTransactionSize) {
        return `Transaction exceeds maximum size: the transaction is ${transactionSize} bytes, but the maximum transaction size is ${ConsensusBCH.maximumTransactionSize} bytes.`;
      }
      if (standard) {
        if (transaction.version < 1 || transaction.version > ConsensusBCH.maximumStandardVersion) {
          return `Standard transactions must have a version no less than 1 and no greater than ${ConsensusBCH.maximumStandardVersion}.`;
        }
        if (transactionSize > ConsensusBCH.maximumStandardTransactionSize) {
          return `Transaction exceeds maximum standard size: this transaction is ${transactionSize} bytes, but the maximum standard transaction size is ${ConsensusBCH.maximumStandardTransactionSize} bytes.`;
        }
        for (const [index2, output] of sourceOutputs.entries()) {
          if (!isStandardOutputBytecode(output.lockingBytecode)) {
            return `Standard transactions may only spend standard output types, but source output ${index2} is non-standard.`;
          }
        }
        let totalArbitraryDataBytes = 0;
        for (const [index2, output] of transaction.outputs.entries()) {
          if (!isStandardOutputBytecode(output.lockingBytecode)) {
            return `Standard transactions may only create standard output types, but transaction output ${index2} is non-standard.`;
          }
          if (isArbitraryDataOutput(output.lockingBytecode)) {
            totalArbitraryDataBytes += output.lockingBytecode.length + 1;
          }
        }
        if (totalArbitraryDataBytes > ConsensusBCH.maximumDataCarrierBytes) {
          return `Standard transactions may carry no more than ${ConsensusBCH.maximumDataCarrierBytes} bytes in arbitrary data outputs; this transaction includes ${totalArbitraryDataBytes} bytes of arbitrary data.`;
        }
        for (const [index2, input] of transaction.inputs.entries()) {
          if (input.unlockingBytecode.length > ConsensusBCH.maximumStandardUnlockingBytecodeLength) {
            return `Input index ${index2} is non-standard: the unlocking bytecode (${input.unlockingBytecode.length} bytes) exceeds the maximum standard unlocking bytecode length (${ConsensusBCH.maximumStandardUnlockingBytecodeLength} bytes).`;
          }
          if (!isPushOnly(input.unlockingBytecode)) {
            return `Input index ${index2} is non-standard: unlocking bytecode may contain only push operations.`;
          }
        }
      }
      for (const index2 of transaction.inputs.keys()) {
        const state = evaluate({
          inputIndex: index2,
          sourceOutputs,
          transaction
        });
        const result = stateSuccess(state);
        if (typeof result === "string") {
          return `Error in evaluating input index ${index2}: ${result}`;
        }
      }
      return true;
    }
  };
};

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/bch/2022/bch-2022-opcodes.js
var import_dist232 = __toESM(require_dist(), 1);
var import_dist233 = __toESM(require_dist2(), 1);
var import_dist234 = __toESM(require_dist3(), 1);
var OpcodesBCH2022;
(function(OpcodesBCH20222) {
  OpcodesBCH20222[OpcodesBCH20222["OP_0"] = 0] = "OP_0";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_1"] = 1] = "OP_PUSHBYTES_1";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_2"] = 2] = "OP_PUSHBYTES_2";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_3"] = 3] = "OP_PUSHBYTES_3";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_4"] = 4] = "OP_PUSHBYTES_4";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_5"] = 5] = "OP_PUSHBYTES_5";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_6"] = 6] = "OP_PUSHBYTES_6";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_7"] = 7] = "OP_PUSHBYTES_7";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_8"] = 8] = "OP_PUSHBYTES_8";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_9"] = 9] = "OP_PUSHBYTES_9";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_10"] = 10] = "OP_PUSHBYTES_10";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_11"] = 11] = "OP_PUSHBYTES_11";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_12"] = 12] = "OP_PUSHBYTES_12";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_13"] = 13] = "OP_PUSHBYTES_13";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_14"] = 14] = "OP_PUSHBYTES_14";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_15"] = 15] = "OP_PUSHBYTES_15";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_16"] = 16] = "OP_PUSHBYTES_16";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_17"] = 17] = "OP_PUSHBYTES_17";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_18"] = 18] = "OP_PUSHBYTES_18";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_19"] = 19] = "OP_PUSHBYTES_19";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_20"] = 20] = "OP_PUSHBYTES_20";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_21"] = 21] = "OP_PUSHBYTES_21";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_22"] = 22] = "OP_PUSHBYTES_22";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_23"] = 23] = "OP_PUSHBYTES_23";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_24"] = 24] = "OP_PUSHBYTES_24";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_25"] = 25] = "OP_PUSHBYTES_25";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_26"] = 26] = "OP_PUSHBYTES_26";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_27"] = 27] = "OP_PUSHBYTES_27";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_28"] = 28] = "OP_PUSHBYTES_28";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_29"] = 29] = "OP_PUSHBYTES_29";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_30"] = 30] = "OP_PUSHBYTES_30";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_31"] = 31] = "OP_PUSHBYTES_31";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_32"] = 32] = "OP_PUSHBYTES_32";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_33"] = 33] = "OP_PUSHBYTES_33";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_34"] = 34] = "OP_PUSHBYTES_34";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_35"] = 35] = "OP_PUSHBYTES_35";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_36"] = 36] = "OP_PUSHBYTES_36";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_37"] = 37] = "OP_PUSHBYTES_37";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_38"] = 38] = "OP_PUSHBYTES_38";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_39"] = 39] = "OP_PUSHBYTES_39";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_40"] = 40] = "OP_PUSHBYTES_40";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_41"] = 41] = "OP_PUSHBYTES_41";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_42"] = 42] = "OP_PUSHBYTES_42";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_43"] = 43] = "OP_PUSHBYTES_43";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_44"] = 44] = "OP_PUSHBYTES_44";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_45"] = 45] = "OP_PUSHBYTES_45";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_46"] = 46] = "OP_PUSHBYTES_46";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_47"] = 47] = "OP_PUSHBYTES_47";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_48"] = 48] = "OP_PUSHBYTES_48";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_49"] = 49] = "OP_PUSHBYTES_49";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_50"] = 50] = "OP_PUSHBYTES_50";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_51"] = 51] = "OP_PUSHBYTES_51";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_52"] = 52] = "OP_PUSHBYTES_52";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_53"] = 53] = "OP_PUSHBYTES_53";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_54"] = 54] = "OP_PUSHBYTES_54";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_55"] = 55] = "OP_PUSHBYTES_55";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_56"] = 56] = "OP_PUSHBYTES_56";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_57"] = 57] = "OP_PUSHBYTES_57";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_58"] = 58] = "OP_PUSHBYTES_58";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_59"] = 59] = "OP_PUSHBYTES_59";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_60"] = 60] = "OP_PUSHBYTES_60";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_61"] = 61] = "OP_PUSHBYTES_61";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_62"] = 62] = "OP_PUSHBYTES_62";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_63"] = 63] = "OP_PUSHBYTES_63";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_64"] = 64] = "OP_PUSHBYTES_64";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_65"] = 65] = "OP_PUSHBYTES_65";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_66"] = 66] = "OP_PUSHBYTES_66";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_67"] = 67] = "OP_PUSHBYTES_67";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_68"] = 68] = "OP_PUSHBYTES_68";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_69"] = 69] = "OP_PUSHBYTES_69";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_70"] = 70] = "OP_PUSHBYTES_70";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_71"] = 71] = "OP_PUSHBYTES_71";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_72"] = 72] = "OP_PUSHBYTES_72";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_73"] = 73] = "OP_PUSHBYTES_73";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_74"] = 74] = "OP_PUSHBYTES_74";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHBYTES_75"] = 75] = "OP_PUSHBYTES_75";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHDATA_1"] = 76] = "OP_PUSHDATA_1";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHDATA_2"] = 77] = "OP_PUSHDATA_2";
  OpcodesBCH20222[OpcodesBCH20222["OP_PUSHDATA_4"] = 78] = "OP_PUSHDATA_4";
  OpcodesBCH20222[OpcodesBCH20222["OP_1NEGATE"] = 79] = "OP_1NEGATE";
  OpcodesBCH20222[OpcodesBCH20222["OP_RESERVED"] = 80] = "OP_RESERVED";
  OpcodesBCH20222[OpcodesBCH20222["OP_1"] = 81] = "OP_1";
  OpcodesBCH20222[OpcodesBCH20222["OP_2"] = 82] = "OP_2";
  OpcodesBCH20222[OpcodesBCH20222["OP_3"] = 83] = "OP_3";
  OpcodesBCH20222[OpcodesBCH20222["OP_4"] = 84] = "OP_4";
  OpcodesBCH20222[OpcodesBCH20222["OP_5"] = 85] = "OP_5";
  OpcodesBCH20222[OpcodesBCH20222["OP_6"] = 86] = "OP_6";
  OpcodesBCH20222[OpcodesBCH20222["OP_7"] = 87] = "OP_7";
  OpcodesBCH20222[OpcodesBCH20222["OP_8"] = 88] = "OP_8";
  OpcodesBCH20222[OpcodesBCH20222["OP_9"] = 89] = "OP_9";
  OpcodesBCH20222[OpcodesBCH20222["OP_10"] = 90] = "OP_10";
  OpcodesBCH20222[OpcodesBCH20222["OP_11"] = 91] = "OP_11";
  OpcodesBCH20222[OpcodesBCH20222["OP_12"] = 92] = "OP_12";
  OpcodesBCH20222[OpcodesBCH20222["OP_13"] = 93] = "OP_13";
  OpcodesBCH20222[OpcodesBCH20222["OP_14"] = 94] = "OP_14";
  OpcodesBCH20222[OpcodesBCH20222["OP_15"] = 95] = "OP_15";
  OpcodesBCH20222[OpcodesBCH20222["OP_16"] = 96] = "OP_16";
  OpcodesBCH20222[OpcodesBCH20222["OP_NOP"] = 97] = "OP_NOP";
  OpcodesBCH20222[OpcodesBCH20222["OP_VER"] = 98] = "OP_VER";
  OpcodesBCH20222[OpcodesBCH20222["OP_IF"] = 99] = "OP_IF";
  OpcodesBCH20222[OpcodesBCH20222["OP_NOTIF"] = 100] = "OP_NOTIF";
  OpcodesBCH20222[OpcodesBCH20222["OP_VERIF"] = 101] = "OP_VERIF";
  OpcodesBCH20222[OpcodesBCH20222["OP_VERNOTIF"] = 102] = "OP_VERNOTIF";
  OpcodesBCH20222[OpcodesBCH20222["OP_ELSE"] = 103] = "OP_ELSE";
  OpcodesBCH20222[OpcodesBCH20222["OP_ENDIF"] = 104] = "OP_ENDIF";
  OpcodesBCH20222[OpcodesBCH20222["OP_VERIFY"] = 105] = "OP_VERIFY";
  OpcodesBCH20222[OpcodesBCH20222["OP_RETURN"] = 106] = "OP_RETURN";
  OpcodesBCH20222[OpcodesBCH20222["OP_TOALTSTACK"] = 107] = "OP_TOALTSTACK";
  OpcodesBCH20222[OpcodesBCH20222["OP_FROMALTSTACK"] = 108] = "OP_FROMALTSTACK";
  OpcodesBCH20222[OpcodesBCH20222["OP_2DROP"] = 109] = "OP_2DROP";
  OpcodesBCH20222[OpcodesBCH20222["OP_2DUP"] = 110] = "OP_2DUP";
  OpcodesBCH20222[OpcodesBCH20222["OP_3DUP"] = 111] = "OP_3DUP";
  OpcodesBCH20222[OpcodesBCH20222["OP_2OVER"] = 112] = "OP_2OVER";
  OpcodesBCH20222[OpcodesBCH20222["OP_2ROT"] = 113] = "OP_2ROT";
  OpcodesBCH20222[OpcodesBCH20222["OP_2SWAP"] = 114] = "OP_2SWAP";
  OpcodesBCH20222[OpcodesBCH20222["OP_IFDUP"] = 115] = "OP_IFDUP";
  OpcodesBCH20222[OpcodesBCH20222["OP_DEPTH"] = 116] = "OP_DEPTH";
  OpcodesBCH20222[OpcodesBCH20222["OP_DROP"] = 117] = "OP_DROP";
  OpcodesBCH20222[OpcodesBCH20222["OP_DUP"] = 118] = "OP_DUP";
  OpcodesBCH20222[OpcodesBCH20222["OP_NIP"] = 119] = "OP_NIP";
  OpcodesBCH20222[OpcodesBCH20222["OP_OVER"] = 120] = "OP_OVER";
  OpcodesBCH20222[OpcodesBCH20222["OP_PICK"] = 121] = "OP_PICK";
  OpcodesBCH20222[OpcodesBCH20222["OP_ROLL"] = 122] = "OP_ROLL";
  OpcodesBCH20222[OpcodesBCH20222["OP_ROT"] = 123] = "OP_ROT";
  OpcodesBCH20222[OpcodesBCH20222["OP_SWAP"] = 124] = "OP_SWAP";
  OpcodesBCH20222[OpcodesBCH20222["OP_TUCK"] = 125] = "OP_TUCK";
  OpcodesBCH20222[OpcodesBCH20222["OP_CAT"] = 126] = "OP_CAT";
  OpcodesBCH20222[OpcodesBCH20222["OP_SPLIT"] = 127] = "OP_SPLIT";
  OpcodesBCH20222[OpcodesBCH20222["OP_NUM2BIN"] = 128] = "OP_NUM2BIN";
  OpcodesBCH20222[OpcodesBCH20222["OP_BIN2NUM"] = 129] = "OP_BIN2NUM";
  OpcodesBCH20222[OpcodesBCH20222["OP_SIZE"] = 130] = "OP_SIZE";
  OpcodesBCH20222[OpcodesBCH20222["OP_INVERT"] = 131] = "OP_INVERT";
  OpcodesBCH20222[OpcodesBCH20222["OP_AND"] = 132] = "OP_AND";
  OpcodesBCH20222[OpcodesBCH20222["OP_OR"] = 133] = "OP_OR";
  OpcodesBCH20222[OpcodesBCH20222["OP_XOR"] = 134] = "OP_XOR";
  OpcodesBCH20222[OpcodesBCH20222["OP_EQUAL"] = 135] = "OP_EQUAL";
  OpcodesBCH20222[OpcodesBCH20222["OP_EQUALVERIFY"] = 136] = "OP_EQUALVERIFY";
  OpcodesBCH20222[OpcodesBCH20222["OP_RESERVED1"] = 137] = "OP_RESERVED1";
  OpcodesBCH20222[OpcodesBCH20222["OP_RESERVED2"] = 138] = "OP_RESERVED2";
  OpcodesBCH20222[OpcodesBCH20222["OP_1ADD"] = 139] = "OP_1ADD";
  OpcodesBCH20222[OpcodesBCH20222["OP_1SUB"] = 140] = "OP_1SUB";
  OpcodesBCH20222[OpcodesBCH20222["OP_2MUL"] = 141] = "OP_2MUL";
  OpcodesBCH20222[OpcodesBCH20222["OP_2DIV"] = 142] = "OP_2DIV";
  OpcodesBCH20222[OpcodesBCH20222["OP_NEGATE"] = 143] = "OP_NEGATE";
  OpcodesBCH20222[OpcodesBCH20222["OP_ABS"] = 144] = "OP_ABS";
  OpcodesBCH20222[OpcodesBCH20222["OP_NOT"] = 145] = "OP_NOT";
  OpcodesBCH20222[OpcodesBCH20222["OP_0NOTEQUAL"] = 146] = "OP_0NOTEQUAL";
  OpcodesBCH20222[OpcodesBCH20222["OP_ADD"] = 147] = "OP_ADD";
  OpcodesBCH20222[OpcodesBCH20222["OP_SUB"] = 148] = "OP_SUB";
  OpcodesBCH20222[OpcodesBCH20222["OP_MUL"] = 149] = "OP_MUL";
  OpcodesBCH20222[OpcodesBCH20222["OP_DIV"] = 150] = "OP_DIV";
  OpcodesBCH20222[OpcodesBCH20222["OP_MOD"] = 151] = "OP_MOD";
  OpcodesBCH20222[OpcodesBCH20222["OP_LSHIFT"] = 152] = "OP_LSHIFT";
  OpcodesBCH20222[OpcodesBCH20222["OP_RSHIFT"] = 153] = "OP_RSHIFT";
  OpcodesBCH20222[OpcodesBCH20222["OP_BOOLAND"] = 154] = "OP_BOOLAND";
  OpcodesBCH20222[OpcodesBCH20222["OP_BOOLOR"] = 155] = "OP_BOOLOR";
  OpcodesBCH20222[OpcodesBCH20222["OP_NUMEQUAL"] = 156] = "OP_NUMEQUAL";
  OpcodesBCH20222[OpcodesBCH20222["OP_NUMEQUALVERIFY"] = 157] = "OP_NUMEQUALVERIFY";
  OpcodesBCH20222[OpcodesBCH20222["OP_NUMNOTEQUAL"] = 158] = "OP_NUMNOTEQUAL";
  OpcodesBCH20222[OpcodesBCH20222["OP_LESSTHAN"] = 159] = "OP_LESSTHAN";
  OpcodesBCH20222[OpcodesBCH20222["OP_GREATERTHAN"] = 160] = "OP_GREATERTHAN";
  OpcodesBCH20222[OpcodesBCH20222["OP_LESSTHANOREQUAL"] = 161] = "OP_LESSTHANOREQUAL";
  OpcodesBCH20222[OpcodesBCH20222["OP_GREATERTHANOREQUAL"] = 162] = "OP_GREATERTHANOREQUAL";
  OpcodesBCH20222[OpcodesBCH20222["OP_MIN"] = 163] = "OP_MIN";
  OpcodesBCH20222[OpcodesBCH20222["OP_MAX"] = 164] = "OP_MAX";
  OpcodesBCH20222[OpcodesBCH20222["OP_WITHIN"] = 165] = "OP_WITHIN";
  OpcodesBCH20222[OpcodesBCH20222["OP_RIPEMD160"] = 166] = "OP_RIPEMD160";
  OpcodesBCH20222[OpcodesBCH20222["OP_SHA1"] = 167] = "OP_SHA1";
  OpcodesBCH20222[OpcodesBCH20222["OP_SHA256"] = 168] = "OP_SHA256";
  OpcodesBCH20222[OpcodesBCH20222["OP_HASH160"] = 169] = "OP_HASH160";
  OpcodesBCH20222[OpcodesBCH20222["OP_HASH256"] = 170] = "OP_HASH256";
  OpcodesBCH20222[OpcodesBCH20222["OP_CODESEPARATOR"] = 171] = "OP_CODESEPARATOR";
  OpcodesBCH20222[OpcodesBCH20222["OP_CHECKSIG"] = 172] = "OP_CHECKSIG";
  OpcodesBCH20222[OpcodesBCH20222["OP_CHECKSIGVERIFY"] = 173] = "OP_CHECKSIGVERIFY";
  OpcodesBCH20222[OpcodesBCH20222["OP_CHECKMULTISIG"] = 174] = "OP_CHECKMULTISIG";
  OpcodesBCH20222[OpcodesBCH20222["OP_CHECKMULTISIGVERIFY"] = 175] = "OP_CHECKMULTISIGVERIFY";
  OpcodesBCH20222[OpcodesBCH20222["OP_NOP1"] = 176] = "OP_NOP1";
  OpcodesBCH20222[OpcodesBCH20222["OP_CHECKLOCKTIMEVERIFY"] = 177] = "OP_CHECKLOCKTIMEVERIFY";
  OpcodesBCH20222[OpcodesBCH20222["OP_CHECKSEQUENCEVERIFY"] = 178] = "OP_CHECKSEQUENCEVERIFY";
  OpcodesBCH20222[OpcodesBCH20222["OP_NOP4"] = 179] = "OP_NOP4";
  OpcodesBCH20222[OpcodesBCH20222["OP_NOP5"] = 180] = "OP_NOP5";
  OpcodesBCH20222[OpcodesBCH20222["OP_NOP6"] = 181] = "OP_NOP6";
  OpcodesBCH20222[OpcodesBCH20222["OP_NOP7"] = 182] = "OP_NOP7";
  OpcodesBCH20222[OpcodesBCH20222["OP_NOP8"] = 183] = "OP_NOP8";
  OpcodesBCH20222[OpcodesBCH20222["OP_NOP9"] = 184] = "OP_NOP9";
  OpcodesBCH20222[OpcodesBCH20222["OP_NOP10"] = 185] = "OP_NOP10";
  OpcodesBCH20222[OpcodesBCH20222["OP_CHECKDATASIG"] = 186] = "OP_CHECKDATASIG";
  OpcodesBCH20222[OpcodesBCH20222["OP_CHECKDATASIGVERIFY"] = 187] = "OP_CHECKDATASIGVERIFY";
  OpcodesBCH20222[OpcodesBCH20222["OP_REVERSEBYTES"] = 188] = "OP_REVERSEBYTES";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN189"] = 189] = "OP_UNKNOWN189";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN190"] = 190] = "OP_UNKNOWN190";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN191"] = 191] = "OP_UNKNOWN191";
  OpcodesBCH20222[OpcodesBCH20222["OP_INPUTINDEX"] = 192] = "OP_INPUTINDEX";
  OpcodesBCH20222[OpcodesBCH20222["OP_ACTIVEBYTECODE"] = 193] = "OP_ACTIVEBYTECODE";
  OpcodesBCH20222[OpcodesBCH20222["OP_TXVERSION"] = 194] = "OP_TXVERSION";
  OpcodesBCH20222[OpcodesBCH20222["OP_TXINPUTCOUNT"] = 195] = "OP_TXINPUTCOUNT";
  OpcodesBCH20222[OpcodesBCH20222["OP_TXOUTPUTCOUNT"] = 196] = "OP_TXOUTPUTCOUNT";
  OpcodesBCH20222[OpcodesBCH20222["OP_TXLOCKTIME"] = 197] = "OP_TXLOCKTIME";
  OpcodesBCH20222[OpcodesBCH20222["OP_UTXOVALUE"] = 198] = "OP_UTXOVALUE";
  OpcodesBCH20222[OpcodesBCH20222["OP_UTXOBYTECODE"] = 199] = "OP_UTXOBYTECODE";
  OpcodesBCH20222[OpcodesBCH20222["OP_OUTPOINTTXHASH"] = 200] = "OP_OUTPOINTTXHASH";
  OpcodesBCH20222[OpcodesBCH20222["OP_OUTPOINTINDEX"] = 201] = "OP_OUTPOINTINDEX";
  OpcodesBCH20222[OpcodesBCH20222["OP_INPUTBYTECODE"] = 202] = "OP_INPUTBYTECODE";
  OpcodesBCH20222[OpcodesBCH20222["OP_INPUTSEQUENCENUMBER"] = 203] = "OP_INPUTSEQUENCENUMBER";
  OpcodesBCH20222[OpcodesBCH20222["OP_OUTPUTVALUE"] = 204] = "OP_OUTPUTVALUE";
  OpcodesBCH20222[OpcodesBCH20222["OP_OUTPUTBYTECODE"] = 205] = "OP_OUTPUTBYTECODE";
  OpcodesBCH20222[OpcodesBCH20222["OP_RESERVED3"] = 206] = "OP_RESERVED3";
  OpcodesBCH20222[OpcodesBCH20222["OP_RESERVED4"] = 207] = "OP_RESERVED4";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN208"] = 208] = "OP_UNKNOWN208";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN209"] = 209] = "OP_UNKNOWN209";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN210"] = 210] = "OP_UNKNOWN210";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN211"] = 211] = "OP_UNKNOWN211";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN212"] = 212] = "OP_UNKNOWN212";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN213"] = 213] = "OP_UNKNOWN213";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN214"] = 214] = "OP_UNKNOWN214";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN215"] = 215] = "OP_UNKNOWN215";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN216"] = 216] = "OP_UNKNOWN216";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN217"] = 217] = "OP_UNKNOWN217";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN218"] = 218] = "OP_UNKNOWN218";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN219"] = 219] = "OP_UNKNOWN219";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN220"] = 220] = "OP_UNKNOWN220";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN221"] = 221] = "OP_UNKNOWN221";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN222"] = 222] = "OP_UNKNOWN222";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN223"] = 223] = "OP_UNKNOWN223";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN224"] = 224] = "OP_UNKNOWN224";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN225"] = 225] = "OP_UNKNOWN225";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN226"] = 226] = "OP_UNKNOWN226";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN227"] = 227] = "OP_UNKNOWN227";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN228"] = 228] = "OP_UNKNOWN228";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN229"] = 229] = "OP_UNKNOWN229";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN230"] = 230] = "OP_UNKNOWN230";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN231"] = 231] = "OP_UNKNOWN231";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN232"] = 232] = "OP_UNKNOWN232";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN233"] = 233] = "OP_UNKNOWN233";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN234"] = 234] = "OP_UNKNOWN234";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN235"] = 235] = "OP_UNKNOWN235";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN236"] = 236] = "OP_UNKNOWN236";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN237"] = 237] = "OP_UNKNOWN237";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN238"] = 238] = "OP_UNKNOWN238";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN239"] = 239] = "OP_UNKNOWN239";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN240"] = 240] = "OP_UNKNOWN240";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN241"] = 241] = "OP_UNKNOWN241";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN242"] = 242] = "OP_UNKNOWN242";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN243"] = 243] = "OP_UNKNOWN243";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN244"] = 244] = "OP_UNKNOWN244";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN245"] = 245] = "OP_UNKNOWN245";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN246"] = 246] = "OP_UNKNOWN246";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN247"] = 247] = "OP_UNKNOWN247";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN248"] = 248] = "OP_UNKNOWN248";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN249"] = 249] = "OP_UNKNOWN249";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN250"] = 250] = "OP_UNKNOWN250";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN251"] = 251] = "OP_UNKNOWN251";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN252"] = 252] = "OP_UNKNOWN252";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN253"] = 253] = "OP_UNKNOWN253";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN254"] = 254] = "OP_UNKNOWN254";
  OpcodesBCH20222[OpcodesBCH20222["OP_UNKNOWN255"] = 255] = "OP_UNKNOWN255";
})(OpcodesBCH2022 || (OpcodesBCH2022 = {}));

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/xec/xec-vm-number-operations.js
var import_dist238 = __toESM(require_dist(), 1);
var import_dist239 = __toESM(require_dist2(), 1);
var import_dist240 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/xec/xec-types.js
var import_dist235 = __toESM(require_dist(), 1);
var import_dist236 = __toESM(require_dist2(), 1);
var import_dist237 = __toESM(require_dist3(), 1);
var ConsensusXEC;
(function(ConsensusXEC2) {
  ConsensusXEC2[ConsensusXEC2["maximumStackItemLength"] = 520] = "maximumStackItemLength";
  ConsensusXEC2[ConsensusXEC2["maximumVmNumberLength"] = 4] = "maximumVmNumberLength";
  ConsensusXEC2[ConsensusXEC2["maximumOperationCount"] = 201] = "maximumOperationCount";
  ConsensusXEC2[ConsensusXEC2["maximumBytecodeLength"] = 1e4] = "maximumBytecodeLength";
  ConsensusXEC2[ConsensusXEC2["maximumStackDepth"] = 1e3] = "maximumStackDepth";
  ConsensusXEC2[ConsensusXEC2["schnorrSignatureLength"] = 64] = "schnorrSignatureLength";
})(ConsensusXEC || (ConsensusXEC = {}));

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/xec/xec-vm-number-operations.js
var maximumVmNumberByteLength = ConsensusXEC.maximumVmNumberLength;
var opPick4Byte = (state) => useOneVmNumber(state, (nextState, depth) => {
  const item = nextState.stack[nextState.stack.length - 1 - Number(depth)];
  if (item === void 0) {
    return applyError(state, AuthenticationErrorCommon.invalidStackIndex);
  }
  return pushToStack(nextState, item.slice());
});
var opRoll4Byte = (state) => useOneVmNumber(state, (nextState, depth) => {
  const index2 = nextState.stack.length - 1 - Number(depth);
  if (index2 < 0 || index2 > nextState.stack.length - 1) {
    return applyError(state, AuthenticationErrorCommon.invalidStackIndex);
  }
  return pushToStack(nextState, nextState.stack.splice(index2, 1)[0]);
});
var opSplit4Byte = (state) => useOneVmNumber(state, (nextState, value) => {
  const index2 = Number(value);
  return useOneStackItem(nextState, (finalState, [item]) => index2 < 0 || index2 > item.length ? applyError(finalState, AuthenticationErrorCommon.invalidSplitIndex) : pushToStack(finalState, item.slice(0, index2), item.slice(index2)));
}, { maximumVmNumberByteLength });
var opNum2Bin4Byte = (state) => useOneVmNumber(state, (nextState, value) => {
  const targetLength = Number(value);
  return targetLength > ConsensusXEC.maximumStackItemLength ? applyError(nextState, AuthenticationErrorCommon.exceededMaximumStackItemLength) : useOneVmNumber(nextState, (finalState, [target]) => {
    const minimallyEncoded = bigIntToVmNumber(target);
    return minimallyEncoded.length > targetLength ? applyError(finalState, AuthenticationErrorCommon.insufficientLength) : minimallyEncoded.length === targetLength ? pushToStack(finalState, minimallyEncoded) : pushToStack(finalState, padMinimallyEncodedVmNumber(minimallyEncoded, targetLength));
  }, {
    maximumVmNumberByteLength: ConsensusXEC.maximumStackItemLength,
    requireMinimalEncoding: false
  });
});
var opBin2Num4Byte = (state) => useOneVmNumber(state, (nextState, [target]) => {
  const minimallyEncoded = bigIntToVmNumber(target);
  return minimallyEncoded.length > ConsensusXEC.maximumVmNumberLength ? applyError(nextState, AuthenticationErrorCommon.exceededMaximumVmNumberLength) : pushToStack(nextState, minimallyEncoded);
}, {
  maximumVmNumberByteLength: ConsensusXEC.maximumStackItemLength,
  requireMinimalEncoding: false
});
var op1Add4Byte = (state) => useOneVmNumber(state, (nextState, [value]) => pushToStack(nextState, bigIntToVmNumber(value + 1n)), { maximumVmNumberByteLength });
var op1Sub4Byte = (state) => useOneVmNumber(state, (nextState, [value]) => pushToStack(nextState, bigIntToVmNumber(value - 1n)), { maximumVmNumberByteLength });
var opNegate4Byte = (state) => useOneVmNumber(state, (nextState, [value]) => pushToStack(nextState, bigIntToVmNumber(-value)), { maximumVmNumberByteLength });
var opAbs4Byte = (state) => useOneVmNumber(state, (nextState, [value]) => pushToStack(nextState, bigIntToVmNumber(value < 0 ? -value : value)), { maximumVmNumberByteLength });
var opNot4Byte = (state) => useOneVmNumber(state, (nextState, [value]) => pushToStack(nextState, value === 0n ? bigIntToVmNumber(1n) : bigIntToVmNumber(0n)), { maximumVmNumberByteLength });
var op0NotEqual4Byte = (state) => useOneVmNumber(state, (nextState, [value]) => pushToStack(nextState, value === 0n ? bigIntToVmNumber(0n) : bigIntToVmNumber(1n)), { maximumVmNumberByteLength });
var opAdd4Byte = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, bigIntToVmNumber(firstValue + secondValue)), { maximumVmNumberByteLength });
var opSub4Byte = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, bigIntToVmNumber(firstValue - secondValue)), { maximumVmNumberByteLength });
var opDiv4Byte = (state) => useTwoVmNumbers(state, (nextState, [a, b]) => b === 0n ? applyError(nextState, AuthenticationErrorCommon.divisionByZero) : pushToStack(nextState, bigIntToVmNumber(a / b)), { maximumVmNumberByteLength });
var opMod4Byte = (state) => useTwoVmNumbers(state, (nextState, [a, b]) => b === 0n ? applyError(nextState, AuthenticationErrorCommon.divisionByZero) : pushToStack(nextState, bigIntToVmNumber(a % b)), { maximumVmNumberByteLength });
var opBoolAnd4Byte = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToVmNumber(firstValue !== 0n && secondValue !== 0n)), { maximumVmNumberByteLength });
var opBoolOr4Byte = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToVmNumber(firstValue !== 0n || secondValue !== 0n)), { maximumVmNumberByteLength });
var opNumEqual4Byte = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToVmNumber(firstValue === secondValue)), { maximumVmNumberByteLength });
var opNumEqualVerify4Byte = combineOperations(opNumEqual4Byte, opVerify);
var opNumNotEqual4Byte = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToVmNumber(firstValue !== secondValue)), { maximumVmNumberByteLength });
var opLessThan4Byte = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToVmNumber(firstValue < secondValue)), { maximumVmNumberByteLength });
var opLessThanOrEqual4Byte = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToVmNumber(firstValue <= secondValue)), { maximumVmNumberByteLength });
var opGreaterThan4Byte = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToVmNumber(firstValue > secondValue)), { maximumVmNumberByteLength });
var opGreaterThanOrEqual4Byte = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToVmNumber(firstValue >= secondValue)), { maximumVmNumberByteLength });
var opMin4Byte = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, bigIntToVmNumber(firstValue < secondValue ? firstValue : secondValue)), { maximumVmNumberByteLength });
var opMax4Byte = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, bigIntToVmNumber(firstValue > secondValue ? firstValue : secondValue)), { maximumVmNumberByteLength });
var opWithin4Byte = (state) => useThreeVmNumbers(state, (nextState, [firstValue, secondValue, thirdValue]) => pushToStack(nextState, booleanToVmNumber(secondValue <= firstValue && firstValue < thirdValue)), { maximumVmNumberByteLength });

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/xec/xec-instruction-set.js
var createInstructionSetXEC = (standard = true) => {
  const instructionSet = createInstructionSetBCH2022(standard);
  return {
    ...instructionSet,
    operations: {
      ...instructionSet.operations,
      ...mapOverOperations([conditionallyEvaluate, incrementOperationCount], {
        [OpcodesBCH2022.OP_PICK]: opPick4Byte,
        [OpcodesBCH2022.OP_ROLL]: opRoll4Byte,
        [OpcodesBCH2022.OP_SPLIT]: opSplit4Byte,
        [OpcodesBCH2022.OP_NUM2BIN]: opNum2Bin4Byte,
        [OpcodesBCH2022.OP_BIN2NUM]: opBin2Num4Byte,
        [OpcodesBCH2022.OP_1ADD]: op1Add4Byte,
        [OpcodesBCH2022.OP_1SUB]: op1Sub4Byte,
        [OpcodesBCH2022.OP_NEGATE]: opNegate4Byte,
        [OpcodesBCH2022.OP_ABS]: opAbs4Byte,
        [OpcodesBCH2022.OP_NOT]: opNot4Byte,
        [OpcodesBCH2022.OP_0NOTEQUAL]: op0NotEqual4Byte,
        [OpcodesBCH2022.OP_ADD]: opAdd4Byte,
        [OpcodesBCH2022.OP_SUB]: opSub4Byte,
        [OpcodesBCH2022.OP_MUL]: disabledOperation,
        [OpcodesBCH2022.OP_DIV]: opDiv4Byte,
        [OpcodesBCH2022.OP_MOD]: opMod4Byte,
        [OpcodesBCH2022.OP_BOOLAND]: opBoolAnd4Byte,
        [OpcodesBCH2022.OP_BOOLOR]: opBoolOr4Byte,
        [OpcodesBCH2022.OP_NUMEQUAL]: opNumEqual4Byte,
        [OpcodesBCH2022.OP_NUMEQUALVERIFY]: opNumEqualVerify4Byte,
        [OpcodesBCH2022.OP_NUMNOTEQUAL]: opNumNotEqual4Byte,
        [OpcodesBCH2022.OP_LESSTHAN]: opLessThan4Byte,
        [OpcodesBCH2022.OP_GREATERTHAN]: opGreaterThan4Byte,
        [OpcodesBCH2022.OP_LESSTHANOREQUAL]: opLessThanOrEqual4Byte,
        [OpcodesBCH2022.OP_GREATERTHANOREQUAL]: opGreaterThanOrEqual4Byte,
        [OpcodesBCH2022.OP_MIN]: opMin4Byte,
        [OpcodesBCH2022.OP_MAX]: opMax4Byte,
        [OpcodesBCH2022.OP_WITHIN]: opWithin4Byte
      }),
      [OpcodesBCH2022.OP_INPUTINDEX]: undefinedOperation,
      [OpcodesBCH2022.OP_ACTIVEBYTECODE]: undefinedOperation,
      [OpcodesBCH2022.OP_TXVERSION]: undefinedOperation,
      [OpcodesBCH2022.OP_TXINPUTCOUNT]: undefinedOperation,
      [OpcodesBCH2022.OP_TXOUTPUTCOUNT]: undefinedOperation,
      [OpcodesBCH2022.OP_TXLOCKTIME]: undefinedOperation,
      [OpcodesBCH2022.OP_UTXOVALUE]: undefinedOperation,
      [OpcodesBCH2022.OP_UTXOBYTECODE]: undefinedOperation,
      [OpcodesBCH2022.OP_OUTPOINTTXHASH]: undefinedOperation,
      [OpcodesBCH2022.OP_OUTPOINTINDEX]: undefinedOperation,
      [OpcodesBCH2022.OP_INPUTBYTECODE]: undefinedOperation,
      [OpcodesBCH2022.OP_INPUTSEQUENCENUMBER]: undefinedOperation,
      [OpcodesBCH2022.OP_OUTPUTVALUE]: undefinedOperation,
      [OpcodesBCH2022.OP_OUTPUTBYTECODE]: undefinedOperation
    }
  };
};

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/xec/xec-opcodes.js
var import_dist244 = __toESM(require_dist(), 1);
var import_dist245 = __toESM(require_dist2(), 1);
var import_dist246 = __toESM(require_dist3(), 1);
var OpcodesXEC;
(function(OpcodesXEC2) {
  OpcodesXEC2[OpcodesXEC2["OP_0"] = 0] = "OP_0";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_1"] = 1] = "OP_PUSHBYTES_1";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_2"] = 2] = "OP_PUSHBYTES_2";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_3"] = 3] = "OP_PUSHBYTES_3";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_4"] = 4] = "OP_PUSHBYTES_4";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_5"] = 5] = "OP_PUSHBYTES_5";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_6"] = 6] = "OP_PUSHBYTES_6";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_7"] = 7] = "OP_PUSHBYTES_7";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_8"] = 8] = "OP_PUSHBYTES_8";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_9"] = 9] = "OP_PUSHBYTES_9";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_10"] = 10] = "OP_PUSHBYTES_10";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_11"] = 11] = "OP_PUSHBYTES_11";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_12"] = 12] = "OP_PUSHBYTES_12";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_13"] = 13] = "OP_PUSHBYTES_13";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_14"] = 14] = "OP_PUSHBYTES_14";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_15"] = 15] = "OP_PUSHBYTES_15";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_16"] = 16] = "OP_PUSHBYTES_16";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_17"] = 17] = "OP_PUSHBYTES_17";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_18"] = 18] = "OP_PUSHBYTES_18";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_19"] = 19] = "OP_PUSHBYTES_19";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_20"] = 20] = "OP_PUSHBYTES_20";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_21"] = 21] = "OP_PUSHBYTES_21";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_22"] = 22] = "OP_PUSHBYTES_22";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_23"] = 23] = "OP_PUSHBYTES_23";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_24"] = 24] = "OP_PUSHBYTES_24";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_25"] = 25] = "OP_PUSHBYTES_25";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_26"] = 26] = "OP_PUSHBYTES_26";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_27"] = 27] = "OP_PUSHBYTES_27";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_28"] = 28] = "OP_PUSHBYTES_28";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_29"] = 29] = "OP_PUSHBYTES_29";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_30"] = 30] = "OP_PUSHBYTES_30";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_31"] = 31] = "OP_PUSHBYTES_31";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_32"] = 32] = "OP_PUSHBYTES_32";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_33"] = 33] = "OP_PUSHBYTES_33";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_34"] = 34] = "OP_PUSHBYTES_34";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_35"] = 35] = "OP_PUSHBYTES_35";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_36"] = 36] = "OP_PUSHBYTES_36";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_37"] = 37] = "OP_PUSHBYTES_37";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_38"] = 38] = "OP_PUSHBYTES_38";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_39"] = 39] = "OP_PUSHBYTES_39";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_40"] = 40] = "OP_PUSHBYTES_40";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_41"] = 41] = "OP_PUSHBYTES_41";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_42"] = 42] = "OP_PUSHBYTES_42";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_43"] = 43] = "OP_PUSHBYTES_43";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_44"] = 44] = "OP_PUSHBYTES_44";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_45"] = 45] = "OP_PUSHBYTES_45";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_46"] = 46] = "OP_PUSHBYTES_46";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_47"] = 47] = "OP_PUSHBYTES_47";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_48"] = 48] = "OP_PUSHBYTES_48";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_49"] = 49] = "OP_PUSHBYTES_49";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_50"] = 50] = "OP_PUSHBYTES_50";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_51"] = 51] = "OP_PUSHBYTES_51";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_52"] = 52] = "OP_PUSHBYTES_52";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_53"] = 53] = "OP_PUSHBYTES_53";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_54"] = 54] = "OP_PUSHBYTES_54";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_55"] = 55] = "OP_PUSHBYTES_55";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_56"] = 56] = "OP_PUSHBYTES_56";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_57"] = 57] = "OP_PUSHBYTES_57";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_58"] = 58] = "OP_PUSHBYTES_58";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_59"] = 59] = "OP_PUSHBYTES_59";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_60"] = 60] = "OP_PUSHBYTES_60";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_61"] = 61] = "OP_PUSHBYTES_61";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_62"] = 62] = "OP_PUSHBYTES_62";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_63"] = 63] = "OP_PUSHBYTES_63";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_64"] = 64] = "OP_PUSHBYTES_64";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_65"] = 65] = "OP_PUSHBYTES_65";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_66"] = 66] = "OP_PUSHBYTES_66";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_67"] = 67] = "OP_PUSHBYTES_67";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_68"] = 68] = "OP_PUSHBYTES_68";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_69"] = 69] = "OP_PUSHBYTES_69";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_70"] = 70] = "OP_PUSHBYTES_70";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_71"] = 71] = "OP_PUSHBYTES_71";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_72"] = 72] = "OP_PUSHBYTES_72";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_73"] = 73] = "OP_PUSHBYTES_73";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_74"] = 74] = "OP_PUSHBYTES_74";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHBYTES_75"] = 75] = "OP_PUSHBYTES_75";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHDATA_1"] = 76] = "OP_PUSHDATA_1";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHDATA_2"] = 77] = "OP_PUSHDATA_2";
  OpcodesXEC2[OpcodesXEC2["OP_PUSHDATA_4"] = 78] = "OP_PUSHDATA_4";
  OpcodesXEC2[OpcodesXEC2["OP_1NEGATE"] = 79] = "OP_1NEGATE";
  OpcodesXEC2[OpcodesXEC2["OP_RESERVED"] = 80] = "OP_RESERVED";
  OpcodesXEC2[OpcodesXEC2["OP_1"] = 81] = "OP_1";
  OpcodesXEC2[OpcodesXEC2["OP_2"] = 82] = "OP_2";
  OpcodesXEC2[OpcodesXEC2["OP_3"] = 83] = "OP_3";
  OpcodesXEC2[OpcodesXEC2["OP_4"] = 84] = "OP_4";
  OpcodesXEC2[OpcodesXEC2["OP_5"] = 85] = "OP_5";
  OpcodesXEC2[OpcodesXEC2["OP_6"] = 86] = "OP_6";
  OpcodesXEC2[OpcodesXEC2["OP_7"] = 87] = "OP_7";
  OpcodesXEC2[OpcodesXEC2["OP_8"] = 88] = "OP_8";
  OpcodesXEC2[OpcodesXEC2["OP_9"] = 89] = "OP_9";
  OpcodesXEC2[OpcodesXEC2["OP_10"] = 90] = "OP_10";
  OpcodesXEC2[OpcodesXEC2["OP_11"] = 91] = "OP_11";
  OpcodesXEC2[OpcodesXEC2["OP_12"] = 92] = "OP_12";
  OpcodesXEC2[OpcodesXEC2["OP_13"] = 93] = "OP_13";
  OpcodesXEC2[OpcodesXEC2["OP_14"] = 94] = "OP_14";
  OpcodesXEC2[OpcodesXEC2["OP_15"] = 95] = "OP_15";
  OpcodesXEC2[OpcodesXEC2["OP_16"] = 96] = "OP_16";
  OpcodesXEC2[OpcodesXEC2["OP_NOP"] = 97] = "OP_NOP";
  OpcodesXEC2[OpcodesXEC2["OP_VER"] = 98] = "OP_VER";
  OpcodesXEC2[OpcodesXEC2["OP_IF"] = 99] = "OP_IF";
  OpcodesXEC2[OpcodesXEC2["OP_NOTIF"] = 100] = "OP_NOTIF";
  OpcodesXEC2[OpcodesXEC2["OP_VERIF"] = 101] = "OP_VERIF";
  OpcodesXEC2[OpcodesXEC2["OP_VERNOTIF"] = 102] = "OP_VERNOTIF";
  OpcodesXEC2[OpcodesXEC2["OP_ELSE"] = 103] = "OP_ELSE";
  OpcodesXEC2[OpcodesXEC2["OP_ENDIF"] = 104] = "OP_ENDIF";
  OpcodesXEC2[OpcodesXEC2["OP_VERIFY"] = 105] = "OP_VERIFY";
  OpcodesXEC2[OpcodesXEC2["OP_RETURN"] = 106] = "OP_RETURN";
  OpcodesXEC2[OpcodesXEC2["OP_TOALTSTACK"] = 107] = "OP_TOALTSTACK";
  OpcodesXEC2[OpcodesXEC2["OP_FROMALTSTACK"] = 108] = "OP_FROMALTSTACK";
  OpcodesXEC2[OpcodesXEC2["OP_2DROP"] = 109] = "OP_2DROP";
  OpcodesXEC2[OpcodesXEC2["OP_2DUP"] = 110] = "OP_2DUP";
  OpcodesXEC2[OpcodesXEC2["OP_3DUP"] = 111] = "OP_3DUP";
  OpcodesXEC2[OpcodesXEC2["OP_2OVER"] = 112] = "OP_2OVER";
  OpcodesXEC2[OpcodesXEC2["OP_2ROT"] = 113] = "OP_2ROT";
  OpcodesXEC2[OpcodesXEC2["OP_2SWAP"] = 114] = "OP_2SWAP";
  OpcodesXEC2[OpcodesXEC2["OP_IFDUP"] = 115] = "OP_IFDUP";
  OpcodesXEC2[OpcodesXEC2["OP_DEPTH"] = 116] = "OP_DEPTH";
  OpcodesXEC2[OpcodesXEC2["OP_DROP"] = 117] = "OP_DROP";
  OpcodesXEC2[OpcodesXEC2["OP_DUP"] = 118] = "OP_DUP";
  OpcodesXEC2[OpcodesXEC2["OP_NIP"] = 119] = "OP_NIP";
  OpcodesXEC2[OpcodesXEC2["OP_OVER"] = 120] = "OP_OVER";
  OpcodesXEC2[OpcodesXEC2["OP_PICK"] = 121] = "OP_PICK";
  OpcodesXEC2[OpcodesXEC2["OP_ROLL"] = 122] = "OP_ROLL";
  OpcodesXEC2[OpcodesXEC2["OP_ROT"] = 123] = "OP_ROT";
  OpcodesXEC2[OpcodesXEC2["OP_SWAP"] = 124] = "OP_SWAP";
  OpcodesXEC2[OpcodesXEC2["OP_TUCK"] = 125] = "OP_TUCK";
  OpcodesXEC2[OpcodesXEC2["OP_CAT"] = 126] = "OP_CAT";
  OpcodesXEC2[OpcodesXEC2["OP_SPLIT"] = 127] = "OP_SPLIT";
  OpcodesXEC2[OpcodesXEC2["OP_NUM2BIN"] = 128] = "OP_NUM2BIN";
  OpcodesXEC2[OpcodesXEC2["OP_BIN2NUM"] = 129] = "OP_BIN2NUM";
  OpcodesXEC2[OpcodesXEC2["OP_SIZE"] = 130] = "OP_SIZE";
  OpcodesXEC2[OpcodesXEC2["OP_INVERT"] = 131] = "OP_INVERT";
  OpcodesXEC2[OpcodesXEC2["OP_AND"] = 132] = "OP_AND";
  OpcodesXEC2[OpcodesXEC2["OP_OR"] = 133] = "OP_OR";
  OpcodesXEC2[OpcodesXEC2["OP_XOR"] = 134] = "OP_XOR";
  OpcodesXEC2[OpcodesXEC2["OP_EQUAL"] = 135] = "OP_EQUAL";
  OpcodesXEC2[OpcodesXEC2["OP_EQUALVERIFY"] = 136] = "OP_EQUALVERIFY";
  OpcodesXEC2[OpcodesXEC2["OP_RESERVED1"] = 137] = "OP_RESERVED1";
  OpcodesXEC2[OpcodesXEC2["OP_RESERVED2"] = 138] = "OP_RESERVED2";
  OpcodesXEC2[OpcodesXEC2["OP_1ADD"] = 139] = "OP_1ADD";
  OpcodesXEC2[OpcodesXEC2["OP_1SUB"] = 140] = "OP_1SUB";
  OpcodesXEC2[OpcodesXEC2["OP_2MUL"] = 141] = "OP_2MUL";
  OpcodesXEC2[OpcodesXEC2["OP_2DIV"] = 142] = "OP_2DIV";
  OpcodesXEC2[OpcodesXEC2["OP_NEGATE"] = 143] = "OP_NEGATE";
  OpcodesXEC2[OpcodesXEC2["OP_ABS"] = 144] = "OP_ABS";
  OpcodesXEC2[OpcodesXEC2["OP_NOT"] = 145] = "OP_NOT";
  OpcodesXEC2[OpcodesXEC2["OP_0NOTEQUAL"] = 146] = "OP_0NOTEQUAL";
  OpcodesXEC2[OpcodesXEC2["OP_ADD"] = 147] = "OP_ADD";
  OpcodesXEC2[OpcodesXEC2["OP_SUB"] = 148] = "OP_SUB";
  OpcodesXEC2[OpcodesXEC2["OP_MUL"] = 149] = "OP_MUL";
  OpcodesXEC2[OpcodesXEC2["OP_DIV"] = 150] = "OP_DIV";
  OpcodesXEC2[OpcodesXEC2["OP_MOD"] = 151] = "OP_MOD";
  OpcodesXEC2[OpcodesXEC2["OP_LSHIFT"] = 152] = "OP_LSHIFT";
  OpcodesXEC2[OpcodesXEC2["OP_RSHIFT"] = 153] = "OP_RSHIFT";
  OpcodesXEC2[OpcodesXEC2["OP_BOOLAND"] = 154] = "OP_BOOLAND";
  OpcodesXEC2[OpcodesXEC2["OP_BOOLOR"] = 155] = "OP_BOOLOR";
  OpcodesXEC2[OpcodesXEC2["OP_NUMEQUAL"] = 156] = "OP_NUMEQUAL";
  OpcodesXEC2[OpcodesXEC2["OP_NUMEQUALVERIFY"] = 157] = "OP_NUMEQUALVERIFY";
  OpcodesXEC2[OpcodesXEC2["OP_NUMNOTEQUAL"] = 158] = "OP_NUMNOTEQUAL";
  OpcodesXEC2[OpcodesXEC2["OP_LESSTHAN"] = 159] = "OP_LESSTHAN";
  OpcodesXEC2[OpcodesXEC2["OP_GREATERTHAN"] = 160] = "OP_GREATERTHAN";
  OpcodesXEC2[OpcodesXEC2["OP_LESSTHANOREQUAL"] = 161] = "OP_LESSTHANOREQUAL";
  OpcodesXEC2[OpcodesXEC2["OP_GREATERTHANOREQUAL"] = 162] = "OP_GREATERTHANOREQUAL";
  OpcodesXEC2[OpcodesXEC2["OP_MIN"] = 163] = "OP_MIN";
  OpcodesXEC2[OpcodesXEC2["OP_MAX"] = 164] = "OP_MAX";
  OpcodesXEC2[OpcodesXEC2["OP_WITHIN"] = 165] = "OP_WITHIN";
  OpcodesXEC2[OpcodesXEC2["OP_RIPEMD160"] = 166] = "OP_RIPEMD160";
  OpcodesXEC2[OpcodesXEC2["OP_SHA1"] = 167] = "OP_SHA1";
  OpcodesXEC2[OpcodesXEC2["OP_SHA256"] = 168] = "OP_SHA256";
  OpcodesXEC2[OpcodesXEC2["OP_HASH160"] = 169] = "OP_HASH160";
  OpcodesXEC2[OpcodesXEC2["OP_HASH256"] = 170] = "OP_HASH256";
  OpcodesXEC2[OpcodesXEC2["OP_CODESEPARATOR"] = 171] = "OP_CODESEPARATOR";
  OpcodesXEC2[OpcodesXEC2["OP_CHECKSIG"] = 172] = "OP_CHECKSIG";
  OpcodesXEC2[OpcodesXEC2["OP_CHECKSIGVERIFY"] = 173] = "OP_CHECKSIGVERIFY";
  OpcodesXEC2[OpcodesXEC2["OP_CHECKMULTISIG"] = 174] = "OP_CHECKMULTISIG";
  OpcodesXEC2[OpcodesXEC2["OP_CHECKMULTISIGVERIFY"] = 175] = "OP_CHECKMULTISIGVERIFY";
  OpcodesXEC2[OpcodesXEC2["OP_NOP1"] = 176] = "OP_NOP1";
  OpcodesXEC2[OpcodesXEC2["OP_CHECKLOCKTIMEVERIFY"] = 177] = "OP_CHECKLOCKTIMEVERIFY";
  OpcodesXEC2[OpcodesXEC2["OP_CHECKSEQUENCEVERIFY"] = 178] = "OP_CHECKSEQUENCEVERIFY";
  OpcodesXEC2[OpcodesXEC2["OP_NOP4"] = 179] = "OP_NOP4";
  OpcodesXEC2[OpcodesXEC2["OP_NOP5"] = 180] = "OP_NOP5";
  OpcodesXEC2[OpcodesXEC2["OP_NOP6"] = 181] = "OP_NOP6";
  OpcodesXEC2[OpcodesXEC2["OP_NOP7"] = 182] = "OP_NOP7";
  OpcodesXEC2[OpcodesXEC2["OP_NOP8"] = 183] = "OP_NOP8";
  OpcodesXEC2[OpcodesXEC2["OP_NOP9"] = 184] = "OP_NOP9";
  OpcodesXEC2[OpcodesXEC2["OP_NOP10"] = 185] = "OP_NOP10";
  OpcodesXEC2[OpcodesXEC2["OP_CHECKDATASIG"] = 186] = "OP_CHECKDATASIG";
  OpcodesXEC2[OpcodesXEC2["OP_CHECKDATASIGVERIFY"] = 187] = "OP_CHECKDATASIGVERIFY";
  OpcodesXEC2[OpcodesXEC2["OP_REVERSEBYTES"] = 188] = "OP_REVERSEBYTES";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN189"] = 189] = "OP_UNKNOWN189";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN190"] = 190] = "OP_UNKNOWN190";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN191"] = 191] = "OP_UNKNOWN191";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN192"] = 192] = "OP_UNKNOWN192";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN193"] = 193] = "OP_UNKNOWN193";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN194"] = 194] = "OP_UNKNOWN194";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN195"] = 195] = "OP_UNKNOWN195";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN196"] = 196] = "OP_UNKNOWN196";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN197"] = 197] = "OP_UNKNOWN197";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN198"] = 198] = "OP_UNKNOWN198";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN199"] = 199] = "OP_UNKNOWN199";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN200"] = 200] = "OP_UNKNOWN200";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN201"] = 201] = "OP_UNKNOWN201";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN202"] = 202] = "OP_UNKNOWN202";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN203"] = 203] = "OP_UNKNOWN203";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN204"] = 204] = "OP_UNKNOWN204";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN205"] = 205] = "OP_UNKNOWN205";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN206"] = 206] = "OP_UNKNOWN206";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN207"] = 207] = "OP_UNKNOWN207";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN208"] = 208] = "OP_UNKNOWN208";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN209"] = 209] = "OP_UNKNOWN209";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN210"] = 210] = "OP_UNKNOWN210";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN211"] = 211] = "OP_UNKNOWN211";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN212"] = 212] = "OP_UNKNOWN212";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN213"] = 213] = "OP_UNKNOWN213";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN214"] = 214] = "OP_UNKNOWN214";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN215"] = 215] = "OP_UNKNOWN215";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN216"] = 216] = "OP_UNKNOWN216";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN217"] = 217] = "OP_UNKNOWN217";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN218"] = 218] = "OP_UNKNOWN218";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN219"] = 219] = "OP_UNKNOWN219";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN220"] = 220] = "OP_UNKNOWN220";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN221"] = 221] = "OP_UNKNOWN221";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN222"] = 222] = "OP_UNKNOWN222";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN223"] = 223] = "OP_UNKNOWN223";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN224"] = 224] = "OP_UNKNOWN224";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN225"] = 225] = "OP_UNKNOWN225";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN226"] = 226] = "OP_UNKNOWN226";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN227"] = 227] = "OP_UNKNOWN227";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN228"] = 228] = "OP_UNKNOWN228";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN229"] = 229] = "OP_UNKNOWN229";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN230"] = 230] = "OP_UNKNOWN230";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN231"] = 231] = "OP_UNKNOWN231";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN232"] = 232] = "OP_UNKNOWN232";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN233"] = 233] = "OP_UNKNOWN233";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN234"] = 234] = "OP_UNKNOWN234";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN235"] = 235] = "OP_UNKNOWN235";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN236"] = 236] = "OP_UNKNOWN236";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN237"] = 237] = "OP_UNKNOWN237";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN238"] = 238] = "OP_UNKNOWN238";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN239"] = 239] = "OP_UNKNOWN239";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN240"] = 240] = "OP_UNKNOWN240";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN241"] = 241] = "OP_UNKNOWN241";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN242"] = 242] = "OP_UNKNOWN242";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN243"] = 243] = "OP_UNKNOWN243";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN244"] = 244] = "OP_UNKNOWN244";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN245"] = 245] = "OP_UNKNOWN245";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN246"] = 246] = "OP_UNKNOWN246";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN247"] = 247] = "OP_UNKNOWN247";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN248"] = 248] = "OP_UNKNOWN248";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN249"] = 249] = "OP_UNKNOWN249";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN250"] = 250] = "OP_UNKNOWN250";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN251"] = 251] = "OP_UNKNOWN251";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN252"] = 252] = "OP_UNKNOWN252";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN253"] = 253] = "OP_UNKNOWN253";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN254"] = 254] = "OP_UNKNOWN254";
  OpcodesXEC2[OpcodesXEC2["OP_UNKNOWN255"] = 255] = "OP_UNKNOWN255";
})(OpcodesXEC || (OpcodesXEC = {}));

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/xec/xec-vm.js
var import_dist247 = __toESM(require_dist(), 1);
var import_dist248 = __toESM(require_dist2(), 1);
var import_dist249 = __toESM(require_dist3(), 1);
var createVirtualMachineXEC = (standard = true) => createAuthenticationVirtualMachine(createInstructionSetXEC(standard));

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/xec/fixtures/satoshi-client/bitcoin-satoshi-utils.js
var import_dist250 = __toESM(require_dist(), 1);
var import_dist251 = __toESM(require_dist2(), 1);
var import_dist252 = __toESM(require_dist3(), 1);
var bitcoinSatoshiOpcodes = Object.entries(generateBytecodeMap(OpcodesXEC)).reduce((acc, cur) => ({ ...acc, [cur[0].slice("OP_".length)]: cur[1] }), {
  PUSHDATA1: Uint8Array.of(OpcodesXEC.OP_PUSHDATA_1),
  PUSHDATA2: Uint8Array.of(OpcodesXEC.OP_PUSHDATA_2),
  PUSHDATA4: Uint8Array.of(OpcodesXEC.OP_PUSHDATA_4)
  // eslint-disable-line @typescript-eslint/naming-convention
});
var assembleBitcoinSatoshiScript = (satoshiScript) => flattenBinArray(satoshiScript.split(" ").filter((token) => token !== "").map((token) => token.startsWith("0x") ? hexToBin(token.slice("0x".length)) : token.startsWith("'") ? encodeDataPush(utf8ToBin(token.slice(1, token.length - 1))) : bitcoinSatoshiOpcodes[token] === void 0 ? encodeDataPush(bigIntToVmNumber(BigInt(token))) : bitcoinSatoshiOpcodes[token]));

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/bch/2022/bch-2022.js
var import_dist268 = __toESM(require_dist(), 1);
var import_dist269 = __toESM(require_dist2(), 1);
var import_dist270 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/bch/2022/bch-2022-descriptions.js
var import_dist256 = __toESM(require_dist(), 1);
var import_dist257 = __toESM(require_dist2(), 1);
var import_dist258 = __toESM(require_dist3(), 1);
var OpcodeDescriptionsBCH2022;
(function(OpcodeDescriptionsBCH20222) {
  OpcodeDescriptionsBCH20222["OP_0"] = "Push the VM Number 0 onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_1"] = "Push the next byte onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_2"] = "Push the next 2 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_3"] = "Push the next 3 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_4"] = "Push the next 4 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_5"] = "Push the next 5 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_6"] = "Push the next 6 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_7"] = "Push the next 7 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_8"] = "Push the next 8 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_9"] = "Push the next 9 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_10"] = "Push the next 10 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_11"] = "Push the next 11 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_12"] = "Push the next 12 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_13"] = "Push the next 13 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_14"] = "Push the next 14 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_15"] = "Push the next 15 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_16"] = "Push the next 16 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_17"] = "Push the next 17 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_18"] = "Push the next 18 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_19"] = "Push the next 19 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_20"] = "Push the next 20 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_21"] = "Push the next 21 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_22"] = "Push the next 22 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_23"] = "Push the next 23 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_24"] = "Push the next 24 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_25"] = "Push the next 25 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_26"] = "Push the next 26 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_27"] = "Push the next 27 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_28"] = "Push the next 28 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_29"] = "Push the next 29 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_30"] = "Push the next 30 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_31"] = "Push the next 31 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_32"] = "Push the next 32 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_33"] = "Push the next 33 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_34"] = "Push the next 34 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_35"] = "Push the next 35 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_36"] = "Push the next 36 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_37"] = "Push the next 37 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_38"] = "Push the next 38 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_39"] = "Push the next 39 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_40"] = "Push the next 40 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_41"] = "Push the next 41 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_42"] = "Push the next 42 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_43"] = "Push the next 43 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_44"] = "Push the next 44 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_45"] = "Push the next 45 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_46"] = "Push the next 46 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_47"] = "Push the next 47 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_48"] = "Push the next 48 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_49"] = "Push the next 49 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_50"] = "Push the next 50 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_51"] = "Push the next 51 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_52"] = "Push the next 52 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_53"] = "Push the next 53 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_54"] = "Push the next 54 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_55"] = "Push the next 55 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_56"] = "Push the next 56 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_57"] = "Push the next 57 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_58"] = "Push the next 58 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_59"] = "Push the next 59 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_60"] = "Push the next 60 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_61"] = "Push the next 61 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_62"] = "Push the next 62 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_63"] = "Push the next 63 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_64"] = "Push the next 64 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_65"] = "Push the next 65 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_66"] = "Push the next 66 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_67"] = "Push the next 67 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_68"] = "Push the next 68 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_69"] = "Push the next 69 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_70"] = "Push the next 70 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_71"] = "Push the next 71 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_72"] = "Push the next 72 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_73"] = "Push the next 73 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_74"] = "Push the next 74 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHBYTES_75"] = "Push the next 75 bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHDATA_1"] = "Read the next Uint8 and push that number of bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHDATA_2"] = "Read the next little-endian Uint16 and push that number of bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_PUSHDATA_4"] = "Read the next little-endian Uint32 and push that number of bytes onto the stack.";
  OpcodeDescriptionsBCH20222["OP_1NEGATE"] = "Push the VM Number -1 onto the stack.";
  OpcodeDescriptionsBCH20222["OP_RESERVED"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED does not count toward the opcode limit.";
  OpcodeDescriptionsBCH20222["OP_1"] = "Push a 1 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH20222["OP_2"] = "Push a 2 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH20222["OP_3"] = "Push a 3 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH20222["OP_4"] = "Push a 4 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH20222["OP_5"] = "Push a 5 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH20222["OP_6"] = "Push a 6 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH20222["OP_7"] = "Push a 7 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH20222["OP_8"] = "Push a 8 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH20222["OP_9"] = "Push a 9 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH20222["OP_10"] = "Push a 10 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH20222["OP_11"] = "Push a 11 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH20222["OP_12"] = "Push a 12 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH20222["OP_13"] = "Push a 13 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH20222["OP_14"] = "Push a 14 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH20222["OP_15"] = "Push a 15 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH20222["OP_16"] = "Push a 16 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH20222["OP_NOP"] = "No operation. Note: OP_NOP counts toward the opcode limit.";
  OpcodeDescriptionsBCH20222["OP_VER"] = "Error unless found in an unexecuted conditional branch. Note: OP_VER counts toward the opcode limit. (Historically, this pushed a protocol version number to the stack.)";
  OpcodeDescriptionsBCH20222["OP_IF"] = 'Pop the top item from the stack. If it is not "truthy", skip evaluation until a matching OP_ELSE or OP_ENDIF.';
  OpcodeDescriptionsBCH20222["OP_NOTIF"] = 'Pop the top item from the stack. If it is "truthy", skip evaluation until a matching OP_ELSE or OP_ENDIF.';
  OpcodeDescriptionsBCH20222["OP_VERIF"] = "Error, even when found in an unexecuted conditional branch. (Historically, this was a combination of OP_VER and OP_IF.)";
  OpcodeDescriptionsBCH20222["OP_VERNOTIF"] = "Error, even when found in an unexecuted conditional branch. (Historically, this was a combination of OP_VER and OP_NOTIF.)";
  OpcodeDescriptionsBCH20222["OP_ELSE"] = "Invert conditional evaluation within the current OP_IF ... OP_ENDIF block. (If evaluation is enabled, disable it, if it is disabled, enable it.)";
  OpcodeDescriptionsBCH20222["OP_ENDIF"] = "End the current OP_IF/OP_NOTIF ... OP_ENDIF block.";
  OpcodeDescriptionsBCH20222["OP_VERIFY"] = `Pop the top item from the stack and error if it isn't "truthy".`;
  OpcodeDescriptionsBCH20222["OP_RETURN"] = "Error when executed.";
  OpcodeDescriptionsBCH20222["OP_TOALTSTACK"] = "Pop the top item from the stack and push it onto the alternate stack.";
  OpcodeDescriptionsBCH20222["OP_FROMALTSTACK"] = "Pop the top item from the alternate stack and push it onto the stack.";
  OpcodeDescriptionsBCH20222["OP_2DROP"] = "Pop the top 2 items from the stack and discard them.";
  OpcodeDescriptionsBCH20222["OP_2DUP"] = "Duplicate the top 2 items on the stack. (E.g. [a, b] -> [a, b, a, b])";
  OpcodeDescriptionsBCH20222["OP_3DUP"] = "Duplicate the top 3 items on the stack. (E.g. [a, b, c] -> [a, b, c, a, b, c])";
  OpcodeDescriptionsBCH20222["OP_2OVER"] = "Duplicate the 2 items beginning at a depth of 2 on the stack. (E.g. [a, b, c, d] -> [a, b, c, d, a, b])";
  OpcodeDescriptionsBCH20222["OP_2ROT"] = "Rotate the top 6 items on the stack, bringing the fifth and sixth items to the top. (E.g. [a, b, c, d, e, f] -> [c, d, e, f, a, b])";
  OpcodeDescriptionsBCH20222["OP_2SWAP"] = "Swap the positions of the top two pairs of items on the stack. (E.g. [a, b, c, d] -> [c, d, a, b])";
  OpcodeDescriptionsBCH20222["OP_IFDUP"] = 'If the top item on the stack is "truthy", duplicate it.';
  OpcodeDescriptionsBCH20222["OP_DEPTH"] = "Push the current number of stack items as a VM Number.";
  OpcodeDescriptionsBCH20222["OP_DROP"] = "Pop the top item from the stack and discard it. (E.g. [a] -> [])";
  OpcodeDescriptionsBCH20222["OP_DUP"] = "Duplicate the top item on the stack. (E.g. [a] -> [a, a])";
  OpcodeDescriptionsBCH20222["OP_NIP"] = "Remove the second-to-top item from the stack. (E.g. [a, b] -> [b])";
  OpcodeDescriptionsBCH20222["OP_OVER"] = "Duplicate the second-to-top item on the stack. (E.g. [a, b] -> [a, b, a])";
  OpcodeDescriptionsBCH20222["OP_PICK"] = "Pop the top item from the stack as a VM Number. Duplicate the item at that depth (zero-indexed), placing it on top of the stack. (E.g. [a, b, c, 2] -> [a, b, c, a])";
  OpcodeDescriptionsBCH20222["OP_ROLL"] = "Pop the top item from the stack as a VM Number. Move the item at that depth (zero-indexed) to the top of the stack. (E.g. [a, b, c, 2] -> [b, c, a])";
  OpcodeDescriptionsBCH20222["OP_ROT"] = "Rotate the top 3 items on the stack, bringing the third item to the top. (E.g. [a, b, c] -> [b, c, a])";
  OpcodeDescriptionsBCH20222["OP_SWAP"] = "Swap the top two items on the stack. (E.g. [a, b] -> [b, a])";
  OpcodeDescriptionsBCH20222["OP_TUCK"] = "Duplicate the item at the top of the stack, inserting it below the second-to-top item. (E.g. [a, b] -> [b, a, b])";
  OpcodeDescriptionsBCH20222["OP_CAT"] = "Pop the top 2 items from the stack and concatenate them, pushing the result.";
  OpcodeDescriptionsBCH20222["OP_SPLIT"] = "Pop the top item from the stack as an index (VM Number) and the next item as a byte array. Split the byte array into two stack items at the index (zero-based), pushing the results.";
  OpcodeDescriptionsBCH20222["OP_NUM2BIN"] = "Pop the top item from the stack as an item length (VM Number) and the next item as a VM Number (without encoding restrictions). Re-encode the number using a byte array of the provided length, filling any unused bytes with zeros, then push the result. (If the requested length is too short to encode the number, error.)";
  OpcodeDescriptionsBCH20222["OP_BIN2NUM"] = "Pop the top item from the stack as a VM Number without encoding restrictions. Minimally-encode the number and push the result. (If the number can't be encoded in 4 bytes or less, error.)";
  OpcodeDescriptionsBCH20222["OP_SIZE"] = "Push the byte-length of the top stack item as a VM Number.";
  OpcodeDescriptionsBCH20222["OP_INVERT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this flipped all the bits in a stack item.)";
  OpcodeDescriptionsBCH20222["OP_AND"] = "Pop the top 2 items from the stack and perform a bitwise AND on each byte, pushing the result. If the length of the items are not equal, error.";
  OpcodeDescriptionsBCH20222["OP_OR"] = "Pop the top 2 items from the stack and perform a bitwise OR on each byte, pushing the result. If the length of the items are not equal, error.";
  OpcodeDescriptionsBCH20222["OP_XOR"] = "Pop the top 2 items from the stack and perform a bitwise XOR on each byte, pushing the result. If the length of the items are not equal, error.";
  OpcodeDescriptionsBCH20222["OP_EQUAL"] = "Pop the top two items from the stack and compare them byte-by-byte. If they are the same, push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsBCH20222["OP_EQUALVERIFY"] = "Pop the top two items from the stack and compare them byte-by-byte. If the values are different, error. (This operation is a combination of OP_EQUAL followed by OP_VERIFY.)";
  OpcodeDescriptionsBCH20222["OP_RESERVED1"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED1 counts toward the opcode limit.";
  OpcodeDescriptionsBCH20222["OP_RESERVED2"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED2 counts toward the opcode limit.";
  OpcodeDescriptionsBCH20222["OP_1ADD"] = "Pop the top item from the stack as a VM Number, add 1, then push the result.";
  OpcodeDescriptionsBCH20222["OP_1SUB"] = "Pop the top item from the stack as a VM Number, subtract 1, then push the result.";
  OpcodeDescriptionsBCH20222["OP_2MUL"] = "Error, even when found in an unexecuted conditional branch. (Historically, this multiplied a VM Number by 2.)";
  OpcodeDescriptionsBCH20222["OP_2DIV"] = "Error, even when found in an unexecuted conditional branch. (Historically, this divided a VM Number by 2.)";
  OpcodeDescriptionsBCH20222["OP_NEGATE"] = "Pop the top item from the stack as a VM Number, negate it, then push the result.";
  OpcodeDescriptionsBCH20222["OP_ABS"] = "Pop the top item from the stack as a VM Number, take its absolute value, then push the result.";
  OpcodeDescriptionsBCH20222["OP_NOT"] = "Pop the top item from the stack as a VM Number. If its value is 0, push a 1 (VM Number), otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH20222["OP_0NOTEQUAL"] = "Pop the top item from the stack as a VM Number. If its value is not 0, push a 1 (VM Number), otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH20222["OP_ADD"] = "Pop the top two items from the stack as VM Numbers. Add them, then push the result.";
  OpcodeDescriptionsBCH20222["OP_SUB"] = "Pop the top two items from the stack as VM Numbers. Subtract the top item from the second item, then push the result.";
  OpcodeDescriptionsBCH20222["OP_MUL"] = "Pop the top two items from the stack as VM Numbers. Multiply them, then push the result.";
  OpcodeDescriptionsBCH20222["OP_DIV"] = "Pop the top item from the stack as a denominator (VM Number) and the next as a numerator (VM Number). Divide and push the result to the stack.";
  OpcodeDescriptionsBCH20222["OP_MOD"] = "Pop the top item from the stack as a denominator (VM Number) and the next as a numerator (VM Number). Divide and push the remainder to the stack.";
  OpcodeDescriptionsBCH20222["OP_LSHIFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a sign-preserving, left bit shift.)";
  OpcodeDescriptionsBCH20222["OP_RSHIFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a sign-preserving, right bit shift.)";
  OpcodeDescriptionsBCH20222["OP_BOOLAND"] = "Pop the top two items from the stack as VM Numbers. If neither value is a 0 (VM Number), push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH20222["OP_BOOLOR"] = "Pop the top two items from the stack as VM Numbers. If either value is a 1 (VM Number), push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH20222["OP_NUMEQUAL"] = "Pop the top two items from the stack as VM Numbers. If the values are equal, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH20222["OP_NUMEQUALVERIFY"] = "Pop the top two items from the stack as VM Numbers. If the values are different, error. (This operation is a combination of OP_NUMEQUAL followed by OP_VERIFY.)";
  OpcodeDescriptionsBCH20222["OP_NUMNOTEQUAL"] = "Pop the top two items from the stack as VM Numbers. If the values are not equal, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH20222["OP_LESSTHAN"] = "Pop the top two items from the stack as VM Numbers. If the second item is less than top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH20222["OP_GREATERTHAN"] = "Pop the top two items from the stack as VM Numbers. If the second item is greater than top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH20222["OP_LESSTHANOREQUAL"] = "Pop the top two items from the stack as VM Numbers. If the second item is less than or equal to the top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH20222["OP_GREATERTHANOREQUAL"] = "Pop the top two items from the stack as VM Numbers. If the second item is greater than or equal to the top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH20222["OP_MIN"] = "Pop the top two items from the stack as VM Numbers. Push the smaller of the two numbers.";
  OpcodeDescriptionsBCH20222["OP_MAX"] = "Pop the top two items from the stack as VM Numbers. Push the larger of the two numbers.";
  OpcodeDescriptionsBCH20222["OP_WITHIN"] = "Pop the top three items from the stack as VM Numbers. If the top number is within the range defined by the following two numbers (left-inclusive), push a 1 (VM Number). Otherwise, push a 0 (VM Number). (E.g. for [a, b, c]: if (b <= a), and (a < c), [1]. Else [0].)";
  OpcodeDescriptionsBCH20222["OP_RIPEMD160"] = "Pop the top item from the stack and pass it through ripemd160, pushing the result onto the stack.";
  OpcodeDescriptionsBCH20222["OP_SHA1"] = "Pop the top item from the stack and pass it through sha1, pushing the result onto the stack.";
  OpcodeDescriptionsBCH20222["OP_SHA256"] = "Pop the top item from the stack and pass it through sha256, pushing the result onto the stack.";
  OpcodeDescriptionsBCH20222["OP_HASH160"] = "Pop the top item from the stack and pass it through sha256, then ripemd160, pushing the result onto the stack.";
  OpcodeDescriptionsBCH20222["OP_HASH256"] = "Pop the top item from the stack and pass it through sha256 twice, pushing the result onto the stack.";
  OpcodeDescriptionsBCH20222["OP_CODESEPARATOR"] = "Update the value of lastCodeSeparator to the instruction pointer's current value. (This reduces the coverage of signing serializations used in signature verification operations.)";
  OpcodeDescriptionsBCH20222["OP_CHECKSIG"] = "Pop the top two items from the stack. Treat the top as a signature and the second as a public key. If the signature is valid, push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsBCH20222["OP_CHECKSIGVERIFY"] = "Pop the top two items from the stack. Treat the top as a signature and the second as a public key. If the signature is not valid, error. (This operation is a combination of OP_CHECKSIG followed by OP_VERIFY.)";
  OpcodeDescriptionsBCH20222["OP_CHECKMULTISIG"] = "Pop items from the stack: first pop the VM Number of public keys, then pop each of those public keys. Next, pop the VM Number of required signatures, then pop each of those signatures. Finally, pop a final VM Number that must be 0 due to a protocol bug. Checking each signature against each public key in order, if all signatures are valid – and the required number of signatures have been provided – push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsBCH20222["OP_CHECKMULTISIGVERIFY"] = "Pop items from the stack: first pop the VM Number of public keys, then pop each of those public keys. Next, pop the VM Number of required signatures, then pop each of those signatures. Finally, (due to a protocol bug) pop an unused final VM Number that must be 0. Checking each signature against each public key in order, if any signatures are invalid – or the required number of signatures have not been provided – error. (This operation is a combination of OP_CHECKMULTISIG followed by OP_VERIFY.)";
  OpcodeDescriptionsBCH20222["OP_NOP1"] = "No operation (reserved for future expansion). Note: OP_NOP1 counts toward the opcode limit.";
  OpcodeDescriptionsBCH20222["OP_CHECKLOCKTIMEVERIFY"] = "Verify the transaction occurs after an absolute block time or height: read the top item on the stack as a VM Number (without removing it), and compare it to the transaction's locktime. If the required locktime has not passed, or if locktime has been disabled for this input by a maximized sequence number, error.";
  OpcodeDescriptionsBCH20222["OP_CHECKSEQUENCEVERIFY"] = `Verify the transaction occurs after the output being spent has "aged" by a relative block time or block height since it was created: read the top item on the stack as a VM Number (without removing it), and compare it to the age encoded in the input's sequence number. If the required relative locktime has not passed, or if relative locktime has been disabled by the sequence number or the transaction version, error.`;
  OpcodeDescriptionsBCH20222["OP_NOP4"] = "No operation (reserved for future expansion). Note: OP_NOP4 counts toward the opcode limit.";
  OpcodeDescriptionsBCH20222["OP_NOP6"] = "No operation (reserved for future expansion). Note: OP_NOP6 counts toward the opcode limit.";
  OpcodeDescriptionsBCH20222["OP_NOP5"] = "No operation (reserved for future expansion). Note: OP_NOP5 counts toward the opcode limit.";
  OpcodeDescriptionsBCH20222["OP_NOP7"] = "No operation (reserved for future expansion). Note: OP_NOP7 counts toward the opcode limit.";
  OpcodeDescriptionsBCH20222["OP_NOP8"] = "No operation (reserved for future expansion). Note: OP_NOP8 counts toward the opcode limit.";
  OpcodeDescriptionsBCH20222["OP_NOP9"] = "No operation (reserved for future expansion). Note: OP_NOP9 counts toward the opcode limit.";
  OpcodeDescriptionsBCH20222["OP_NOP10"] = "No operation (reserved for future expansion). Note: OP_NOP10 counts toward the opcode limit.";
  OpcodeDescriptionsBCH20222["OP_CHECKDATASIG"] = "Pop the top 3 items from the stack. Treat the top as a public key, the second as a message, and the third as a signature. If the signature is valid, push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsBCH20222["OP_CHECKDATASIGVERIFY"] = "Pop the top 3 items from the stack. Treat the top as a public key, the second as a message, and the third as a signature. If the signature is not valid, error. (This operation is a combination of OP_CHECKDATASIG followed by OP_VERIFY.)";
  OpcodeDescriptionsBCH20222["OP_REVERSEBYTES"] = "Pop the top item from the stack and reverse it, pushing the result.";
  OpcodeDescriptionsBCH20222["OP_INPUTINDEX"] = "Push the index of the input being evaluated to the stack as a VM Number.";
  OpcodeDescriptionsBCH20222["OP_ACTIVEBYTECODE"] = "Push the bytecode currently being evaluated, beginning after the last executed OP_CODESEPARATOR, to the stack. For Pay-to-Script-Hash (P2SH) evaluations, this is the redeem bytecode of the Unspent Transaction Output (UTXO) being spent; for all other evaluations, this is the locking bytecode of the UTXO being spent.";
  OpcodeDescriptionsBCH20222["OP_TXVERSION"] = "Push the version of the current transaction to the stack as a VM Number.";
  OpcodeDescriptionsBCH20222["OP_TXINPUTCOUNT"] = "Push the count of inputs in the current transaction to the stack as a VM Number.";
  OpcodeDescriptionsBCH20222["OP_TXOUTPUTCOUNT"] = "Push the count of outputs in the current transaction to the stack as a VM Number.";
  OpcodeDescriptionsBCH20222["OP_TXLOCKTIME"] = "Push the locktime of the current transaction to the stack as a VM Number.";
  OpcodeDescriptionsBCH20222["OP_UTXOVALUE"] = "Pop the top item from the stack as an input index (VM Number). Push the value (in satoshis) of the Unspent Transaction Output (UTXO) spent by that input to the stack as a VM Number.";
  OpcodeDescriptionsBCH20222["OP_UTXOBYTECODE"] = "Pop the top item from the stack as an input index (VM Number). Push the full locking bytecode of the Unspent Transaction Output (UTXO) spent by that input to the stack.";
  OpcodeDescriptionsBCH20222["OP_OUTPOINTTXHASH"] = "Pop the top item from the stack as an input index (VM Number). From that input, push the outpoint transaction hash – the hash of the transaction that created the Unspent Transaction Output (UTXO) that is being spent – to the stack in OP_HASH256 byte order.";
  OpcodeDescriptionsBCH20222["OP_OUTPOINTINDEX"] = "Pop the top item from the stack as an input index (VM Number). From that input, push the outpoint index – the index of the output in the transaction that created the Unspent Transaction Output (UTXO) that is being spent – to the stack as a VM Number.";
  OpcodeDescriptionsBCH20222["OP_INPUTBYTECODE"] = "Pop the top item from the stack as an input index (VM Number). Push the unlocking bytecode of the input at that index to the stack.";
  OpcodeDescriptionsBCH20222["OP_INPUTSEQUENCENUMBER"] = "Pop the top item from the stack as an input index (VM Number). Push the sequence number of the input at that index to the stack as a VM Number.";
  OpcodeDescriptionsBCH20222["OP_OUTPUTVALUE"] = "Pop the top item from the stack as an output index (VM Number). Push the value (in satoshis) of the output at that index to the stack as a VM Number.";
  OpcodeDescriptionsBCH20222["OP_OUTPUTBYTECODE"] = "Pop the top item from the stack as an output index (VM Number). Push the locking bytecode of the output at that index to the stack.";
})(OpcodeDescriptionsBCH2022 || (OpcodeDescriptionsBCH2022 = {}));

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/bch/2022/bch-2022-errors.js
var import_dist259 = __toESM(require_dist(), 1);
var import_dist260 = __toESM(require_dist2(), 1);
var import_dist261 = __toESM(require_dist3(), 1);
var AuthenticationErrorBCH2022;
(function(AuthenticationErrorBCH20222) {
  AuthenticationErrorBCH20222["exceededMaximumVmNumberLength"] = "Program attempted an OP_BIN2NUM operation on a byte sequence that cannot be encoded within the maximum VM Number length (8 bytes).";
})(AuthenticationErrorBCH2022 || (AuthenticationErrorBCH2022 = {}));

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/bch/2022/bch-2022-types.js
var import_dist262 = __toESM(require_dist(), 1);
var import_dist263 = __toESM(require_dist2(), 1);
var import_dist264 = __toESM(require_dist3(), 1);
var createTestAuthenticationProgramBCH = ({ lockingBytecode, valueSatoshis, unlockingBytecode }) => {
  const testFundingTransaction = {
    inputs: [
      {
        outpointIndex: 4294967295,
        outpointTransactionHash: hexToBin("0000000000000000000000000000000000000000000000000000000000000000"),
        sequenceNumber: 4294967295,
        unlockingBytecode: Uint8Array.of(0, 0)
      }
    ],
    locktime: 0,
    outputs: [{ lockingBytecode, valueSatoshis }],
    version: 1
  };
  const testSpendingTransaction = {
    inputs: [
      {
        outpointIndex: 0,
        outpointTransactionHash: hashTransactionP2pOrder(encodeTransactionCommon(testFundingTransaction)),
        sequenceNumber: 4294967295,
        unlockingBytecode
      }
    ],
    locktime: 0,
    outputs: [{ lockingBytecode: Uint8Array.of(), valueSatoshis }],
    version: 1
  };
  return {
    inputIndex: 0,
    sourceOutputs: testFundingTransaction.outputs,
    transaction: testSpendingTransaction
  };
};

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/bch/2022/bch-2022-vm.js
var import_dist265 = __toESM(require_dist(), 1);
var import_dist266 = __toESM(require_dist2(), 1);
var import_dist267 = __toESM(require_dist3(), 1);
var createVirtualMachineBCH2022 = (standard = true) => createAuthenticationVirtualMachine(createInstructionSetBCH2022(standard));

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/bch/chips/bch-chips.js
var import_dist295 = __toESM(require_dist(), 1);
var import_dist296 = __toESM(require_dist2(), 1);
var import_dist297 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/bch/chips/bch-chips-crypto.js
var import_dist277 = __toESM(require_dist(), 1);
var import_dist278 = __toESM(require_dist2(), 1);
var import_dist279 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/bch/chips/bch-chips-errors.js
var import_dist271 = __toESM(require_dist(), 1);
var import_dist272 = __toESM(require_dist2(), 1);
var import_dist273 = __toESM(require_dist3(), 1);
var AuthenticationErrorBCHCHIPs;
(function(AuthenticationErrorBCHCHIPs2) {
  AuthenticationErrorBCHCHIPs2["invalidBoolean"] = "Invalid input: this operation requires a valid boolean (VM Number 0 or VM Number 1).";
  AuthenticationErrorBCHCHIPs2["unexpectedUntil"] = "Encountered an OP_UNTIL that is not following a matching OP_BEGIN.";
  AuthenticationErrorBCHCHIPs2["excessiveHashing"] = "Program attempted a hashing operation that would exceed the hashing limit (660 hash digest iterations).";
  AuthenticationErrorBCHCHIPs2["excessiveLooping"] = "Program attempted an OP_UNTIL operation that would exceed the limit of repeated bytes (10,000 bytes minus active bytecode length).";
})(AuthenticationErrorBCHCHIPs || (AuthenticationErrorBCHCHIPs = {}));

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/bch/chips/bch-chips-types.js
var import_dist274 = __toESM(require_dist(), 1);
var import_dist275 = __toESM(require_dist2(), 1);
var import_dist276 = __toESM(require_dist3(), 1);
var ConsensusBCHCHIPs;
(function(ConsensusBCHCHIPs2) {
  ConsensusBCHCHIPs2[ConsensusBCHCHIPs2["maximumTransactionVersion"] = 2] = "maximumTransactionVersion";
  ConsensusBCHCHIPs2[ConsensusBCHCHIPs2["bannedTransactionSize"] = 64] = "bannedTransactionSize";
  ConsensusBCHCHIPs2[ConsensusBCHCHIPs2["maximumHashDigestIterations"] = 660] = "maximumHashDigestIterations";
})(ConsensusBCHCHIPs || (ConsensusBCHCHIPs = {}));
var cloneAuthenticationProgramStateBCHCHIPs = (state) => ({
  ...state.error === void 0 ? {} : { error: state.error },
  alternateStack: cloneStack(state.alternateStack),
  controlStack: state.controlStack.slice(),
  hashDigestIterations: state.hashDigestIterations,
  instructions: state.instructions.map(cloneAuthenticationInstruction),
  ip: state.ip,
  lastCodeSeparator: state.lastCodeSeparator,
  program: cloneAuthenticationProgramCommon(state.program),
  repeatedBytes: state.repeatedBytes,
  signedMessages: state.signedMessages.map((item) => ({
    digest: item.digest.slice(),
    ..."serialization" in item ? { serialization: item.serialization.slice() } : { message: item.message.slice() }
  })),
  stack: cloneStack(state.stack)
});
var createAuthenticationProgramStateBCHCHIPs = ({ program, instructions, stack }) => ({
  alternateStack: [],
  controlStack: [],
  hashDigestIterations: 0,
  instructions,
  ip: 0,
  lastCodeSeparator: -1,
  program,
  repeatedBytes: 0,
  signedMessages: [],
  stack
});

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/bch/chips/bch-chips-crypto.js
var hashDigestIterations = (messageLength) => (
  // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
  1 + ((messageLength + 8) / 64 | 0)
);
var incrementHashDigestIterations = (state, messageLength, operation) => {
  const requiredTotalIterations = state.hashDigestIterations + hashDigestIterations(messageLength);
  if (requiredTotalIterations > ConsensusBCHCHIPs.maximumHashDigestIterations) {
    return applyError(state, AuthenticationErrorBCHCHIPs.excessiveHashing, `Required cumulative iterations: ${requiredTotalIterations}`);
  }
  return operation(state);
};
var opRipemd160ChipLimits = ({ ripemd160: ripemd1602 } = { ripemd160 }) => (state) => useOneStackItem(state, (nextState, [value]) => incrementHashDigestIterations(nextState, value.length, (finalState) => pushToStack(finalState, ripemd1602.hash(value))));
var opSha1ChipLimits = ({ sha1: sha12 } = { sha1 }) => (state) => useOneStackItem(state, (nextState, [value]) => incrementHashDigestIterations(nextState, value.length, (finalState) => pushToStack(finalState, sha12.hash(value))));
var opSha256ChipLimits = ({ sha256: sha2562 } = { sha256 }) => (state) => useOneStackItem(state, (nextState, [value]) => incrementHashDigestIterations(nextState, value.length, (finalState) => pushToStack(finalState, sha2562.hash(value))));
var opHash160ChipLimits = ({ ripemd160: ripemd1602, sha256: sha2562 } = { ripemd160, sha256 }) => (state) => useOneStackItem(state, (nextState, [value]) => incrementHashDigestIterations(nextState, value.length, (finalState) => pushToStack(finalState, ripemd1602.hash(sha2562.hash(value)))));
var opHash256ChipLimits = ({ sha256: sha2562 } = { sha256 }) => (state) => useOneStackItem(state, (nextState, [value]) => incrementHashDigestIterations(nextState, value.length, (finalState) => pushToStack(finalState, hash256(value, sha2562))));
var opCheckSigChipLimits = ({ secp256k1: secp256k12, sha256: sha2562 } = { secp256k1, sha256 }) => (s) => (
  // eslint-disable-next-line complexity
  useTwoStackItems(s, (state, [bitcoinEncodedSignature, publicKey]) => {
    if (!isValidPublicKeyEncoding(publicKey)) {
      return applyError(state, AuthenticationErrorCommon.invalidPublicKeyEncoding);
    }
    if (!isValidSignatureEncodingBCHTransaction(bitcoinEncodedSignature, SigningSerializationTypesBCH2023)) {
      return applyError(state, AuthenticationErrorCommon.invalidSignatureEncoding, `Transaction signature (including signing serialization type): ${binToHex(bitcoinEncodedSignature)}`);
    }
    const coveredBytecode = encodeAuthenticationInstructions(state.instructions).subarray(state.lastCodeSeparator + 1);
    const { signingSerializationType, signature } = decodeBitcoinSignature(bitcoinEncodedSignature);
    const serialization = generateSigningSerializationBCH(state.program, { coveredBytecode, signingSerializationType }, sha2562);
    const requiredTotalIterations = state.hashDigestIterations + hashDigestIterations(serialization.length);
    if (requiredTotalIterations > ConsensusBCHCHIPs.maximumHashDigestIterations) {
      return applyError(state, AuthenticationErrorBCHCHIPs.excessiveHashing, `Required cumulative iterations: ${requiredTotalIterations}`);
    }
    const digest = hash256(serialization, sha2562);
    state.signedMessages.push({ digest, serialization });
    const useSchnorr = signature.length === ConsensusCommon.schnorrSignatureLength;
    const success = useSchnorr ? secp256k12.verifySignatureSchnorr(signature, publicKey, digest) : secp256k12.verifySignatureDERLowS(signature, publicKey, digest);
    return !success && signature.length !== 0 ? applyError(state, AuthenticationErrorCommon.nonNullSignatureFailure) : pushToStack(state, booleanToVmNumber(success));
  })
);
var opCheckMultiSigChipLimits = ({ secp256k1: secp256k12, sha256: sha2562 } = { secp256k1, sha256 }) => (s) => useOneVmNumber(s, (state, publicKeysValue) => {
  const potentialPublicKeys = Number(publicKeysValue);
  if (potentialPublicKeys < 0) {
    return applyError(state, AuthenticationErrorCommon.invalidNaturalNumber);
  }
  if (potentialPublicKeys > 20) {
    return applyError(state, AuthenticationErrorCommon.exceedsMaximumMultisigPublicKeyCount);
  }
  const publicKeys = (
    // eslint-disable-next-line functional/immutable-data
    potentialPublicKeys > 0 ? state.stack.splice(-potentialPublicKeys) : []
  );
  return useOneVmNumber(state, (nextState, approvingKeys) => {
    const requiredApprovingPublicKeys = Number(approvingKeys);
    if (requiredApprovingPublicKeys < 0) {
      return applyError(nextState, AuthenticationErrorCommon.invalidNaturalNumber);
    }
    if (requiredApprovingPublicKeys > potentialPublicKeys) {
      return applyError(nextState, AuthenticationErrorCommon.insufficientPublicKeys);
    }
    const signatures = requiredApprovingPublicKeys > 0 ? (
      // eslint-disable-next-line functional/immutable-data
      nextState.stack.splice(-requiredApprovingPublicKeys)
    ) : [];
    return useOneStackItem(
      nextState,
      // eslint-disable-next-line complexity
      (finalState, [protocolBugValue]) => {
        if (protocolBugValue.length !== 0) {
          return applyError(finalState, AuthenticationErrorCommon.invalidProtocolBugValue);
        }
        const coveredBytecode = encodeAuthenticationInstructions(finalState.instructions).subarray(finalState.lastCodeSeparator + 1);
        let approvingPublicKeys = 0;
        let remainingSignatures = signatures.length;
        let remainingPublicKeys = publicKeys.length;
        while (remainingSignatures > 0 && remainingPublicKeys > 0 && approvingPublicKeys + remainingPublicKeys >= remainingSignatures && approvingPublicKeys !== requiredApprovingPublicKeys) {
          const publicKey = publicKeys[remainingPublicKeys - 1];
          const bitcoinEncodedSignature = (
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            signatures[remainingSignatures - 1]
          );
          if (!isValidPublicKeyEncoding(publicKey)) {
            return applyError(finalState, AuthenticationErrorCommon.invalidPublicKeyEncoding);
          }
          if (!isValidSignatureEncodingBCHTransaction(bitcoinEncodedSignature, SigningSerializationTypesBCH2023)) {
            return applyError(finalState, AuthenticationErrorCommon.invalidSignatureEncoding, `Transaction signature (including signing serialization type): ${binToHex(bitcoinEncodedSignature)}`);
          }
          const { signingSerializationType, signature } = decodeBitcoinSignature(bitcoinEncodedSignature);
          const serialization = generateSigningSerializationBCH(state.program, { coveredBytecode, signingSerializationType }, sha2562);
          const requiredTotalIterations = state.hashDigestIterations + hashDigestIterations(serialization.length);
          if (requiredTotalIterations > ConsensusBCHCHIPs.maximumHashDigestIterations) {
            return applyError(state, AuthenticationErrorBCHCHIPs.excessiveHashing, `Required cumulative iterations: ${requiredTotalIterations}`);
          }
          const digest = hash256(serialization, sha2562);
          finalState.signedMessages.push({ digest, serialization });
          if (signature.length === ConsensusCommon.schnorrSignatureLength) {
            return applyError(finalState, AuthenticationErrorCommon.schnorrSizedSignatureInCheckMultiSig);
          }
          const signed = secp256k12.verifySignatureDERLowS(signature, publicKey, digest);
          if (signed) {
            approvingPublicKeys += 1;
            remainingSignatures -= 1;
          }
          remainingPublicKeys -= 1;
        }
        const success = approvingPublicKeys === requiredApprovingPublicKeys;
        if (!success && !signatures.every((signature) => signature.length === 0)) {
          return applyError(finalState, AuthenticationErrorCommon.nonNullSignatureFailure);
        }
        return pushToStack(finalState, booleanToVmNumber(success));
      }
    );
  });
});
var opCheckSigVerifyChipLimits = ({ secp256k1: secp256k12, sha256: sha2562 } = { secp256k1, sha256 }) => combineOperations(opCheckSigChipLimits({ secp256k1: secp256k12, sha256: sha2562 }), opVerify);
var opCheckMultiSigVerifyChipLimits = ({ secp256k1: secp256k12, sha256: sha2562 }) => combineOperations(opCheckMultiSigChipLimits({ secp256k1: secp256k12, sha256: sha2562 }), opVerify);
var opCheckDataSigChipLimits = ({ secp256k1: secp256k12, sha256: sha2562 }) => (state) => (
  // eslint-disable-next-line complexity
  useThreeStackItems(state, (nextState, [signature, message, publicKey]) => {
    if (!isValidSignatureEncodingBCHRaw(signature)) {
      return applyError(nextState, AuthenticationErrorCommon.invalidSignatureEncoding, `Data signature: ${binToHex(signature)}`);
    }
    if (!isValidPublicKeyEncoding(publicKey)) {
      return applyError(nextState, AuthenticationErrorCommon.invalidPublicKeyEncoding);
    }
    const requiredTotalIterations = state.hashDigestIterations + hashDigestIterations(message.length);
    if (requiredTotalIterations > ConsensusBCHCHIPs.maximumHashDigestIterations) {
      return applyError(state, AuthenticationErrorBCHCHIPs.excessiveHashing, `Required cumulative iterations: ${requiredTotalIterations}`);
    }
    const digest = sha2562.hash(message);
    nextState.signedMessages.push({ digest, message });
    const useSchnorr = signature.length === ConsensusCommon.schnorrSignatureLength;
    const success = useSchnorr ? secp256k12.verifySignatureSchnorr(signature, publicKey, digest) : secp256k12.verifySignatureDERLowS(signature, publicKey, digest);
    return !success && signature.length !== 0 ? applyError(nextState, AuthenticationErrorCommon.nonNullSignatureFailure) : pushToStack(nextState, booleanToVmNumber(success));
  })
);
var opCheckDataSigVerifyChipLimits = ({ secp256k1: secp256k12, sha256: sha2562 } = { secp256k1, sha256 }) => combineOperations(opCheckDataSigChipLimits({ secp256k1: secp256k12, sha256: sha2562 }), opVerify);

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/bch/chips/bch-chips-descriptions.js
var import_dist280 = __toESM(require_dist(), 1);
var import_dist281 = __toESM(require_dist2(), 1);
var import_dist282 = __toESM(require_dist3(), 1);
var OpcodeDescriptionsBCHCHIPs;
(function(OpcodeDescriptionsBCHCHIPs2) {
  OpcodeDescriptionsBCHCHIPs2["OP_0"] = "Push the VM Number 0 onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_1"] = "Push the next byte onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_2"] = "Push the next 2 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_3"] = "Push the next 3 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_4"] = "Push the next 4 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_5"] = "Push the next 5 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_6"] = "Push the next 6 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_7"] = "Push the next 7 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_8"] = "Push the next 8 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_9"] = "Push the next 9 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_10"] = "Push the next 10 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_11"] = "Push the next 11 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_12"] = "Push the next 12 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_13"] = "Push the next 13 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_14"] = "Push the next 14 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_15"] = "Push the next 15 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_16"] = "Push the next 16 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_17"] = "Push the next 17 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_18"] = "Push the next 18 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_19"] = "Push the next 19 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_20"] = "Push the next 20 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_21"] = "Push the next 21 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_22"] = "Push the next 22 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_23"] = "Push the next 23 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_24"] = "Push the next 24 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_25"] = "Push the next 25 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_26"] = "Push the next 26 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_27"] = "Push the next 27 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_28"] = "Push the next 28 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_29"] = "Push the next 29 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_30"] = "Push the next 30 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_31"] = "Push the next 31 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_32"] = "Push the next 32 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_33"] = "Push the next 33 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_34"] = "Push the next 34 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_35"] = "Push the next 35 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_36"] = "Push the next 36 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_37"] = "Push the next 37 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_38"] = "Push the next 38 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_39"] = "Push the next 39 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_40"] = "Push the next 40 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_41"] = "Push the next 41 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_42"] = "Push the next 42 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_43"] = "Push the next 43 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_44"] = "Push the next 44 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_45"] = "Push the next 45 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_46"] = "Push the next 46 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_47"] = "Push the next 47 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_48"] = "Push the next 48 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_49"] = "Push the next 49 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_50"] = "Push the next 50 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_51"] = "Push the next 51 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_52"] = "Push the next 52 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_53"] = "Push the next 53 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_54"] = "Push the next 54 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_55"] = "Push the next 55 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_56"] = "Push the next 56 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_57"] = "Push the next 57 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_58"] = "Push the next 58 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_59"] = "Push the next 59 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_60"] = "Push the next 60 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_61"] = "Push the next 61 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_62"] = "Push the next 62 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_63"] = "Push the next 63 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_64"] = "Push the next 64 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_65"] = "Push the next 65 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_66"] = "Push the next 66 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_67"] = "Push the next 67 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_68"] = "Push the next 68 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_69"] = "Push the next 69 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_70"] = "Push the next 70 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_71"] = "Push the next 71 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_72"] = "Push the next 72 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_73"] = "Push the next 73 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_74"] = "Push the next 74 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHBYTES_75"] = "Push the next 75 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHDATA_1"] = "Read the next Uint8 and push that number of bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHDATA_2"] = "Read the next little-endian Uint16 and push that number of bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_PUSHDATA_4"] = "Read the next little-endian Uint32 and push that number of bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_1NEGATE"] = "Push the VM Number -1 onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_RESERVED"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED does not count toward the opcode limit.";
  OpcodeDescriptionsBCHCHIPs2["OP_1"] = "Push a 1 (VM Number) onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_2"] = "Push a 2 (VM Number) onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_3"] = "Push a 3 (VM Number) onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_4"] = "Push a 4 (VM Number) onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_5"] = "Push a 5 (VM Number) onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_6"] = "Push a 6 (VM Number) onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_7"] = "Push a 7 (VM Number) onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_8"] = "Push a 8 (VM Number) onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_9"] = "Push a 9 (VM Number) onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_10"] = "Push a 10 (VM Number) onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_11"] = "Push a 11 (VM Number) onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_12"] = "Push a 12 (VM Number) onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_13"] = "Push a 13 (VM Number) onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_14"] = "Push a 14 (VM Number) onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_15"] = "Push a 15 (VM Number) onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_16"] = "Push a 16 (VM Number) onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_NOP"] = "No operation. Note: OP_NOP counts toward the opcode limit.";
  OpcodeDescriptionsBCHCHIPs2["OP_VER"] = "Error unless found in an unexecuted conditional branch. Note: OP_VER counts toward the opcode limit. (Historically, this pushed a protocol version number to the stack.)";
  OpcodeDescriptionsBCHCHIPs2["OP_IF"] = 'Pop the top item from the stack. If it is not "truthy", skip evaluation until a matching OP_ELSE or OP_ENDIF.';
  OpcodeDescriptionsBCHCHIPs2["OP_NOTIF"] = 'Pop the top item from the stack. If it is "truthy", skip evaluation until a matching OP_ELSE or OP_ENDIF.';
  OpcodeDescriptionsBCHCHIPs2["OP_BEGIN"] = "Push the current instruction pointer index to the control stack as an integer (to be read by OP_UNTIL).";
  OpcodeDescriptionsBCHCHIPs2["OP_UNTIL"] = "Pop the top item from the control stack (if the control value is not an integer, error). Add the difference between the control value and the current instruction pointer index to the repeated bytes counter, if the sum of the repeated bytes counter and the active bytecode length is greater than the maximum bytecode length, error. Pop the top item from the stack, if the value is a 0 (VM Number), move the instruction pointer to the control value (and re-evaluate the OP_BEGIN).";
  OpcodeDescriptionsBCHCHIPs2["OP_ELSE"] = "Invert conditional evaluation within the current OP_IF ... OP_ENDIF block. (If evaluation is enabled, disable it, if it is disabled, enable it.)";
  OpcodeDescriptionsBCHCHIPs2["OP_ENDIF"] = "End the current OP_IF/OP_NOTIF ... OP_ENDIF block.";
  OpcodeDescriptionsBCHCHIPs2["OP_VERIFY"] = `Pop the top item from the stack and error if it isn't "truthy".`;
  OpcodeDescriptionsBCHCHIPs2["OP_RETURN"] = "Error when executed.";
  OpcodeDescriptionsBCHCHIPs2["OP_TOALTSTACK"] = "Pop the top item from the stack and push it onto the alternate stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_FROMALTSTACK"] = "Pop the top item from the alternate stack and push it onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_2DROP"] = "Pop the top 2 items from the stack and discard them.";
  OpcodeDescriptionsBCHCHIPs2["OP_2DUP"] = "Duplicate the top 2 items on the stack. (E.g. [a, b] -> [a, b, a, b])";
  OpcodeDescriptionsBCHCHIPs2["OP_3DUP"] = "Duplicate the top 3 items on the stack. (E.g. [a, b, c] -> [a, b, c, a, b, c])";
  OpcodeDescriptionsBCHCHIPs2["OP_2OVER"] = "Duplicate the 2 items beginning at a depth of 2 on the stack. (E.g. [a, b, c, d] -> [a, b, c, d, a, b])";
  OpcodeDescriptionsBCHCHIPs2["OP_2ROT"] = "Rotate the top 6 items on the stack, bringing the fifth and sixth items to the top. (E.g. [a, b, c, d, e, f] -> [c, d, e, f, a, b])";
  OpcodeDescriptionsBCHCHIPs2["OP_2SWAP"] = "Swap the positions of the top two pairs of items on the stack. (E.g. [a, b, c, d] -> [c, d, a, b])";
  OpcodeDescriptionsBCHCHIPs2["OP_IFDUP"] = 'If the top item on the stack is "truthy", duplicate it.';
  OpcodeDescriptionsBCHCHIPs2["OP_DEPTH"] = "Push the current number of stack items as a VM Number.";
  OpcodeDescriptionsBCHCHIPs2["OP_DROP"] = "Pop the top item from the stack and discard it. (E.g. [a] -> [])";
  OpcodeDescriptionsBCHCHIPs2["OP_DUP"] = "Duplicate the top item on the stack. (E.g. [a] -> [a, a])";
  OpcodeDescriptionsBCHCHIPs2["OP_NIP"] = "Remove the second-to-top item from the stack. (E.g. [a, b] -> [b])";
  OpcodeDescriptionsBCHCHIPs2["OP_OVER"] = "Duplicate the second-to-top item on the stack. (E.g. [a, b] -> [a, b, a])";
  OpcodeDescriptionsBCHCHIPs2["OP_PICK"] = "Pop the top item from the stack as a VM Number. Duplicate the item at that depth (zero-indexed), placing it on top of the stack. (E.g. [a, b, c, 2] -> [a, b, c, a])";
  OpcodeDescriptionsBCHCHIPs2["OP_ROLL"] = "Pop the top item from the stack as a VM Number. Move the item at that depth (zero-indexed) to the top of the stack. (E.g. [a, b, c, 2] -> [b, c, a])";
  OpcodeDescriptionsBCHCHIPs2["OP_ROT"] = "Rotate the top 3 items on the stack, bringing the third item to the top. (E.g. [a, b, c] -> [b, c, a])";
  OpcodeDescriptionsBCHCHIPs2["OP_SWAP"] = "Swap the top two items on the stack. (E.g. [a, b] -> [b, a])";
  OpcodeDescriptionsBCHCHIPs2["OP_TUCK"] = "Duplicate the item at the top of the stack, inserting it below the second-to-top item. (E.g. [a, b] -> [b, a, b])";
  OpcodeDescriptionsBCHCHIPs2["OP_CAT"] = "Pop the top 2 items from the stack and concatenate them, pushing the result.";
  OpcodeDescriptionsBCHCHIPs2["OP_SPLIT"] = "Pop the top item from the stack as an index (VM Number) and the next item as a byte array. Split the byte array into two stack items at the index (zero-based), pushing the results.";
  OpcodeDescriptionsBCHCHIPs2["OP_NUM2BIN"] = "Pop the top item from the stack as an item length (VM Number) and the next item as a VM Number (without encoding restrictions). Re-encode the number using a byte array of the provided length, filling any unused bytes with zeros, then push the result. (If the requested length is too short to encode the number, error.)";
  OpcodeDescriptionsBCHCHIPs2["OP_BIN2NUM"] = "Pop the top item from the stack as a VM Number without encoding restrictions. Minimally-encode the number and push the result. (If the number can't be encoded in 4 bytes or less, error.)";
  OpcodeDescriptionsBCHCHIPs2["OP_SIZE"] = "Push the byte-length of the top stack item as a VM Number.";
  OpcodeDescriptionsBCHCHIPs2["OP_INVERT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this flipped all the bits in a stack item.)";
  OpcodeDescriptionsBCHCHIPs2["OP_AND"] = "Pop the top 2 items from the stack and perform a bitwise AND on each byte, pushing the result. If the length of the items are not equal, error.";
  OpcodeDescriptionsBCHCHIPs2["OP_OR"] = "Pop the top 2 items from the stack and perform a bitwise OR on each byte, pushing the result. If the length of the items are not equal, error.";
  OpcodeDescriptionsBCHCHIPs2["OP_XOR"] = "Pop the top 2 items from the stack and perform a bitwise XOR on each byte, pushing the result. If the length of the items are not equal, error.";
  OpcodeDescriptionsBCHCHIPs2["OP_EQUAL"] = "Pop the top two items from the stack and compare them byte-by-byte. If they are the same, push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs2["OP_EQUALVERIFY"] = "Pop the top two items from the stack and compare them byte-by-byte. If the values are different, error. (This operation is a combination of OP_EQUAL followed by OP_VERIFY.)";
  OpcodeDescriptionsBCHCHIPs2["OP_RESERVED1"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED1 counts toward the opcode limit.";
  OpcodeDescriptionsBCHCHIPs2["OP_RESERVED2"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED2 counts toward the opcode limit.";
  OpcodeDescriptionsBCHCHIPs2["OP_1ADD"] = "Pop the top item from the stack as a VM Number, add 1, then push the result.";
  OpcodeDescriptionsBCHCHIPs2["OP_1SUB"] = "Pop the top item from the stack as a VM Number, subtract 1, then push the result.";
  OpcodeDescriptionsBCHCHIPs2["OP_2MUL"] = "Error, even when found in an unexecuted conditional branch. (Historically, this multiplied a VM Number by 2.)";
  OpcodeDescriptionsBCHCHIPs2["OP_2DIV"] = "Error, even when found in an unexecuted conditional branch. (Historically, this divided a VM Number by 2.)";
  OpcodeDescriptionsBCHCHIPs2["OP_NEGATE"] = "Pop the top item from the stack as a VM Number, negate it, then push the result.";
  OpcodeDescriptionsBCHCHIPs2["OP_ABS"] = "Pop the top item from the stack as a VM Number, take its absolute value, then push the result.";
  OpcodeDescriptionsBCHCHIPs2["OP_NOT"] = "Pop the top item from the stack as a VM Number. If its value is 0, push a 1 (VM Number), otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs2["OP_0NOTEQUAL"] = "Pop the top item from the stack as a VM Number. If its value is not 0, push a 1 (VM Number), otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs2["OP_ADD"] = "Pop the top two items from the stack as VM Numbers. Add them, then push the result.";
  OpcodeDescriptionsBCHCHIPs2["OP_SUB"] = "Pop the top two items from the stack as VM Numbers. Subtract the top item from the second item, then push the result.";
  OpcodeDescriptionsBCHCHIPs2["OP_MUL"] = "Pop the top two items from the stack as VM Numbers. Multiply them, then push the result.";
  OpcodeDescriptionsBCHCHIPs2["OP_DIV"] = "Pop the top item from the stack as a denominator (VM Number) and the next as a numerator (VM Number). Divide and push the result to the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_MOD"] = "Pop the top item from the stack as a denominator (VM Number) and the next as a numerator (VM Number). Divide and push the remainder to the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_LSHIFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a sign-preserving, left bit shift.)";
  OpcodeDescriptionsBCHCHIPs2["OP_RSHIFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a sign-preserving, right bit shift.)";
  OpcodeDescriptionsBCHCHIPs2["OP_BOOLAND"] = "Pop the top two items from the stack as VM Numbers. If neither value is a 0 (VM Number), push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs2["OP_BOOLOR"] = "Pop the top two items from the stack as VM Numbers. If either value is a 1 (VM Number), push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs2["OP_NUMEQUAL"] = "Pop the top two items from the stack as VM Numbers. If the values are equal, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs2["OP_NUMEQUALVERIFY"] = "Pop the top two items from the stack as VM Numbers. If the values are different, error. (This operation is a combination of OP_NUMEQUAL followed by OP_VERIFY.)";
  OpcodeDescriptionsBCHCHIPs2["OP_NUMNOTEQUAL"] = "Pop the top two items from the stack as VM Numbers. If the values are not equal, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs2["OP_LESSTHAN"] = "Pop the top two items from the stack as VM Numbers. If the second item is less than top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs2["OP_GREATERTHAN"] = "Pop the top two items from the stack as VM Numbers. If the second item is greater than top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs2["OP_LESSTHANOREQUAL"] = "Pop the top two items from the stack as VM Numbers. If the second item is less than or equal to the top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs2["OP_GREATERTHANOREQUAL"] = "Pop the top two items from the stack as VM Numbers. If the second item is greater than or equal to the top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs2["OP_MIN"] = "Pop the top two items from the stack as VM Numbers. Push the smaller of the two numbers.";
  OpcodeDescriptionsBCHCHIPs2["OP_MAX"] = "Pop the top two items from the stack as VM Numbers. Push the larger of the two numbers.";
  OpcodeDescriptionsBCHCHIPs2["OP_WITHIN"] = "Pop the top three items from the stack as VM Numbers. If the top number is within the range defined by the following two numbers (left-inclusive), push a 1 (VM Number). Otherwise, push a 0 (VM Number). (E.g. for [a, b, c]: if (b <= a), and (a < c), [1]. Else [0].)";
  OpcodeDescriptionsBCHCHIPs2["OP_RIPEMD160"] = "Pop the top item from the stack and pass it through ripemd160, pushing the result onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_SHA1"] = "Pop the top item from the stack and pass it through sha1, pushing the result onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_SHA256"] = "Pop the top item from the stack and pass it through sha256, pushing the result onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_HASH160"] = "Pop the top item from the stack and pass it through sha256, then ripemd160, pushing the result onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_HASH256"] = "Pop the top item from the stack and pass it through sha256 twice, pushing the result onto the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_CODESEPARATOR"] = "Update the value of lastCodeSeparator to the instruction pointer's current value. (This reduces the coverage of signing serializations used in signature verification operations.)";
  OpcodeDescriptionsBCHCHIPs2["OP_CHECKSIG"] = "Pop the top two items from the stack. Treat the top as a signature and the second as a public key. If the signature is valid, push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs2["OP_CHECKSIGVERIFY"] = "Pop the top two items from the stack. Treat the top as a signature and the second as a public key. If the signature is not valid, error. (This operation is a combination of OP_CHECKSIG followed by OP_VERIFY.)";
  OpcodeDescriptionsBCHCHIPs2["OP_CHECKMULTISIG"] = "Pop items from the stack: first pop the VM Number of public keys, then pop each of those public keys. Next, pop the VM Number of required signatures, then pop each of those signatures. Finally, pop a final VM Number that must be 0 due to a protocol bug. Checking each signature against each public key in order, if all signatures are valid – and the required number of signatures have been provided – push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs2["OP_CHECKMULTISIGVERIFY"] = "Pop items from the stack: first pop the VM Number of public keys, then pop each of those public keys. Next, pop the VM Number of required signatures, then pop each of those signatures. Finally, (due to a protocol bug) pop an unused final VM Number that must be 0. Checking each signature against each public key in order, if any signatures are invalid – or the required number of signatures have not been provided – error. (This operation is a combination of OP_CHECKMULTISIG followed by OP_VERIFY.)";
  OpcodeDescriptionsBCHCHIPs2["OP_NOP1"] = "No operation (reserved for future expansion). Note: OP_NOP1 counts toward the opcode limit.";
  OpcodeDescriptionsBCHCHIPs2["OP_CHECKLOCKTIMEVERIFY"] = "Verify the transaction occurs after an absolute block time or height: read the top item on the stack as a VM Number (without removing it), and compare it to the transaction's locktime. If the required locktime has not passed, or if locktime has been disabled for this input by a maximized sequence number, error.";
  OpcodeDescriptionsBCHCHIPs2["OP_CHECKSEQUENCEVERIFY"] = `Verify the transaction occurs after the output being spent has "aged" by a relative block time or block height since it was created: read the top item on the stack as a VM Number (without removing it), and compare it to the age encoded in the input's sequence number. If the required relative locktime has not passed, or if relative locktime has been disabled by the sequence number or the transaction version, error.`;
  OpcodeDescriptionsBCHCHIPs2["OP_NOP4"] = "No operation (reserved for future expansion). Note: OP_NOP4 counts toward the opcode limit.";
  OpcodeDescriptionsBCHCHIPs2["OP_NOP6"] = "No operation (reserved for future expansion). Note: OP_NOP6 counts toward the opcode limit.";
  OpcodeDescriptionsBCHCHIPs2["OP_NOP5"] = "No operation (reserved for future expansion). Note: OP_NOP5 counts toward the opcode limit.";
  OpcodeDescriptionsBCHCHIPs2["OP_NOP7"] = "No operation (reserved for future expansion). Note: OP_NOP7 counts toward the opcode limit.";
  OpcodeDescriptionsBCHCHIPs2["OP_NOP8"] = "No operation (reserved for future expansion). Note: OP_NOP8 counts toward the opcode limit.";
  OpcodeDescriptionsBCHCHIPs2["OP_NOP9"] = "No operation (reserved for future expansion). Note: OP_NOP9 counts toward the opcode limit.";
  OpcodeDescriptionsBCHCHIPs2["OP_NOP10"] = "No operation (reserved for future expansion). Note: OP_NOP10 counts toward the opcode limit.";
  OpcodeDescriptionsBCHCHIPs2["OP_CHECKDATASIG"] = "Pop the top 3 items from the stack. Treat the top as a public key, the second as a message, and the third as a signature. If the signature is valid, push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs2["OP_CHECKDATASIGVERIFY"] = "Pop the top 3 items from the stack. Treat the top as a public key, the second as a message, and the third as a signature. If the signature is not valid, error. (This operation is a combination of OP_CHECKDATASIG followed by OP_VERIFY.)";
  OpcodeDescriptionsBCHCHIPs2["OP_REVERSEBYTES"] = "Pop the top item from the stack and reverse it, pushing the result.";
  OpcodeDescriptionsBCHCHIPs2["OP_INPUTINDEX"] = "Push the index of the input being evaluated to the stack as a VM Number.";
  OpcodeDescriptionsBCHCHIPs2["OP_ACTIVEBYTECODE"] = "Push the bytecode currently being evaluated, beginning after the last executed OP_CODESEPARATOR, to the stack. For Pay-to-Script-Hash (P2SH) evaluations, this is the redeem bytecode of the Unspent Transaction Output (UTXO) being spent; for all other evaluations, this is the locking bytecode of the UTXO being spent.";
  OpcodeDescriptionsBCHCHIPs2["OP_TXVERSION"] = "Push the version of the current transaction to the stack as a VM Number.";
  OpcodeDescriptionsBCHCHIPs2["OP_TXINPUTCOUNT"] = "Push the count of inputs in the current transaction to the stack as a VM Number.";
  OpcodeDescriptionsBCHCHIPs2["OP_TXOUTPUTCOUNT"] = "Push the count of outputs in the current transaction to the stack as a VM Number.";
  OpcodeDescriptionsBCHCHIPs2["OP_TXLOCKTIME"] = "Push the locktime of the current transaction to the stack as a VM Number.";
  OpcodeDescriptionsBCHCHIPs2["OP_UTXOVALUE"] = "Pop the top item from the stack as an input index (VM Number). Push the value (in satoshis) of the Unspent Transaction Output (UTXO) spent by that input to the stack as a VM Number.";
  OpcodeDescriptionsBCHCHIPs2["OP_UTXOBYTECODE"] = "Pop the top item from the stack as an input index (VM Number). Push the full locking bytecode of the Unspent Transaction Output (UTXO) spent by that input to the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_OUTPOINTTXHASH"] = "Pop the top item from the stack as an input index (VM Number). From that input, push the outpoint transaction hash – the hash of the transaction that created the Unspent Transaction Output (UTXO) that is being spent – to the stack in OP_HASH256 byte order.";
  OpcodeDescriptionsBCHCHIPs2["OP_OUTPOINTINDEX"] = "Pop the top item from the stack as an input index (VM Number). From that input, push the outpoint index – the index of the output in the transaction that created the Unspent Transaction Output (UTXO) that is being spent – to the stack as a VM Number.";
  OpcodeDescriptionsBCHCHIPs2["OP_INPUTBYTECODE"] = "Pop the top item from the stack as an input index (VM Number). Push the unlocking bytecode of the input at that index to the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_INPUTSEQUENCENUMBER"] = "Pop the top item from the stack as an input index (VM Number). Push the sequence number of the input at that index to the stack as a VM Number.";
  OpcodeDescriptionsBCHCHIPs2["OP_OUTPUTVALUE"] = "Pop the top item from the stack as an output index (VM Number). Push the value (in satoshis) of the output at that index to the stack as a VM Number.";
  OpcodeDescriptionsBCHCHIPs2["OP_OUTPUTBYTECODE"] = "Pop the top item from the stack as an output index (VM Number). Push the locking bytecode of the output at that index to the stack.";
  OpcodeDescriptionsBCHCHIPs2["OP_UTXOTOKENCATEGORY"] = "Pop the top item from the stack as an input index (VM Number). If the Unspent Transaction Output (UTXO) spent by that input includes no tokens, push a 0 (VM Number) to the stack. If the UTXO does not include a non-fungible token with a capability, push the UTXO's token category, otherwise, push the concatenation of the token category and capability, where the mutable capability is represented by 1 (VM Number) and the minting capability is represented by 2 (VM Number).";
  OpcodeDescriptionsBCHCHIPs2["OP_UTXOTOKENCOMMITMENT"] = "Pop the top item from the stack as an input index (VM Number). Push the token commitment of the Unspent Transaction Output (UTXO) spent by that input to the stack. If the UTXO does not include a non-fungible token, or if it includes a non-fungible token with a zero-length commitment, push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs2["OP_UTXOTOKENAMOUNT"] = "Pop the top item from the stack as an input index (VM Number). Push the fungible token amount of the Unspent Transaction Output (UTXO) spent by that input to the stack as a VM Number. If the UTXO includes no fungible tokens, push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs2["OP_OUTPUTTOKENCATEGORY"] = "Pop the top item from the stack as an output index (VM Number). If the output spent by that input includes no tokens, push a 0 (VM Number) to the stack. If the output does not include a non-fungible token with a capability, push the output's token category, otherwise, push the concatenation of the token category and capability, where the mutable capability is represented by 1 (VM Number) and the minting capability is represented by 2 (VM Number).";
  OpcodeDescriptionsBCHCHIPs2["OP_OUTPUTTOKENCOMMITMENT"] = "Pop the top item from the stack as an output index (VM Number). Push the token commitment of the output at that index to the stack. If the output does not include a non-fungible token, or if it includes a non-fungible token with a zero-length commitment, push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs2["OP_OUTPUTTOKENAMOUNT"] = "Pop the top item from the stack as an output index (VM Number). Push the fungible token amount of the output at that index to the stack as a VM Number. If the output includes no fungible tokens, push a 0 (VM Number).";
})(OpcodeDescriptionsBCHCHIPs || (OpcodeDescriptionsBCHCHIPs = {}));

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/bch/chips/bch-chips-instruction-set.js
var import_dist289 = __toESM(require_dist(), 1);
var import_dist290 = __toESM(require_dist2(), 1);
var import_dist291 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/bch/chips/bch-chips-loops.js
var import_dist283 = __toESM(require_dist(), 1);
var import_dist284 = __toESM(require_dist2(), 1);
var import_dist285 = __toESM(require_dist3(), 1);
var executionIsActive2 = (state) => state.controlStack.every((item) => item !== false);
var conditionallyEvaluateChipLoops = (operation) => (state) => executionIsActive2(state) ? operation(state) : state;
var undefinedOperationChipLoops = conditionallyEvaluateChipLoops((state) => applyError(state, AuthenticationErrorCommon.unknownOpcode));
var pushOperationChipLoops = (maximumPushSize = ConsensusCommon.maximumStackItemLength) => (state) => {
  const instruction = state.instructions[state.ip];
  return instruction.data.length > maximumPushSize ? applyError(state, `${AuthenticationErrorCommon.exceededMaximumStackItemLength} Item length: ${instruction.data.length} bytes.`) : executionIsActive2(state) ? isMinimalDataPush(instruction.opcode, instruction.data) ? pushToStack(state, instruction.data) : applyError(state, AuthenticationErrorCommon.nonMinimalPush) : state;
};
var pushToControlStackChipLoops = (state, value) => {
  state.controlStack.push(value);
  return state;
};
var opIfChipLoops = (state) => {
  if (executionIsActive2(state)) {
    return useOneStackItem(state, (nextState, [item]) => pushToControlStackChipLoops(nextState, stackItemIsTruthy(item)));
  }
  return pushToControlStackChipLoops(state, false);
};
var opNotIfChipLoops = (state) => {
  if (executionIsActive2(state)) {
    return useOneStackItem(state, (nextState, [item]) => pushToControlStackChipLoops(nextState, !stackItemIsTruthy(item)));
  }
  return pushToControlStackChipLoops(state, false);
};
var opEndIfChipLoops = (state) => {
  const element = state.controlStack.pop();
  if (typeof element !== "boolean") {
    return applyError(state, AuthenticationErrorCommon.unexpectedEndIf);
  }
  return state;
};
var opElseChipLoops = (state) => {
  const top = state.controlStack[state.controlStack.length - 1];
  if (typeof top !== "boolean") {
    return applyError(state, AuthenticationErrorCommon.unexpectedElse);
  }
  state.controlStack[state.controlStack.length - 1] = !top;
  return state;
};
var opBegin = (state) => pushToControlStackChipLoops(state, state.ip);
var opUntil = (state) => {
  const controlValue = state.controlStack.pop();
  if (typeof controlValue !== "number") {
    return applyError(state, AuthenticationErrorBCHCHIPs.unexpectedUntil);
  }
  state.repeatedBytes += encodeAuthenticationInstructions(state.instructions.slice(controlValue, state.ip)).length;
  const activeBytecodeLength = encodeAuthenticationInstructions(state.instructions).length;
  if (state.repeatedBytes + activeBytecodeLength > ConsensusCommon.maximumBytecodeLength) {
    return applyError(state, AuthenticationErrorBCHCHIPs.excessiveLooping, `Repeated bytes: ${state.repeatedBytes}; active bytecode length: ${activeBytecodeLength}`);
  }
  return useOneStackItem(state, (nextState, [item]) => {
    if (item.length === 1 && item[0] === 1) {
      return nextState;
    }
    nextState.ip = controlValue - 1;
    return nextState;
  });
};

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/bch/chips/bch-chips-opcodes.js
var import_dist286 = __toESM(require_dist(), 1);
var import_dist287 = __toESM(require_dist2(), 1);
var import_dist288 = __toESM(require_dist3(), 1);
var OpcodesBCHCHIPs;
(function(OpcodesBCHCHIPs2) {
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_0"] = 0] = "OP_0";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_1"] = 1] = "OP_PUSHBYTES_1";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_2"] = 2] = "OP_PUSHBYTES_2";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_3"] = 3] = "OP_PUSHBYTES_3";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_4"] = 4] = "OP_PUSHBYTES_4";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_5"] = 5] = "OP_PUSHBYTES_5";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_6"] = 6] = "OP_PUSHBYTES_6";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_7"] = 7] = "OP_PUSHBYTES_7";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_8"] = 8] = "OP_PUSHBYTES_8";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_9"] = 9] = "OP_PUSHBYTES_9";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_10"] = 10] = "OP_PUSHBYTES_10";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_11"] = 11] = "OP_PUSHBYTES_11";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_12"] = 12] = "OP_PUSHBYTES_12";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_13"] = 13] = "OP_PUSHBYTES_13";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_14"] = 14] = "OP_PUSHBYTES_14";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_15"] = 15] = "OP_PUSHBYTES_15";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_16"] = 16] = "OP_PUSHBYTES_16";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_17"] = 17] = "OP_PUSHBYTES_17";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_18"] = 18] = "OP_PUSHBYTES_18";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_19"] = 19] = "OP_PUSHBYTES_19";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_20"] = 20] = "OP_PUSHBYTES_20";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_21"] = 21] = "OP_PUSHBYTES_21";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_22"] = 22] = "OP_PUSHBYTES_22";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_23"] = 23] = "OP_PUSHBYTES_23";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_24"] = 24] = "OP_PUSHBYTES_24";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_25"] = 25] = "OP_PUSHBYTES_25";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_26"] = 26] = "OP_PUSHBYTES_26";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_27"] = 27] = "OP_PUSHBYTES_27";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_28"] = 28] = "OP_PUSHBYTES_28";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_29"] = 29] = "OP_PUSHBYTES_29";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_30"] = 30] = "OP_PUSHBYTES_30";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_31"] = 31] = "OP_PUSHBYTES_31";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_32"] = 32] = "OP_PUSHBYTES_32";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_33"] = 33] = "OP_PUSHBYTES_33";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_34"] = 34] = "OP_PUSHBYTES_34";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_35"] = 35] = "OP_PUSHBYTES_35";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_36"] = 36] = "OP_PUSHBYTES_36";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_37"] = 37] = "OP_PUSHBYTES_37";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_38"] = 38] = "OP_PUSHBYTES_38";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_39"] = 39] = "OP_PUSHBYTES_39";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_40"] = 40] = "OP_PUSHBYTES_40";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_41"] = 41] = "OP_PUSHBYTES_41";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_42"] = 42] = "OP_PUSHBYTES_42";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_43"] = 43] = "OP_PUSHBYTES_43";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_44"] = 44] = "OP_PUSHBYTES_44";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_45"] = 45] = "OP_PUSHBYTES_45";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_46"] = 46] = "OP_PUSHBYTES_46";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_47"] = 47] = "OP_PUSHBYTES_47";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_48"] = 48] = "OP_PUSHBYTES_48";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_49"] = 49] = "OP_PUSHBYTES_49";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_50"] = 50] = "OP_PUSHBYTES_50";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_51"] = 51] = "OP_PUSHBYTES_51";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_52"] = 52] = "OP_PUSHBYTES_52";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_53"] = 53] = "OP_PUSHBYTES_53";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_54"] = 54] = "OP_PUSHBYTES_54";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_55"] = 55] = "OP_PUSHBYTES_55";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_56"] = 56] = "OP_PUSHBYTES_56";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_57"] = 57] = "OP_PUSHBYTES_57";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_58"] = 58] = "OP_PUSHBYTES_58";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_59"] = 59] = "OP_PUSHBYTES_59";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_60"] = 60] = "OP_PUSHBYTES_60";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_61"] = 61] = "OP_PUSHBYTES_61";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_62"] = 62] = "OP_PUSHBYTES_62";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_63"] = 63] = "OP_PUSHBYTES_63";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_64"] = 64] = "OP_PUSHBYTES_64";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_65"] = 65] = "OP_PUSHBYTES_65";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_66"] = 66] = "OP_PUSHBYTES_66";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_67"] = 67] = "OP_PUSHBYTES_67";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_68"] = 68] = "OP_PUSHBYTES_68";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_69"] = 69] = "OP_PUSHBYTES_69";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_70"] = 70] = "OP_PUSHBYTES_70";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_71"] = 71] = "OP_PUSHBYTES_71";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_72"] = 72] = "OP_PUSHBYTES_72";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_73"] = 73] = "OP_PUSHBYTES_73";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_74"] = 74] = "OP_PUSHBYTES_74";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHBYTES_75"] = 75] = "OP_PUSHBYTES_75";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHDATA_1"] = 76] = "OP_PUSHDATA_1";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHDATA_2"] = 77] = "OP_PUSHDATA_2";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PUSHDATA_4"] = 78] = "OP_PUSHDATA_4";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_1NEGATE"] = 79] = "OP_1NEGATE";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_RESERVED"] = 80] = "OP_RESERVED";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_1"] = 81] = "OP_1";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_2"] = 82] = "OP_2";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_3"] = 83] = "OP_3";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_4"] = 84] = "OP_4";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_5"] = 85] = "OP_5";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_6"] = 86] = "OP_6";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_7"] = 87] = "OP_7";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_8"] = 88] = "OP_8";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_9"] = 89] = "OP_9";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_10"] = 90] = "OP_10";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_11"] = 91] = "OP_11";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_12"] = 92] = "OP_12";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_13"] = 93] = "OP_13";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_14"] = 94] = "OP_14";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_15"] = 95] = "OP_15";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_16"] = 96] = "OP_16";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_NOP"] = 97] = "OP_NOP";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_VER"] = 98] = "OP_VER";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_IF"] = 99] = "OP_IF";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_NOTIF"] = 100] = "OP_NOTIF";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_VERIF"] = 101] = "OP_VERIF";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_BEGIN"] = 101] = "OP_BEGIN";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_VERNOTIF"] = 102] = "OP_VERNOTIF";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNTIL"] = 102] = "OP_UNTIL";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_ELSE"] = 103] = "OP_ELSE";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_ENDIF"] = 104] = "OP_ENDIF";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_VERIFY"] = 105] = "OP_VERIFY";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_RETURN"] = 106] = "OP_RETURN";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_TOALTSTACK"] = 107] = "OP_TOALTSTACK";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_FROMALTSTACK"] = 108] = "OP_FROMALTSTACK";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_2DROP"] = 109] = "OP_2DROP";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_2DUP"] = 110] = "OP_2DUP";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_3DUP"] = 111] = "OP_3DUP";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_2OVER"] = 112] = "OP_2OVER";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_2ROT"] = 113] = "OP_2ROT";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_2SWAP"] = 114] = "OP_2SWAP";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_IFDUP"] = 115] = "OP_IFDUP";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_DEPTH"] = 116] = "OP_DEPTH";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_DROP"] = 117] = "OP_DROP";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_DUP"] = 118] = "OP_DUP";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_NIP"] = 119] = "OP_NIP";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_OVER"] = 120] = "OP_OVER";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_PICK"] = 121] = "OP_PICK";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_ROLL"] = 122] = "OP_ROLL";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_ROT"] = 123] = "OP_ROT";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_SWAP"] = 124] = "OP_SWAP";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_TUCK"] = 125] = "OP_TUCK";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_CAT"] = 126] = "OP_CAT";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_SPLIT"] = 127] = "OP_SPLIT";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_NUM2BIN"] = 128] = "OP_NUM2BIN";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_BIN2NUM"] = 129] = "OP_BIN2NUM";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_SIZE"] = 130] = "OP_SIZE";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_INVERT"] = 131] = "OP_INVERT";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_AND"] = 132] = "OP_AND";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_OR"] = 133] = "OP_OR";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_XOR"] = 134] = "OP_XOR";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_EQUAL"] = 135] = "OP_EQUAL";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_EQUALVERIFY"] = 136] = "OP_EQUALVERIFY";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_RESERVED1"] = 137] = "OP_RESERVED1";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_RESERVED2"] = 138] = "OP_RESERVED2";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_1ADD"] = 139] = "OP_1ADD";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_1SUB"] = 140] = "OP_1SUB";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_2MUL"] = 141] = "OP_2MUL";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_2DIV"] = 142] = "OP_2DIV";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_NEGATE"] = 143] = "OP_NEGATE";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_ABS"] = 144] = "OP_ABS";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_NOT"] = 145] = "OP_NOT";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_0EQUAL"] = 145] = "OP_0EQUAL";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_0NOTEQUAL"] = 146] = "OP_0NOTEQUAL";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_ADD"] = 147] = "OP_ADD";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_SUB"] = 148] = "OP_SUB";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_MUL"] = 149] = "OP_MUL";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_DIV"] = 150] = "OP_DIV";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_MOD"] = 151] = "OP_MOD";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_LSHIFT"] = 152] = "OP_LSHIFT";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_RSHIFT"] = 153] = "OP_RSHIFT";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_BOOLAND"] = 154] = "OP_BOOLAND";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_BOOLOR"] = 155] = "OP_BOOLOR";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_NUMEQUAL"] = 156] = "OP_NUMEQUAL";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_NUMEQUALVERIFY"] = 157] = "OP_NUMEQUALVERIFY";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_NUMNOTEQUAL"] = 158] = "OP_NUMNOTEQUAL";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_LESSTHAN"] = 159] = "OP_LESSTHAN";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_GREATERTHAN"] = 160] = "OP_GREATERTHAN";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_LESSTHANOREQUAL"] = 161] = "OP_LESSTHANOREQUAL";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_GREATERTHANOREQUAL"] = 162] = "OP_GREATERTHANOREQUAL";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_MIN"] = 163] = "OP_MIN";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_MAX"] = 164] = "OP_MAX";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_WITHIN"] = 165] = "OP_WITHIN";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_RIPEMD160"] = 166] = "OP_RIPEMD160";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_SHA1"] = 167] = "OP_SHA1";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_SHA256"] = 168] = "OP_SHA256";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_HASH160"] = 169] = "OP_HASH160";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_HASH256"] = 170] = "OP_HASH256";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_CODESEPARATOR"] = 171] = "OP_CODESEPARATOR";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_CHECKSIG"] = 172] = "OP_CHECKSIG";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_CHECKSIGVERIFY"] = 173] = "OP_CHECKSIGVERIFY";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_CHECKMULTISIG"] = 174] = "OP_CHECKMULTISIG";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_CHECKMULTISIGVERIFY"] = 175] = "OP_CHECKMULTISIGVERIFY";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_NOP1"] = 176] = "OP_NOP1";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_CHECKLOCKTIMEVERIFY"] = 177] = "OP_CHECKLOCKTIMEVERIFY";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_CHECKSEQUENCEVERIFY"] = 178] = "OP_CHECKSEQUENCEVERIFY";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_NOP4"] = 179] = "OP_NOP4";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_NOP5"] = 180] = "OP_NOP5";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_NOP6"] = 181] = "OP_NOP6";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_NOP7"] = 182] = "OP_NOP7";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_NOP8"] = 183] = "OP_NOP8";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_NOP9"] = 184] = "OP_NOP9";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_NOP10"] = 185] = "OP_NOP10";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_CHECKDATASIG"] = 186] = "OP_CHECKDATASIG";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_CHECKDATASIGVERIFY"] = 187] = "OP_CHECKDATASIGVERIFY";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_REVERSEBYTES"] = 188] = "OP_REVERSEBYTES";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN189"] = 189] = "OP_UNKNOWN189";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN190"] = 190] = "OP_UNKNOWN190";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN191"] = 191] = "OP_UNKNOWN191";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_INPUTINDEX"] = 192] = "OP_INPUTINDEX";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_ACTIVEBYTECODE"] = 193] = "OP_ACTIVEBYTECODE";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_TXVERSION"] = 194] = "OP_TXVERSION";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_TXINPUTCOUNT"] = 195] = "OP_TXINPUTCOUNT";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_TXOUTPUTCOUNT"] = 196] = "OP_TXOUTPUTCOUNT";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_TXLOCKTIME"] = 197] = "OP_TXLOCKTIME";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UTXOVALUE"] = 198] = "OP_UTXOVALUE";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UTXOBYTECODE"] = 199] = "OP_UTXOBYTECODE";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_OUTPOINTTXHASH"] = 200] = "OP_OUTPOINTTXHASH";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_OUTPOINTINDEX"] = 201] = "OP_OUTPOINTINDEX";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_INPUTBYTECODE"] = 202] = "OP_INPUTBYTECODE";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_INPUTSEQUENCENUMBER"] = 203] = "OP_INPUTSEQUENCENUMBER";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_OUTPUTVALUE"] = 204] = "OP_OUTPUTVALUE";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_OUTPUTBYTECODE"] = 205] = "OP_OUTPUTBYTECODE";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UTXOTOKENCATEGORY"] = 206] = "OP_UTXOTOKENCATEGORY";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UTXOTOKENCOMMITMENT"] = 207] = "OP_UTXOTOKENCOMMITMENT";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UTXOTOKENAMOUNT"] = 208] = "OP_UTXOTOKENAMOUNT";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_OUTPUTTOKENCATEGORY"] = 209] = "OP_OUTPUTTOKENCATEGORY";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_OUTPUTTOKENCOMMITMENT"] = 210] = "OP_OUTPUTTOKENCOMMITMENT";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_OUTPUTTOKENAMOUNT"] = 211] = "OP_OUTPUTTOKENAMOUNT";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN212"] = 212] = "OP_UNKNOWN212";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN213"] = 213] = "OP_UNKNOWN213";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN214"] = 214] = "OP_UNKNOWN214";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN215"] = 215] = "OP_UNKNOWN215";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN216"] = 216] = "OP_UNKNOWN216";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN217"] = 217] = "OP_UNKNOWN217";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN218"] = 218] = "OP_UNKNOWN218";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN219"] = 219] = "OP_UNKNOWN219";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN220"] = 220] = "OP_UNKNOWN220";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN221"] = 221] = "OP_UNKNOWN221";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN222"] = 222] = "OP_UNKNOWN222";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN223"] = 223] = "OP_UNKNOWN223";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN224"] = 224] = "OP_UNKNOWN224";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN225"] = 225] = "OP_UNKNOWN225";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN226"] = 226] = "OP_UNKNOWN226";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN227"] = 227] = "OP_UNKNOWN227";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN228"] = 228] = "OP_UNKNOWN228";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN229"] = 229] = "OP_UNKNOWN229";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN230"] = 230] = "OP_UNKNOWN230";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN231"] = 231] = "OP_UNKNOWN231";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN232"] = 232] = "OP_UNKNOWN232";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN233"] = 233] = "OP_UNKNOWN233";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN234"] = 234] = "OP_UNKNOWN234";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN235"] = 235] = "OP_UNKNOWN235";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN236"] = 236] = "OP_UNKNOWN236";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN237"] = 237] = "OP_UNKNOWN237";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN238"] = 238] = "OP_UNKNOWN238";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN239"] = 239] = "OP_UNKNOWN239";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN240"] = 240] = "OP_UNKNOWN240";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN241"] = 241] = "OP_UNKNOWN241";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN242"] = 242] = "OP_UNKNOWN242";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN243"] = 243] = "OP_UNKNOWN243";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN244"] = 244] = "OP_UNKNOWN244";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN245"] = 245] = "OP_UNKNOWN245";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN246"] = 246] = "OP_UNKNOWN246";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN247"] = 247] = "OP_UNKNOWN247";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN248"] = 248] = "OP_UNKNOWN248";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN249"] = 249] = "OP_UNKNOWN249";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN250"] = 250] = "OP_UNKNOWN250";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN251"] = 251] = "OP_UNKNOWN251";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN252"] = 252] = "OP_UNKNOWN252";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN253"] = 253] = "OP_UNKNOWN253";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN254"] = 254] = "OP_UNKNOWN254";
  OpcodesBCHCHIPs2[OpcodesBCHCHIPs2["OP_UNKNOWN255"] = 255] = "OP_UNKNOWN255";
})(OpcodesBCHCHIPs || (OpcodesBCHCHIPs = {}));

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/bch/chips/bch-chips-instruction-set.js
var createInstructionSetBCHCHIPs = (standard = true, { ripemd160: ripemd1602, secp256k1: secp256k12, sha1: sha12, sha256: sha2562 } = {
  ripemd160,
  secp256k1,
  sha1,
  sha256
}) => {
  const conditionallyPush = pushOperationChipLoops();
  return {
    clone: cloneAuthenticationProgramStateBCHCHIPs,
    continue: (state) => state.error === void 0 && state.ip < state.instructions.length,
    // eslint-disable-next-line complexity
    evaluate: (program, stateEvaluate) => {
      const { unlockingBytecode } = (
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        program.transaction.inputs[program.inputIndex]
      );
      const { lockingBytecode } = program.sourceOutputs[program.inputIndex];
      const unlockingInstructions = decodeAuthenticationInstructions(unlockingBytecode);
      const lockingInstructions = decodeAuthenticationInstructions(lockingBytecode);
      const initialState = createAuthenticationProgramStateBCHCHIPs({
        instructions: unlockingInstructions,
        program,
        stack: []
      });
      if (unlockingBytecode.length > ConsensusBCH.maximumBytecodeLength) {
        return applyError(initialState, `The provided unlocking bytecode (${unlockingBytecode.length} bytes) exceeds the maximum bytecode length (${ConsensusBCH.maximumBytecodeLength} bytes).`);
      }
      if (authenticationInstructionsAreMalformed(unlockingInstructions)) {
        return applyError(initialState, AuthenticationErrorCommon.malformedUnlockingBytecode);
      }
      if (!isPushOnly(unlockingBytecode)) {
        return applyError(initialState, AuthenticationErrorCommon.requiresPushOnly);
      }
      if (lockingBytecode.length > ConsensusBCH.maximumBytecodeLength) {
        return applyError(initialState, AuthenticationErrorCommon.exceededMaximumBytecodeLengthLocking);
      }
      if (authenticationInstructionsAreMalformed(lockingInstructions)) {
        return applyError(initialState, AuthenticationErrorCommon.malformedLockingBytecode);
      }
      const unlockingResult = stateEvaluate(initialState);
      if (unlockingResult.error !== void 0) {
        return unlockingResult;
      }
      if (unlockingResult.controlStack.length !== 0) {
        return applyError(initialState, AuthenticationErrorCommon.nonEmptyControlStack);
      }
      const lockingResult = stateEvaluate(createAuthenticationProgramStateBCHCHIPs({
        instructions: lockingInstructions,
        program,
        stack: unlockingResult.stack
      }));
      if (!isPayToScriptHash20(lockingBytecode)) {
        return lockingResult;
      }
      const p2shStack = cloneStack(unlockingResult.stack);
      const p2shScript = p2shStack.pop() ?? Uint8Array.of();
      if (p2shStack.length === 0 && isWitnessProgram(p2shScript)) {
        return lockingResult;
      }
      const p2shInstructions = decodeAuthenticationInstructions(p2shScript);
      return authenticationInstructionsAreMalformed(p2shInstructions) ? {
        ...lockingResult,
        error: AuthenticationErrorCommon.malformedP2shBytecode
      } : stateEvaluate(createAuthenticationProgramStateBCHCHIPs({
        instructions: p2shInstructions,
        program,
        stack: p2shStack
      }));
    },
    every: (state) => {
      if (state.stack.length + state.alternateStack.length > ConsensusBCH.maximumStackDepth) {
        return applyError(state, AuthenticationErrorCommon.exceededMaximumStackDepth);
      }
      return state;
    },
    operations: {
      [OpcodesBCHCHIPs.OP_0]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_1]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_2]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_3]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_4]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_5]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_6]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_7]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_8]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_9]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_10]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_11]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_12]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_13]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_14]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_15]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_16]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_17]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_18]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_19]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_20]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_21]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_22]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_23]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_24]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_25]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_26]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_27]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_28]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_29]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_30]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_31]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_32]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_33]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_34]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_35]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_36]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_37]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_38]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_39]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_40]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_41]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_42]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_43]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_44]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_45]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_46]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_47]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_48]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_49]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_50]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_51]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_52]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_53]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_54]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_55]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_56]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_57]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_58]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_59]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_60]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_61]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_62]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_63]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_64]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_65]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_66]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_67]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_68]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_69]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_70]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_71]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_72]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_73]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_74]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHBYTES_75]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHDATA_1]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHDATA_2]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_PUSHDATA_4]: conditionallyPush,
      [OpcodesBCHCHIPs.OP_1NEGATE]: conditionallyEvaluateChipLoops(pushNumberOperation(-1)),
      [OpcodesBCHCHIPs.OP_RESERVED]: conditionallyEvaluateChipLoops(reservedOperation),
      [OpcodesBCHCHIPs.OP_1]: conditionallyEvaluateChipLoops(pushNumberOperation(1)),
      /* eslint-disable @typescript-eslint/no-magic-numbers */
      [OpcodesBCHCHIPs.OP_2]: conditionallyEvaluateChipLoops(pushNumberOperation(2)),
      [OpcodesBCHCHIPs.OP_3]: conditionallyEvaluateChipLoops(pushNumberOperation(3)),
      [OpcodesBCHCHIPs.OP_4]: conditionallyEvaluateChipLoops(pushNumberOperation(4)),
      [OpcodesBCHCHIPs.OP_5]: conditionallyEvaluateChipLoops(pushNumberOperation(5)),
      [OpcodesBCHCHIPs.OP_6]: conditionallyEvaluateChipLoops(pushNumberOperation(6)),
      [OpcodesBCHCHIPs.OP_7]: conditionallyEvaluateChipLoops(pushNumberOperation(7)),
      [OpcodesBCHCHIPs.OP_8]: conditionallyEvaluateChipLoops(pushNumberOperation(8)),
      [OpcodesBCHCHIPs.OP_9]: conditionallyEvaluateChipLoops(pushNumberOperation(9)),
      [OpcodesBCHCHIPs.OP_10]: conditionallyEvaluateChipLoops(pushNumberOperation(10)),
      [OpcodesBCHCHIPs.OP_11]: conditionallyEvaluateChipLoops(pushNumberOperation(11)),
      [OpcodesBCHCHIPs.OP_12]: conditionallyEvaluateChipLoops(pushNumberOperation(12)),
      [OpcodesBCHCHIPs.OP_13]: conditionallyEvaluateChipLoops(pushNumberOperation(13)),
      [OpcodesBCHCHIPs.OP_14]: conditionallyEvaluateChipLoops(pushNumberOperation(14)),
      [OpcodesBCHCHIPs.OP_15]: conditionallyEvaluateChipLoops(pushNumberOperation(15)),
      [OpcodesBCHCHIPs.OP_16]: conditionallyEvaluateChipLoops(pushNumberOperation(16)),
      /* eslint-enable @typescript-eslint/no-magic-numbers */
      [OpcodesBCHCHIPs.OP_NOP]: conditionallyEvaluateChipLoops(opNop),
      [OpcodesBCHCHIPs.OP_VER]: conditionallyEvaluateChipLoops(reservedOperation),
      [OpcodesBCHCHIPs.OP_IF]: opIfChipLoops,
      [OpcodesBCHCHIPs.OP_NOTIF]: opNotIfChipLoops,
      [OpcodesBCHCHIPs.OP_BEGIN]: conditionallyEvaluateChipLoops(opBegin),
      [OpcodesBCHCHIPs.OP_UNTIL]: conditionallyEvaluateChipLoops(opUntil),
      [OpcodesBCHCHIPs.OP_ELSE]: opElseChipLoops,
      [OpcodesBCHCHIPs.OP_ENDIF]: opEndIfChipLoops,
      [OpcodesBCHCHIPs.OP_VERIFY]: conditionallyEvaluateChipLoops(opVerify),
      [OpcodesBCHCHIPs.OP_RETURN]: conditionallyEvaluateChipLoops(opReturn),
      [OpcodesBCHCHIPs.OP_TOALTSTACK]: conditionallyEvaluateChipLoops(opToAltStack),
      [OpcodesBCHCHIPs.OP_FROMALTSTACK]: conditionallyEvaluateChipLoops(opFromAltStack),
      [OpcodesBCHCHIPs.OP_2DROP]: conditionallyEvaluateChipLoops(op2Drop),
      [OpcodesBCHCHIPs.OP_2DUP]: conditionallyEvaluateChipLoops(op2Dup),
      [OpcodesBCHCHIPs.OP_3DUP]: conditionallyEvaluateChipLoops(op3Dup),
      [OpcodesBCHCHIPs.OP_2OVER]: conditionallyEvaluateChipLoops(op2Over),
      [OpcodesBCHCHIPs.OP_2ROT]: conditionallyEvaluateChipLoops(op2Rot),
      [OpcodesBCHCHIPs.OP_2SWAP]: conditionallyEvaluateChipLoops(op2Swap),
      [OpcodesBCHCHIPs.OP_IFDUP]: conditionallyEvaluateChipLoops(opIfDup),
      [OpcodesBCHCHIPs.OP_DEPTH]: conditionallyEvaluateChipLoops(opDepth),
      [OpcodesBCHCHIPs.OP_DROP]: conditionallyEvaluateChipLoops(opDrop),
      [OpcodesBCHCHIPs.OP_DUP]: conditionallyEvaluateChipLoops(opDup),
      [OpcodesBCHCHIPs.OP_NIP]: conditionallyEvaluateChipLoops(opNip),
      [OpcodesBCHCHIPs.OP_OVER]: conditionallyEvaluateChipLoops(opOver),
      [OpcodesBCHCHIPs.OP_PICK]: conditionallyEvaluateChipLoops(opPick),
      [OpcodesBCHCHIPs.OP_ROLL]: conditionallyEvaluateChipLoops(opRoll),
      [OpcodesBCHCHIPs.OP_ROT]: conditionallyEvaluateChipLoops(opRot),
      [OpcodesBCHCHIPs.OP_SWAP]: conditionallyEvaluateChipLoops(opSwap),
      [OpcodesBCHCHIPs.OP_TUCK]: conditionallyEvaluateChipLoops(opTuck),
      [OpcodesBCHCHIPs.OP_CAT]: conditionallyEvaluateChipLoops(opCat),
      [OpcodesBCHCHIPs.OP_SPLIT]: conditionallyEvaluateChipLoops(opSplit),
      [OpcodesBCHCHIPs.OP_NUM2BIN]: conditionallyEvaluateChipLoops(opNum2Bin),
      [OpcodesBCHCHIPs.OP_BIN2NUM]: conditionallyEvaluateChipLoops(opBin2Num),
      [OpcodesBCHCHIPs.OP_SIZE]: conditionallyEvaluateChipLoops(opSize),
      [OpcodesBCHCHIPs.OP_INVERT]: disabledOperation,
      [OpcodesBCHCHIPs.OP_AND]: conditionallyEvaluateChipLoops(opAnd),
      [OpcodesBCHCHIPs.OP_OR]: conditionallyEvaluateChipLoops(opOr),
      [OpcodesBCHCHIPs.OP_XOR]: conditionallyEvaluateChipLoops(opXor),
      [OpcodesBCHCHIPs.OP_EQUAL]: conditionallyEvaluateChipLoops(opEqual),
      [OpcodesBCHCHIPs.OP_EQUALVERIFY]: conditionallyEvaluateChipLoops(opEqualVerify),
      [OpcodesBCHCHIPs.OP_RESERVED1]: conditionallyEvaluateChipLoops(reservedOperation),
      [OpcodesBCHCHIPs.OP_RESERVED2]: conditionallyEvaluateChipLoops(reservedOperation),
      [OpcodesBCHCHIPs.OP_1ADD]: conditionallyEvaluateChipLoops(op1Add),
      [OpcodesBCHCHIPs.OP_1SUB]: conditionallyEvaluateChipLoops(op1Sub),
      [OpcodesBCHCHIPs.OP_2MUL]: disabledOperation,
      [OpcodesBCHCHIPs.OP_2DIV]: disabledOperation,
      [OpcodesBCHCHIPs.OP_NEGATE]: conditionallyEvaluateChipLoops(opNegate),
      [OpcodesBCHCHIPs.OP_ABS]: conditionallyEvaluateChipLoops(opAbs),
      [OpcodesBCHCHIPs.OP_NOT]: conditionallyEvaluateChipLoops(opNot),
      [OpcodesBCHCHIPs.OP_0NOTEQUAL]: conditionallyEvaluateChipLoops(op0NotEqual),
      [OpcodesBCHCHIPs.OP_ADD]: conditionallyEvaluateChipLoops(opAdd),
      [OpcodesBCHCHIPs.OP_SUB]: conditionallyEvaluateChipLoops(opSub),
      [OpcodesBCHCHIPs.OP_MUL]: conditionallyEvaluateChipLoops(opMul),
      [OpcodesBCHCHIPs.OP_DIV]: conditionallyEvaluateChipLoops(opDiv),
      [OpcodesBCHCHIPs.OP_MOD]: conditionallyEvaluateChipLoops(opMod),
      [OpcodesBCHCHIPs.OP_LSHIFT]: disabledOperation,
      [OpcodesBCHCHIPs.OP_RSHIFT]: disabledOperation,
      [OpcodesBCHCHIPs.OP_BOOLAND]: conditionallyEvaluateChipLoops(opBoolAnd),
      [OpcodesBCHCHIPs.OP_BOOLOR]: conditionallyEvaluateChipLoops(opBoolOr),
      [OpcodesBCHCHIPs.OP_NUMEQUAL]: conditionallyEvaluateChipLoops(opNumEqual),
      [OpcodesBCHCHIPs.OP_NUMEQUALVERIFY]: conditionallyEvaluateChipLoops(opNumEqualVerify),
      [OpcodesBCHCHIPs.OP_NUMNOTEQUAL]: conditionallyEvaluateChipLoops(opNumNotEqual),
      [OpcodesBCHCHIPs.OP_LESSTHAN]: conditionallyEvaluateChipLoops(opLessThan),
      [OpcodesBCHCHIPs.OP_GREATERTHAN]: conditionallyEvaluateChipLoops(opGreaterThan),
      [OpcodesBCHCHIPs.OP_LESSTHANOREQUAL]: conditionallyEvaluateChipLoops(opLessThanOrEqual),
      [OpcodesBCHCHIPs.OP_GREATERTHANOREQUAL]: conditionallyEvaluateChipLoops(opGreaterThanOrEqual),
      [OpcodesBCHCHIPs.OP_MIN]: conditionallyEvaluateChipLoops(opMin),
      [OpcodesBCHCHIPs.OP_MAX]: conditionallyEvaluateChipLoops(opMax),
      [OpcodesBCHCHIPs.OP_WITHIN]: conditionallyEvaluateChipLoops(opWithin),
      [OpcodesBCHCHIPs.OP_RIPEMD160]: conditionallyEvaluateChipLoops(opRipemd160({ ripemd160: ripemd1602 })),
      [OpcodesBCHCHIPs.OP_SHA1]: conditionallyEvaluateChipLoops(opSha1({ sha1: sha12 })),
      [OpcodesBCHCHIPs.OP_SHA256]: conditionallyEvaluateChipLoops(opSha256({ sha256: sha2562 })),
      [OpcodesBCHCHIPs.OP_HASH160]: conditionallyEvaluateChipLoops(opHash160({ ripemd160: ripemd1602, sha256: sha2562 })),
      [OpcodesBCHCHIPs.OP_HASH256]: conditionallyEvaluateChipLoops(opHash256({ sha256: sha2562 })),
      [OpcodesBCHCHIPs.OP_CODESEPARATOR]: conditionallyEvaluateChipLoops(opCodeSeparator),
      [OpcodesBCHCHIPs.OP_CHECKSIG]: conditionallyEvaluateChipLoops(opCheckSigChipLimits({ secp256k1: secp256k12, sha256: sha2562 })),
      [OpcodesBCHCHIPs.OP_CHECKSIGVERIFY]: conditionallyEvaluateChipLoops(opCheckSigVerifyChipLimits({ secp256k1: secp256k12, sha256: sha2562 })),
      [OpcodesBCHCHIPs.OP_CHECKMULTISIG]: conditionallyEvaluateChipLoops(opCheckMultiSigChipLimits({ secp256k1: secp256k12, sha256: sha2562 })),
      [OpcodesBCHCHIPs.OP_CHECKMULTISIGVERIFY]: conditionallyEvaluateChipLoops(opCheckMultiSigVerifyChipLimits({ secp256k1: secp256k12, sha256: sha2562 })),
      ...standard ? {
        [OpcodesBCHCHIPs.OP_NOP1]: conditionallyEvaluateChipLoops(opNopDisallowed),
        [OpcodesBCHCHIPs.OP_CHECKLOCKTIMEVERIFY]: conditionallyEvaluateChipLoops(opCheckLockTimeVerify),
        [OpcodesBCHCHIPs.OP_CHECKSEQUENCEVERIFY]: conditionallyEvaluateChipLoops(opCheckSequenceVerify),
        [OpcodesBCHCHIPs.OP_NOP4]: conditionallyEvaluateChipLoops(opNopDisallowed),
        [OpcodesBCHCHIPs.OP_NOP5]: conditionallyEvaluateChipLoops(opNopDisallowed),
        [OpcodesBCHCHIPs.OP_NOP6]: conditionallyEvaluateChipLoops(opNopDisallowed),
        [OpcodesBCHCHIPs.OP_NOP7]: conditionallyEvaluateChipLoops(opNopDisallowed),
        [OpcodesBCHCHIPs.OP_NOP8]: conditionallyEvaluateChipLoops(opNopDisallowed),
        [OpcodesBCHCHIPs.OP_NOP9]: conditionallyEvaluateChipLoops(opNopDisallowed),
        [OpcodesBCHCHIPs.OP_NOP10]: conditionallyEvaluateChipLoops(opNopDisallowed)
      } : {
        [OpcodesBCHCHIPs.OP_NOP1]: conditionallyEvaluateChipLoops(opNop),
        [OpcodesBCHCHIPs.OP_CHECKLOCKTIMEVERIFY]: conditionallyEvaluateChipLoops(opCheckLockTimeVerify),
        [OpcodesBCHCHIPs.OP_CHECKSEQUENCEVERIFY]: conditionallyEvaluateChipLoops(opCheckSequenceVerify),
        [OpcodesBCHCHIPs.OP_NOP4]: conditionallyEvaluateChipLoops(opNop),
        [OpcodesBCHCHIPs.OP_NOP5]: conditionallyEvaluateChipLoops(opNop),
        [OpcodesBCHCHIPs.OP_NOP6]: conditionallyEvaluateChipLoops(opNop),
        [OpcodesBCHCHIPs.OP_NOP7]: conditionallyEvaluateChipLoops(opNop),
        [OpcodesBCHCHIPs.OP_NOP8]: conditionallyEvaluateChipLoops(opNop),
        [OpcodesBCHCHIPs.OP_NOP9]: conditionallyEvaluateChipLoops(opNop),
        [OpcodesBCHCHIPs.OP_NOP10]: conditionallyEvaluateChipLoops(opNop)
      },
      [OpcodesBCHCHIPs.OP_CHECKDATASIG]: conditionallyEvaluateChipLoops(opCheckDataSig({ secp256k1: secp256k12, sha256: sha2562 })),
      [OpcodesBCHCHIPs.OP_CHECKDATASIGVERIFY]: conditionallyEvaluateChipLoops(opCheckDataSigVerify({ secp256k1: secp256k12, sha256: sha2562 })),
      [OpcodesBCHCHIPs.OP_REVERSEBYTES]: conditionallyEvaluateChipLoops(opReverseBytes),
      [OpcodesBCHCHIPs.OP_INPUTINDEX]: conditionallyEvaluateChipLoops(opInputIndex),
      [OpcodesBCHCHIPs.OP_ACTIVEBYTECODE]: conditionallyEvaluateChipLoops(opActiveBytecode),
      [OpcodesBCHCHIPs.OP_TXVERSION]: conditionallyEvaluateChipLoops(opTxVersion),
      [OpcodesBCHCHIPs.OP_TXINPUTCOUNT]: conditionallyEvaluateChipLoops(opTxInputCount),
      [OpcodesBCHCHIPs.OP_TXOUTPUTCOUNT]: conditionallyEvaluateChipLoops(opTxOutputCount),
      [OpcodesBCHCHIPs.OP_TXLOCKTIME]: conditionallyEvaluateChipLoops(opTxLocktime),
      [OpcodesBCHCHIPs.OP_UTXOVALUE]: conditionallyEvaluateChipLoops(opUtxoValue),
      [OpcodesBCHCHIPs.OP_UTXOBYTECODE]: conditionallyEvaluateChipLoops(opUtxoBytecode),
      [OpcodesBCHCHIPs.OP_OUTPOINTTXHASH]: conditionallyEvaluateChipLoops(opOutpointTxHash),
      [OpcodesBCHCHIPs.OP_OUTPOINTINDEX]: conditionallyEvaluateChipLoops(opOutpointIndex),
      [OpcodesBCHCHIPs.OP_INPUTBYTECODE]: conditionallyEvaluateChipLoops(opInputBytecode),
      [OpcodesBCHCHIPs.OP_INPUTSEQUENCENUMBER]: conditionallyEvaluateChipLoops(opInputSequenceNumber),
      [OpcodesBCHCHIPs.OP_OUTPUTVALUE]: conditionallyEvaluateChipLoops(opOutputValue),
      [OpcodesBCHCHIPs.OP_OUTPUTBYTECODE]: conditionallyEvaluateChipLoops(opOutputBytecode),
      [OpcodesBCHCHIPs.OP_UTXOTOKENCATEGORY]: conditionallyEvaluateChipLoops(opUtxoTokenCategory),
      [OpcodesBCHCHIPs.OP_UTXOTOKENCOMMITMENT]: conditionallyEvaluateChipLoops(opUtxoTokenCommitment),
      [OpcodesBCHCHIPs.OP_UTXOTOKENAMOUNT]: conditionallyEvaluateChipLoops(opUtxoTokenAmount),
      [OpcodesBCHCHIPs.OP_OUTPUTTOKENCATEGORY]: conditionallyEvaluateChipLoops(opOutputTokenCategory),
      [OpcodesBCHCHIPs.OP_OUTPUTTOKENCOMMITMENT]: conditionallyEvaluateChipLoops(opOutputTokenCommitment),
      [OpcodesBCHCHIPs.OP_OUTPUTTOKENAMOUNT]: conditionallyEvaluateChipLoops(opOutputTokenAmount)
    },
    success: (state) => {
      if (state.error !== void 0) {
        return state.error;
      }
      if (state.controlStack.length !== 0) {
        return AuthenticationErrorCommon.nonEmptyControlStack;
      }
      if (state.stack.length !== 1) {
        return AuthenticationErrorCommon.requiresCleanStack;
      }
      if (!stackItemIsTruthy(state.stack[0])) {
        return AuthenticationErrorCommon.unsuccessfulEvaluation;
      }
      return true;
    },
    undefined: undefinedOperationChipLoops,
    // eslint-disable-next-line complexity
    verify: ({ sourceOutputs, transaction }, evaluate, stateSuccess) => {
      if (transaction.inputs.length === 0) {
        return "Transactions must have at least one input.";
      }
      if (transaction.outputs.length === 0) {
        return "Transactions must have at least one output.";
      }
      if (transaction.inputs.length !== sourceOutputs.length) {
        return "Unable to verify transaction: a single spent output must be provided for each transaction input.";
      }
      const transactionSize = encodeTransactionBCH(transaction).length;
      if (transactionSize < ConsensusBCH.minimumTransactionSize) {
        return `Transaction does not meet minimum size: the transaction is ${transactionSize} bytes, but the minimum transaction size is ${ConsensusBCH.minimumTransactionSize} bytes.`;
      }
      if (transactionSize > ConsensusBCH.maximumTransactionSize) {
        return `Transaction exceeds maximum size: the transaction is ${transactionSize} bytes, but the maximum transaction size is ${ConsensusBCH.maximumTransactionSize} bytes.`;
      }
      if (standard) {
        if (transaction.version < 1 || transaction.version > ConsensusBCH.maximumStandardVersion) {
          return `Standard transactions must have a version no less than 1 and no greater than ${ConsensusBCH.maximumStandardVersion}.`;
        }
        if (transactionSize > ConsensusBCH.maximumStandardTransactionSize) {
          return `Transaction exceeds maximum standard size: this transaction is ${transactionSize} bytes, but the maximum standard transaction size is ${ConsensusBCH.maximumStandardTransactionSize} bytes.`;
        }
        for (const [index2, output] of sourceOutputs.entries()) {
          if (!isStandardOutputBytecode(output.lockingBytecode)) {
            return `Standard transactions may only spend standard output types, but source output ${index2} is non-standard.`;
          }
        }
        let totalArbitraryDataBytes = 0;
        for (const [index2, output] of transaction.outputs.entries()) {
          if (!isStandardOutputBytecode(output.lockingBytecode)) {
            return `Standard transactions may only create standard output types, but transaction output ${index2} is non-standard.`;
          }
          if (isArbitraryDataOutput(output.lockingBytecode)) {
            totalArbitraryDataBytes += output.lockingBytecode.length + 1;
          }
        }
        if (totalArbitraryDataBytes > ConsensusBCH.maximumDataCarrierBytes) {
          return `Standard transactions may carry no more than ${ConsensusBCH.maximumDataCarrierBytes} bytes in arbitrary data outputs; this transaction includes ${totalArbitraryDataBytes} bytes of arbitrary data.`;
        }
        for (const [index2, input] of transaction.inputs.entries()) {
          if (input.unlockingBytecode.length > ConsensusBCH.maximumStandardUnlockingBytecodeLength) {
            return `Input index ${index2} is non-standard: the unlocking bytecode (${input.unlockingBytecode.length} bytes) exceeds the maximum standard unlocking bytecode length (${ConsensusBCH.maximumStandardUnlockingBytecodeLength} bytes).`;
          }
          if (!isPushOnly(input.unlockingBytecode)) {
            return `Input index ${index2} is non-standard: unlocking bytecode may contain only push operations.`;
          }
        }
      }
      for (const index2 of transaction.inputs.keys()) {
        const state = evaluate({
          inputIndex: index2,
          sourceOutputs,
          transaction
        });
        const result = stateSuccess(state);
        if (typeof result === "string") {
          return `Error in evaluating input index ${index2}: ${result}`;
        }
      }
      return true;
    }
  };
};

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/bch/chips/bch-chips-vm.js
var import_dist292 = __toESM(require_dist(), 1);
var import_dist293 = __toESM(require_dist2(), 1);
var import_dist294 = __toESM(require_dist3(), 1);
var createVirtualMachineBCHCHIPs = (standard = true) => createAuthenticationVirtualMachine(createInstructionSetBCHCHIPs(standard));

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/btc/btc.js
var import_dist304 = __toESM(require_dist(), 1);
var import_dist305 = __toESM(require_dist2(), 1);
var import_dist306 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/btc/btc-descriptions.js
var import_dist298 = __toESM(require_dist(), 1);
var import_dist299 = __toESM(require_dist2(), 1);
var import_dist300 = __toESM(require_dist3(), 1);
var OpcodeDescriptionsBTC;
(function(OpcodeDescriptionsBTC2) {
  OpcodeDescriptionsBTC2["OP_0"] = "Push the VM Number 0 onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_1"] = "Push the next byte onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_2"] = "Push the next 2 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_3"] = "Push the next 3 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_4"] = "Push the next 4 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_5"] = "Push the next 5 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_6"] = "Push the next 6 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_7"] = "Push the next 7 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_8"] = "Push the next 8 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_9"] = "Push the next 9 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_10"] = "Push the next 10 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_11"] = "Push the next 11 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_12"] = "Push the next 12 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_13"] = "Push the next 13 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_14"] = "Push the next 14 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_15"] = "Push the next 15 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_16"] = "Push the next 16 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_17"] = "Push the next 17 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_18"] = "Push the next 18 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_19"] = "Push the next 19 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_20"] = "Push the next 20 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_21"] = "Push the next 21 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_22"] = "Push the next 22 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_23"] = "Push the next 23 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_24"] = "Push the next 24 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_25"] = "Push the next 25 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_26"] = "Push the next 26 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_27"] = "Push the next 27 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_28"] = "Push the next 28 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_29"] = "Push the next 29 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_30"] = "Push the next 30 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_31"] = "Push the next 31 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_32"] = "Push the next 32 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_33"] = "Push the next 33 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_34"] = "Push the next 34 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_35"] = "Push the next 35 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_36"] = "Push the next 36 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_37"] = "Push the next 37 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_38"] = "Push the next 38 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_39"] = "Push the next 39 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_40"] = "Push the next 40 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_41"] = "Push the next 41 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_42"] = "Push the next 42 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_43"] = "Push the next 43 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_44"] = "Push the next 44 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_45"] = "Push the next 45 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_46"] = "Push the next 46 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_47"] = "Push the next 47 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_48"] = "Push the next 48 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_49"] = "Push the next 49 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_50"] = "Push the next 50 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_51"] = "Push the next 51 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_52"] = "Push the next 52 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_53"] = "Push the next 53 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_54"] = "Push the next 54 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_55"] = "Push the next 55 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_56"] = "Push the next 56 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_57"] = "Push the next 57 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_58"] = "Push the next 58 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_59"] = "Push the next 59 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_60"] = "Push the next 60 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_61"] = "Push the next 61 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_62"] = "Push the next 62 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_63"] = "Push the next 63 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_64"] = "Push the next 64 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_65"] = "Push the next 65 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_66"] = "Push the next 66 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_67"] = "Push the next 67 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_68"] = "Push the next 68 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_69"] = "Push the next 69 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_70"] = "Push the next 70 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_71"] = "Push the next 71 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_72"] = "Push the next 72 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_73"] = "Push the next 73 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_74"] = "Push the next 74 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHBYTES_75"] = "Push the next 75 bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHDATA_1"] = "Read the next Uint8 and push that number of bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHDATA_2"] = "Read the next little-endian Uint16 and push that number of bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_PUSHDATA_4"] = "Read the next little-endian Uint32 and push that number of bytes onto the stack.";
  OpcodeDescriptionsBTC2["OP_1NEGATE"] = "Push the VM Number -1 onto the stack.";
  OpcodeDescriptionsBTC2["OP_RESERVED"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED does not count toward the opcode limit.";
  OpcodeDescriptionsBTC2["OP_1"] = "Push a 1 (VM Number) onto the stack.";
  OpcodeDescriptionsBTC2["OP_2"] = "Push a 2 (VM Number) onto the stack.";
  OpcodeDescriptionsBTC2["OP_3"] = "Push a 3 (VM Number) onto the stack.";
  OpcodeDescriptionsBTC2["OP_4"] = "Push a 4 (VM Number) onto the stack.";
  OpcodeDescriptionsBTC2["OP_5"] = "Push a 5 (VM Number) onto the stack.";
  OpcodeDescriptionsBTC2["OP_6"] = "Push a 6 (VM Number) onto the stack.";
  OpcodeDescriptionsBTC2["OP_7"] = "Push a 7 (VM Number) onto the stack.";
  OpcodeDescriptionsBTC2["OP_8"] = "Push a 8 (VM Number) onto the stack.";
  OpcodeDescriptionsBTC2["OP_9"] = "Push a 9 (VM Number) onto the stack.";
  OpcodeDescriptionsBTC2["OP_10"] = "Push a 10 (VM Number) onto the stack.";
  OpcodeDescriptionsBTC2["OP_11"] = "Push a 11 (VM Number) onto the stack.";
  OpcodeDescriptionsBTC2["OP_12"] = "Push a 12 (VM Number) onto the stack.";
  OpcodeDescriptionsBTC2["OP_13"] = "Push a 13 (VM Number) onto the stack.";
  OpcodeDescriptionsBTC2["OP_14"] = "Push a 14 (VM Number) onto the stack.";
  OpcodeDescriptionsBTC2["OP_15"] = "Push a 15 (VM Number) onto the stack.";
  OpcodeDescriptionsBTC2["OP_16"] = "Push a 16 (VM Number) onto the stack.";
  OpcodeDescriptionsBTC2["OP_NOP"] = "No operation. Note: OP_NOP counts toward the opcode limit.";
  OpcodeDescriptionsBTC2["OP_VER"] = "Error unless found in an unexecuted conditional branch. Note: OP_VER counts toward the opcode limit. (Historically, this pushed a protocol version number to the stack.)";
  OpcodeDescriptionsBTC2["OP_IF"] = 'Pop the top item from the stack. If it is not "truthy", skip evaluation until a matching OP_ELSE or OP_ENDIF.';
  OpcodeDescriptionsBTC2["OP_NOTIF"] = 'Pop the top item from the stack. If it is "truthy", skip evaluation until a matching OP_ELSE or OP_ENDIF.';
  OpcodeDescriptionsBTC2["OP_VERIF"] = "Error, even when found in an unexecuted conditional branch. (Historically, this was a combination of OP_VER and OP_IF.)";
  OpcodeDescriptionsBTC2["OP_VERNOTIF"] = "Error, even when found in an unexecuted conditional branch. (Historically, this was a combination of OP_VER and OP_NOTIF.)";
  OpcodeDescriptionsBTC2["OP_ELSE"] = "Invert conditional evaluation within the current OP_IF ... OP_ENDIF block. (If evaluation is enabled, disable it, if it is disabled, enable it.)";
  OpcodeDescriptionsBTC2["OP_ENDIF"] = "End the current OP_IF/OP_NOTIF ... OP_ENDIF block.";
  OpcodeDescriptionsBTC2["OP_VERIFY"] = `Pop the top item from the stack and error if it isn't "truthy".`;
  OpcodeDescriptionsBTC2["OP_RETURN"] = "Error when executed.";
  OpcodeDescriptionsBTC2["OP_TOALTSTACK"] = "Pop the top item from the stack and push it onto the alternate stack.";
  OpcodeDescriptionsBTC2["OP_FROMALTSTACK"] = "Pop the top item from the alternate stack and push it onto the stack.";
  OpcodeDescriptionsBTC2["OP_2DROP"] = "Pop the top 2 items from the stack and discard them.";
  OpcodeDescriptionsBTC2["OP_2DUP"] = "Duplicate the top 2 items on the stack. (E.g. [a, b] -> [a, b, a, b])";
  OpcodeDescriptionsBTC2["OP_3DUP"] = "Duplicate the top 3 items on the stack. (E.g. [a, b, c] -> [a, b, c, a, b, c])";
  OpcodeDescriptionsBTC2["OP_2OVER"] = "Duplicate the 2 items beginning at a depth of 2 on the stack. (E.g. [a, b, c, d] -> [a, b, c, d, a, b])";
  OpcodeDescriptionsBTC2["OP_2ROT"] = "Rotate the top 6 items on the stack, bringing the fifth and sixth items to the top. (E.g. [a, b, c, d, e, f] -> [c, d, e, f, a, b])";
  OpcodeDescriptionsBTC2["OP_2SWAP"] = "Swap the positions of the top two pairs of items on the stack. (E.g. [a, b, c, d] -> [c, d, a, b])";
  OpcodeDescriptionsBTC2["OP_IFDUP"] = 'If the top item on the stack is "truthy", duplicate it.';
  OpcodeDescriptionsBTC2["OP_DEPTH"] = "Push the current number of stack items as a VM Number.";
  OpcodeDescriptionsBTC2["OP_DROP"] = "Pop the top item from the stack and discard it. (E.g. [a] -> [])";
  OpcodeDescriptionsBTC2["OP_DUP"] = "Duplicate the top item on the stack. (E.g. [a] -> [a, a])";
  OpcodeDescriptionsBTC2["OP_NIP"] = "Remove the second-to-top item from the stack. (E.g. [a, b] -> [b])";
  OpcodeDescriptionsBTC2["OP_OVER"] = "Duplicate the second-to-top item on the stack. (E.g. [a, b] -> [a, b, a])";
  OpcodeDescriptionsBTC2["OP_PICK"] = "Pop the top item from the stack as a VM Number. Duplicate the item at that depth (zero-indexed), placing it on top of the stack. (E.g. [a, b, c, 2] -> [a, b, c, a])";
  OpcodeDescriptionsBTC2["OP_ROLL"] = "Pop the top item from the stack as a VM Number. Move the item at that depth (zero-indexed) to the top of the stack. (E.g. [a, b, c, 2] -> [b, c, a])";
  OpcodeDescriptionsBTC2["OP_ROT"] = "Rotate the top 3 items on the stack, bringing the third item to the top. (E.g. [a, b, c] -> [b, c, a])";
  OpcodeDescriptionsBTC2["OP_SWAP"] = "Swap the top two items on the stack. (E.g. [a, b] -> [b, a])";
  OpcodeDescriptionsBTC2["OP_TUCK"] = "Duplicate the item at the top of the stack, inserting it below the second-to-top item. (E.g. [a, b] -> [b, a, b])";
  OpcodeDescriptionsBTC2["OP_CAT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this concatenated two stack items.)";
  OpcodeDescriptionsBTC2["OP_SUBSTR"] = "Error, even when found in an unexecuted conditional branch. (Historically, this returned a section of a stack item.)";
  OpcodeDescriptionsBTC2["OP_LEFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this returned a section to the left of a point in a stack item.)";
  OpcodeDescriptionsBTC2["OP_RIGHT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this returned a section to the right of a point in a stack item.)";
  OpcodeDescriptionsBTC2["OP_SIZE"] = "Push the byte-length of the top stack item as a VM Number.";
  OpcodeDescriptionsBTC2["OP_INVERT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this flipped all the bits in a stack item.)";
  OpcodeDescriptionsBTC2["OP_AND"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a boolean AND on each bit in two stack items.)";
  OpcodeDescriptionsBTC2["OP_OR"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a boolean OR on each bit in two stack items.)";
  OpcodeDescriptionsBTC2["OP_XOR"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a boolean XOR on each bit in two stack items.)";
  OpcodeDescriptionsBTC2["OP_EQUAL"] = "Pop the top two items from the stack and compare them byte-by-byte. If they are the same, push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsBTC2["OP_EQUALVERIFY"] = "Pop the top two items from the stack and compare them byte-by-byte. If the values are different, error. (This operation is a combination of OP_EQUAL followed by OP_VERIFY.)";
  OpcodeDescriptionsBTC2["OP_RESERVED1"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED1 counts toward the opcode limit.";
  OpcodeDescriptionsBTC2["OP_RESERVED2"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED2 counts toward the opcode limit.";
  OpcodeDescriptionsBTC2["OP_MUL"] = "Error, even when found in an unexecuted conditional branch. (Historically, this multiplied two VM Numbers.)";
  OpcodeDescriptionsBTC2["OP_DIV"] = "Error, even when found in an unexecuted conditional branch. (Historically, this divided a VM Number by another.)";
  OpcodeDescriptionsBTC2["OP_MOD"] = "Error, even when found in an unexecuted conditional branch. (Historically, this returned the remainder after dividing one VM Number by another.)";
  OpcodeDescriptionsBTC2["OP_1ADD"] = "Pop the top item from the stack as a VM Number, add 1, then push the result.";
  OpcodeDescriptionsBTC2["OP_1SUB"] = "Pop the top item from the stack as a VM Number, subtract 1, then push the result.";
  OpcodeDescriptionsBTC2["OP_2MUL"] = "Error, even when found in an unexecuted conditional branch. (Historically, this multiplied a VM Number by 2.)";
  OpcodeDescriptionsBTC2["OP_2DIV"] = "Error, even when found in an unexecuted conditional branch. (Historically, this divided a VM Number by 2.)";
  OpcodeDescriptionsBTC2["OP_NEGATE"] = "Pop the top item from the stack as a VM Number, negate it, then push the result.";
  OpcodeDescriptionsBTC2["OP_ABS"] = "Pop the top item from the stack as a VM Number, take its absolute value, then push the result.";
  OpcodeDescriptionsBTC2["OP_NOT"] = "Pop the top item from the stack as a VM Number. If its value is 0, push a 1 (VM Number), otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBTC2["OP_0NOTEQUAL"] = "Pop the top item from the stack as a VM Number. If its value is not 0, push a 1 (VM Number), otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBTC2["OP_ADD"] = "Pop the top two items from the stack as VM Numbers. Add them, then push the result.";
  OpcodeDescriptionsBTC2["OP_SUB"] = "Pop the top two items from the stack as VM Numbers. Subtract the top item from the second item, then push the result.";
  OpcodeDescriptionsBTC2["OP_LSHIFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a sign-preserving, left bit shift.)";
  OpcodeDescriptionsBTC2["OP_RSHIFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a sign-preserving, right bit shift.)";
  OpcodeDescriptionsBTC2["OP_BOOLAND"] = "Pop the top two items from the stack as VM Numbers. If neither value is a 0 (VM Number), push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBTC2["OP_BOOLOR"] = "Pop the top two items from the stack as VM Numbers. If either value is a 1 (VM Number), push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBTC2["OP_NUMEQUAL"] = "Pop the top two items from the stack as VM Numbers. If the values are equal, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBTC2["OP_NUMEQUALVERIFY"] = "Pop the top two items from the stack as VM Numbers. If the values are different, error. (This operation is a combination of OP_NUMEQUAL followed by OP_VERIFY.)";
  OpcodeDescriptionsBTC2["OP_NUMNOTEQUAL"] = "Pop the top two items from the stack as VM Numbers. If the values are not equal, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBTC2["OP_LESSTHAN"] = "Pop the top two items from the stack as VM Numbers. If the second item is less than top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBTC2["OP_GREATERTHAN"] = "Pop the top two items from the stack as VM Numbers. If the second item is greater than top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBTC2["OP_LESSTHANOREQUAL"] = "Pop the top two items from the stack as VM Numbers. If the second item is less than or equal to the top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBTC2["OP_GREATERTHANOREQUAL"] = "Pop the top two items from the stack as VM Numbers. If the second item is greater than or equal to the top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBTC2["OP_MIN"] = "Pop the top two items from the stack as VM Numbers. Push the smaller of the two numbers.";
  OpcodeDescriptionsBTC2["OP_MAX"] = "Pop the top two items from the stack as VM Numbers. Push the larger of the two numbers.";
  OpcodeDescriptionsBTC2["OP_WITHIN"] = "Pop the top three items from the stack as VM Numbers. If the top number is within the range defined by the following two numbers (left-inclusive), push a 1 (VM Number). Otherwise, push a 0 (VM Number). (E.g. for [a, b, c]: if (b <= a), and (a < c), [1]. Else [0].)";
  OpcodeDescriptionsBTC2["OP_RIPEMD160"] = "Pop the top item from the stack and pass it through ripemd160, pushing the result onto the stack.";
  OpcodeDescriptionsBTC2["OP_SHA1"] = "Pop the top item from the stack and pass it through sha1, pushing the result onto the stack.";
  OpcodeDescriptionsBTC2["OP_SHA256"] = "Pop the top item from the stack and pass it through sha256, pushing the result onto the stack.";
  OpcodeDescriptionsBTC2["OP_HASH160"] = "Pop the top item from the stack and pass it through sha256, then ripemd160, pushing the result onto the stack.";
  OpcodeDescriptionsBTC2["OP_HASH256"] = "Pop the top item from the stack and pass it through sha256 twice, pushing the result onto the stack.";
  OpcodeDescriptionsBTC2["OP_CODESEPARATOR"] = "Update the value of lastCodeSeparator to the instruction pointer's current value. (This reduces the coverage of signing serializations used in signature verification operations.)";
  OpcodeDescriptionsBTC2["OP_CHECKSIG"] = "Pop the top two items from the stack. Treat the top as a signature and the second as a public key. If the signature is valid, push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsBTC2["OP_CHECKSIGVERIFY"] = "Pop the top two items from the stack. Treat the top as a signature and the second as a public key. If the signature is not valid, error. (This operation is a combination of OP_CHECKSIG followed by OP_VERIFY.)";
  OpcodeDescriptionsBTC2["OP_CHECKMULTISIG"] = "Pop items from the stack: first pop the VM Number of public keys, then pop each of those public keys. Next, pop the VM Number of required signatures, then pop each of those signatures. Finally, pop a final VM Number that must be 0 due to a protocol bug. Checking each signature against each public key in order, if all signatures are valid – and the required number of signatures have been provided – push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsBTC2["OP_CHECKMULTISIGVERIFY"] = "Pop items from the stack: first pop the VM Number of public keys, then pop each of those public keys. Next, pop the VM Number of required signatures, then pop each of those signatures. Finally, (due to a protocol bug) pop an unused final VM Number that must be 0. Checking each signature against each public key in order, if any signatures are invalid – or the required number of signatures have not been provided – error. (This operation is a combination of OP_CHECKMULTISIG followed by OP_VERIFY.)";
  OpcodeDescriptionsBTC2["OP_NOP1"] = "No operation (reserved for future expansion). Note: OP_NOP1 counts toward the opcode limit.";
  OpcodeDescriptionsBTC2["OP_CHECKLOCKTIMEVERIFY"] = "Verify the transaction occurs after an absolute block time or height: read the top item on the stack as a VM Number (without removing it), and compare it to the transaction's locktime. If the required locktime has not passed, or if locktime has been disabled for this input by a maximized sequence number, error.";
  OpcodeDescriptionsBTC2["OP_CHECKSEQUENCEVERIFY"] = `Verify the transaction occurs after the output being spent has "aged" by a relative block time or block height since it was created: read the top item on the stack as a VM Number (without removing it), and compare it to the age encoded in the input's sequence number. If the required relative locktime has not passed, or if relative locktime has been disabled by the sequence number or the transaction version, error.`;
  OpcodeDescriptionsBTC2["OP_NOP4"] = "No operation (reserved for future expansion). Note: OP_NOP4 counts toward the opcode limit.";
  OpcodeDescriptionsBTC2["OP_NOP6"] = "No operation (reserved for future expansion). Note: OP_NOP6 counts toward the opcode limit.";
  OpcodeDescriptionsBTC2["OP_NOP5"] = "No operation (reserved for future expansion). Note: OP_NOP5 counts toward the opcode limit.";
  OpcodeDescriptionsBTC2["OP_NOP7"] = "No operation (reserved for future expansion). Note: OP_NOP7 counts toward the opcode limit.";
  OpcodeDescriptionsBTC2["OP_NOP8"] = "No operation (reserved for future expansion). Note: OP_NOP8 counts toward the opcode limit.";
  OpcodeDescriptionsBTC2["OP_NOP9"] = "No operation (reserved for future expansion). Note: OP_NOP9 counts toward the opcode limit.";
  OpcodeDescriptionsBTC2["OP_NOP10"] = "No operation (reserved for future expansion). Note: OP_NOP10 counts toward the opcode limit.";
})(OpcodeDescriptionsBTC || (OpcodeDescriptionsBTC = {}));

// node_modules/@bitauth/libauth/build/lib/vm/instruction-sets/btc/btc-types.js
var import_dist301 = __toESM(require_dist(), 1);
var import_dist302 = __toESM(require_dist2(), 1);
var import_dist303 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/vm/vm-types.js
var import_dist310 = __toESM(require_dist(), 1);
var import_dist311 = __toESM(require_dist2(), 1);
var import_dist312 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/language/language-types.js
var import_dist316 = __toESM(require_dist(), 1);
var import_dist317 = __toESM(require_dist2(), 1);
var import_dist318 = __toESM(require_dist3(), 1);
var IdentifierResolutionType;
(function(IdentifierResolutionType2) {
  IdentifierResolutionType2["opcode"] = "opcode";
  IdentifierResolutionType2["variable"] = "variable";
  IdentifierResolutionType2["script"] = "script";
})(IdentifierResolutionType || (IdentifierResolutionType = {}));
var IdentifierResolutionErrorType;
(function(IdentifierResolutionErrorType2) {
  IdentifierResolutionErrorType2["unknown"] = "unknown";
  IdentifierResolutionErrorType2["variable"] = "variable";
  IdentifierResolutionErrorType2["script"] = "script";
})(IdentifierResolutionErrorType || (IdentifierResolutionErrorType = {}));

// node_modules/@bitauth/libauth/build/lib/language/language-utils.js
var import_dist319 = __toESM(require_dist(), 1);
var import_dist320 = __toESM(require_dist2(), 1);
var import_dist321 = __toESM(require_dist3(), 1);
var pluckStartPosition = (range2) => ({
  startColumn: range2.startColumn,
  startLineNumber: range2.startLineNumber
});
var pluckEndPosition = (range2) => ({
  endColumn: range2.endColumn,
  endLineNumber: range2.endLineNumber
});
var mergeRanges = (ranges, parentRange = {
  endColumn: 0,
  endLineNumber: 0,
  startColumn: 0,
  startLineNumber: 0
}) => {
  const minimumRangesToMerge = 2;
  const unsortedMerged = ranges.length < minimumRangesToMerge ? ranges.length === 1 ? (
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    ranges[0]
  ) : parentRange : ranges.reduce(
    // eslint-disable-next-line complexity
    (merged, range2) => ({
      ...range2.endLineNumber > merged.endLineNumber ? pluckEndPosition(range2) : range2.endLineNumber === merged.endLineNumber && range2.endColumn > merged.endColumn ? pluckEndPosition(range2) : pluckEndPosition(merged),
      ...range2.startLineNumber < merged.startLineNumber ? pluckStartPosition(range2) : range2.startLineNumber === merged.startLineNumber && range2.startColumn < merged.startColumn ? pluckStartPosition(range2) : pluckStartPosition(merged)
    }),
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    ranges[0]
  );
  return {
    ...pluckEndPosition(unsortedMerged),
    ...pluckStartPosition(unsortedMerged)
  };
};
var containsRange = (outerRange, innerRange, exclusive = true) => {
  const startsAfter = outerRange.startLineNumber < innerRange.startLineNumber ? true : outerRange.startLineNumber === innerRange.startLineNumber ? exclusive ? outerRange.startColumn < innerRange.startColumn : outerRange.startColumn <= innerRange.startColumn : false;
  const endsBefore = outerRange.endLineNumber > innerRange.endLineNumber ? true : outerRange.endLineNumber === innerRange.endLineNumber ? exclusive ? outerRange.endColumn > innerRange.endColumn : outerRange.endColumn >= innerRange.endColumn : false;
  return startsAfter && endsBefore;
};
var getResolutionErrors = (resolvedScript) => resolvedScript.reduce((errors, segment) => {
  switch (segment.type) {
    case "error":
      return [
        ...errors,
        {
          error: segment.value,
          ...segment.missingIdentifier === void 0 ? {} : {
            missingIdentifier: segment.missingIdentifier,
            owningEntity: segment.owningEntity
          },
          range: segment.range
        }
      ];
    case "push":
    case "evaluation":
      return [...errors, ...getResolutionErrors(segment.value)];
    default:
      return errors;
  }
}, []);
var allErrorsAreRecoverable = (errors) => errors.every((error) => "missingIdentifier" in error && "owningEntity" in error);
var extractBytecodeResolutions = (resolvedScript) => (
  // eslint-disable-next-line complexity
  resolvedScript.reduce((all, segment) => {
    switch (segment.type) {
      case "push":
      case "evaluation":
        return [...all, ...extractBytecodeResolutions(segment.value)];
      case "bytecode":
        if ("variable" in segment) {
          return [
            ...all,
            {
              bytecode: segment.value,
              text: segment.variable,
              type: "variable"
            }
          ];
        }
        if ("script" in segment) {
          return [
            ...all,
            ...extractBytecodeResolutions(segment.source),
            {
              bytecode: segment.value,
              text: segment.script,
              type: "script"
            }
          ];
        }
        if ("opcode" in segment) {
          return [
            ...all,
            {
              bytecode: segment.value,
              text: segment.opcode,
              type: "opcode"
            }
          ];
        }
        return [
          ...all,
          {
            bytecode: segment.value,
            text: segment.literal,
            type: segment.literalType
          }
        ];
      default:
        return all;
    }
  }, [])
);
var extractResolvedVariableBytecodeMap = (resolvedScript) => extractBytecodeResolutions(resolvedScript).reduce((all, resolution) => resolution.type === "variable" ? { ...all, [resolution.text]: resolution.bytecode } : all, {});
var stringifyErrors = (errors, separator = "; ") => `${errors.map((error) => `[${error.range.startLineNumber}, ${error.range.startColumn}] ${error.error}`).join(separator)}`;
var extractEvaluationSamples = ({ evaluationRange, nodes, trace }) => {
  const traceWithoutFinalState = trace.length > 1 ? trace.slice(0, -1) : trace.slice();
  if (traceWithoutFinalState.length === 0) {
    return {
      samples: [],
      unmatchedStates: []
    };
  }
  const samples = [
    {
      evaluationRange,
      internalStates: [],
      range: {
        endColumn: evaluationRange.startColumn,
        endLineNumber: evaluationRange.startLineNumber,
        startColumn: evaluationRange.startColumn,
        startLineNumber: evaluationRange.startLineNumber
      },
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      state: traceWithoutFinalState[0]
    }
  ];
  let nextState = 1;
  let nextNode = 0;
  let incomplete;
  while (nextState < traceWithoutFinalState.length && nextNode < nodes.length) {
    const currentNode = nodes[nextNode];
    const { mergedBytecode, mergedRange } = incomplete === void 0 ? {
      mergedBytecode: currentNode.bytecode,
      mergedRange: currentNode.range
    } : {
      mergedBytecode: flattenBinArray([
        incomplete.bytecode,
        currentNode.bytecode
      ]),
      mergedRange: mergeRanges([incomplete.range, currentNode.range])
    };
    const decoded = decodeAuthenticationInstructions(mergedBytecode);
    const [zeroth] = decoded;
    const hasNonMalformedInstructions = zeroth !== void 0 && !("malformed" in zeroth);
    if (hasNonMalformedInstructions) {
      const lastInstruction = decoded[decoded.length - 1];
      const validInstructions = authenticationInstructionIsMalformed(lastInstruction) ? decoded.slice(0, decoded.length - 1) : decoded;
      const firstUnmatchedStateIndex = nextState + validInstructions.length;
      const matchingStates = traceWithoutFinalState.slice(nextState, firstUnmatchedStateIndex);
      const pairedStates = validInstructions.map((instruction, index2) => ({
        instruction,
        state: matchingStates[index2]
      }));
      const firstPairedState = pairedStates[0];
      const closesCurrentlyOpenSample = incomplete !== void 0;
      if (closesCurrentlyOpenSample) {
        samples.push({
          evaluationRange,
          instruction: firstPairedState.instruction,
          internalStates: [],
          range: mergedRange,
          state: firstPairedState.state
        });
      }
      const firstUndefinedStateIndex = pairedStates.findIndex(({ state }) => state === void 0);
      const sampleHasError = firstUndefinedStateIndex !== -1;
      const sampleClosingIndex = sampleHasError ? firstUndefinedStateIndex - 1 : pairedStates.length - 1;
      const closesASecondSample = !closesCurrentlyOpenSample || sampleClosingIndex > 0;
      if (closesASecondSample) {
        const finalState = pairedStates[sampleClosingIndex];
        const secondSamplePairsBegin = closesCurrentlyOpenSample ? 1 : 0;
        const internalStates = pairedStates.slice(secondSamplePairsBegin, sampleClosingIndex);
        samples.push({
          evaluationRange,
          instruction: finalState.instruction,
          internalStates,
          range: currentNode.range,
          state: finalState.state
        });
      }
      nextState = firstUnmatchedStateIndex;
      if (authenticationInstructionIsMalformed(lastInstruction)) {
        incomplete = {
          bytecode: encodeAuthenticationInstructionMalformed(lastInstruction),
          range: currentNode.range
        };
      } else {
        incomplete = void 0;
      }
    } else {
      const lastInstruction = decoded[decoded.length - 1];
      incomplete = lastInstruction === void 0 ? void 0 : {
        bytecode: encodeAuthenticationInstructionMalformed(lastInstruction),
        range: mergedRange
      };
    }
    nextNode += 1;
  }
  const errorOccurred = nextNode < nodes.length;
  const unmatchedStates = errorOccurred ? [] : trace.slice(nextState);
  return {
    samples,
    unmatchedStates
  };
};
var extractEvaluationSamplesRecursive = ({
  /**
   * The range of the script node that was evaluated to produce the `trace`
   */
  evaluationRange,
  /**
   * An array of reduced nodes to parse
   */
  nodes,
  /**
   * The `vm.debug` result to map to these nodes
   */
  trace
}) => {
  const extractEvaluations = (node, depth = 1) => {
    if ("push" in node) {
      return node.push.script.reduce((all, childNode) => [...all, ...extractEvaluations(childNode, depth)], []);
    }
    if ("source" in node) {
      const childSamples2 = node.source.script.reduce((all, childNode) => [
        ...all,
        ...extractEvaluations(childNode, depth + 1)
      ], []);
      const traceWithoutUnlockingPhase = node.trace.slice(1);
      const evaluationBeginToken = "$(";
      const evaluationEndToken = ")";
      const extracted = extractEvaluationSamples({
        evaluationRange: {
          endColumn: node.range.endColumn - evaluationEndToken.length,
          endLineNumber: node.range.endLineNumber,
          startColumn: node.range.startColumn + evaluationBeginToken.length,
          startLineNumber: node.range.startLineNumber
        },
        nodes: node.source.script,
        trace: traceWithoutUnlockingPhase
      });
      return [...extracted.samples, ...childSamples2];
    }
    return [];
  };
  const { samples, unmatchedStates } = extractEvaluationSamples({
    evaluationRange,
    nodes,
    trace
  });
  const childSamples = nodes.reduce((all, node) => [...all, ...extractEvaluations(node)], []);
  const endingOrderedSamples = [...samples, ...childSamples].sort((a, b) => {
    const linesOrdered = a.range.endLineNumber - b.range.endLineNumber;
    return linesOrdered === 0 ? a.range.endColumn - b.range.endColumn : linesOrdered;
  });
  return {
    samples: endingOrderedSamples,
    unmatchedStates
  };
};
var stateIsExecuting = (state) => state.controlStack.every((item) => item !== false);
var extractUnexecutedRanges = (samples, evaluationBegins = "1,1") => {
  const reduced = samples.reduce((all, sample) => {
    const { precedingStateSkipsByEvaluation, unexecutedRanges } = all;
    const currentEvaluationStartLineAndColumn = `${sample.evaluationRange.startLineNumber},${sample.evaluationRange.startColumn}`;
    const precedingStateSkips = (
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      precedingStateSkipsByEvaluation[currentEvaluationStartLineAndColumn]
    );
    const endsWithSkip = !stateIsExecuting(sample.state);
    const sampleHasNoExecutedInstructions = endsWithSkip && sample.internalStates.every((group) => !stateIsExecuting(group.state));
    if (precedingStateSkips && sampleHasNoExecutedInstructions) {
      return {
        precedingStateSkipsByEvaluation: {
          ...precedingStateSkipsByEvaluation,
          [currentEvaluationStartLineAndColumn]: true
        },
        unexecutedRanges: [...unexecutedRanges, sample.range]
      };
    }
    return {
      precedingStateSkipsByEvaluation: {
        ...precedingStateSkipsByEvaluation,
        [currentEvaluationStartLineAndColumn]: endsWithSkip
      },
      unexecutedRanges
    };
  }, {
    precedingStateSkipsByEvaluation: {
      [evaluationBegins]: false
    },
    unexecutedRanges: []
  });
  const canHaveContainedRanges = 2;
  const containedRangesExcluded = reduced.unexecutedRanges.length < canHaveContainedRanges ? reduced.unexecutedRanges : reduced.unexecutedRanges.slice(0, -1).reduceRight(
    (all, range2) => {
      if (containsRange(all[0], range2)) {
        return all;
      }
      return [range2, ...all];
    },
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    [reduced.unexecutedRanges[reduced.unexecutedRanges.length - 1]]
  );
  return containedRangesExcluded;
};
var summarizeStack = (stack) => stack.map((item) => {
  const asNumber = vmNumberToBigInt(item);
  return `0x${binToHex(item)}${typeof asNumber === "string" ? "" : `(${asNumber.toString()})`}`;
});
var summarizeDebugTrace = (trace) => trace.reduce(
  // eslint-disable-next-line max-params
  (steps, state, stateIndex, states) => {
    const nextState = states[stateIndex + 1];
    return nextState === void 0 ? steps : [
      ...steps,
      {
        alternateStack: summarizeStack(nextState.alternateStack),
        ...nextState.error === void 0 ? {} : { error: nextState.error },
        execute: state.controlStack[state.controlStack.length - 1] !== false,
        instruction: state.instructions[state.ip],
        ip: state.ip,
        stack: summarizeStack(nextState.stack)
      }
    ];
  },
  []
);
var stringifyDebugTraceSummary = (summary, { opcodes, padInstruction } = {
  opcodes: OpcodesBCHCHIPs,
  padInstruction: 23
}) => summary.map(
  // eslint-disable-next-line complexity
  (line) => `${(line.instruction === void 0 ? "=>" : `${line.ip}. ${line.execute ? "" : "(skip)"}${opcodes[line.instruction.opcode] ?? `OP_UNKNOWN${line.instruction.opcode}`}:`).padEnd(padInstruction)} ${typeof line.error === "string" ? line.error : `${line.stack.join(" ")}${line.alternateStack.length === 0 ? "" : `| alt: ${line.alternateStack.join(" ")}`}`}`
).join("\n");

// node_modules/@bitauth/libauth/build/lib/language/parse.js
var import_dist325 = __toESM(require_dist(), 1);
var import_dist326 = __toESM(require_dist2(), 1);
var import_dist327 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/language/parsimmon.js
var import_dist322 = __toESM(require_dist(), 1);
var import_dist323 = __toESM(require_dist2(), 1);
var import_dist324 = __toESM(require_dist3(), 1);
function Parsimmon(action) {
  if (!(this instanceof Parsimmon)) {
    return new Parsimmon(action);
  }
  this._ = action;
}
var _ = Parsimmon.prototype;
function makeSuccess(index2, value) {
  return {
    expected: [],
    furthest: -1,
    index: index2,
    status: true,
    value
  };
}
function makeFailure(index2, expected) {
  expected = [expected];
  return {
    expected,
    furthest: index2,
    index: -1,
    status: false,
    value: null
  };
}
function mergeReplies(result, last) {
  if (!last) {
    return result;
  }
  if (result.furthest > last.furthest) {
    return result;
  }
  const expected = result.furthest === last.furthest ? union(result.expected, last.expected) : last.expected;
  return {
    expected,
    furthest: last.furthest,
    index: result.index,
    status: result.status,
    value: result.value
  };
}
function makeLineColumnIndex(input, i) {
  const lines = input.slice(0, i).split("\n");
  const lineWeAreUpTo = lines.length;
  const columnWeAreUpTo = lines[lines.length - 1].length + 1;
  return {
    column: columnWeAreUpTo,
    line: lineWeAreUpTo,
    offset: i
  };
}
function union(xs, ys) {
  const obj = {};
  for (let i = 0; i < xs.length; i++) {
    obj[xs[i]] = true;
  }
  for (let j = 0; j < ys.length; j++) {
    obj[ys[j]] = true;
  }
  const keys = [];
  for (const k in obj) {
    keys.push(k);
  }
  keys.sort();
  return keys;
}
function flags(re) {
  const s = String(re);
  return s.slice(s.lastIndexOf("/") + 1);
}
function anchoredRegexp(re) {
  return RegExp(`^(?:${re.source})`, flags(re));
}
function seq(...params) {
  const parsers = [].slice.call(params);
  const numParsers = parsers.length;
  return Parsimmon(function(input, i) {
    let result;
    const accum = new Array(numParsers);
    for (let j = 0; j < numParsers; j += 1) {
      result = mergeReplies(parsers[j]._(input, i), result);
      if (!result.status) {
        return result;
      }
      accum[j] = result.value;
      i = result.index;
    }
    return mergeReplies(makeSuccess(i, accum), result);
  });
}
function seqMap(...params) {
  const args = [].slice.call(params);
  const mapper = args.pop();
  return seq.apply(null, args).map(function(results) {
    return mapper.apply(null, results);
  });
}
function createLanguage(parsers) {
  const language = {};
  for (const key in parsers) {
    (function(rule) {
      const func = function() {
        return parsers[rule](language);
      };
      language[rule] = lazy(func);
    })(key);
  }
  return language;
}
function alt(...params) {
  const parsers = [].slice.call(params);
  return Parsimmon(function(input, i) {
    let result;
    for (let j = 0; j < parsers.length; j += 1) {
      result = mergeReplies(parsers[j]._(input, i), result);
      if (result.status) {
        return result;
      }
    }
    return result;
  });
}
function sepBy(parser, separator) {
  return sepBy1(parser, separator).or(succeed([]));
}
function sepBy1(parser, separator) {
  const pairs = separator.then(parser).many();
  return seqMap(parser, pairs, function(r, rs) {
    return [r].concat(rs);
  });
}
_.parse = function(input) {
  const result = this.skip(eof)._(input, 0);
  if (result.status) {
    return {
      status: true,
      value: result.value
    };
  }
  return {
    expected: result.expected,
    index: makeLineColumnIndex(input, result.furthest),
    status: false
  };
};
_.or = function(alternative) {
  return alt(this, alternative);
};
_.then = function(next) {
  return seq(this, next).map(function(results) {
    return results[1];
  });
};
_.many = function() {
  const self = this;
  return Parsimmon(function(input, i) {
    const accum = [];
    let result;
    for (; ; ) {
      result = mergeReplies(self._(input, i), result);
      if (result.status) {
        if (i === result.index) {
          throw new Error("infinite loop detected in .many() parser --- calling .many() on a parser that can accept zero characters is usually the cause");
        }
        i = result.index;
        accum.push(result.value);
      } else {
        return mergeReplies(makeSuccess(i, accum), result);
      }
    }
  });
};
_.map = function(fn) {
  const self = this;
  return Parsimmon(function(input, i) {
    const result = self._(input, i);
    if (!result.status) {
      return result;
    }
    return mergeReplies(makeSuccess(result.index, fn(result.value)), result);
  });
};
_.skip = function(next) {
  return seq(this, next).map(function(results) {
    return results[0];
  });
};
_.node = function(name) {
  return seqMap(index, this, index, function(start, value, end) {
    return {
      end,
      name,
      start,
      value
    };
  });
};
_.sepBy = function(separator) {
  return sepBy(this, separator);
};
_.desc = function(expected) {
  expected = [expected];
  const self = this;
  return Parsimmon(function(input, i) {
    const reply = self._(input, i);
    if (!reply.status) {
      reply.expected = expected;
    }
    return reply;
  });
};
function string(str) {
  const expected = `'${str}'`;
  return Parsimmon(function(input, i) {
    const j = i + str.length;
    const head = input.slice(i, j);
    if (head === str) {
      return makeSuccess(j, head);
    }
    return makeFailure(i, expected);
  });
}
function regexp(re, group = 0) {
  const anchored = anchoredRegexp(re);
  const expected = String(re);
  return Parsimmon(function(input, i) {
    const match2 = anchored.exec(input.slice(i));
    if (match2) {
      const fullMatch = match2[0];
      const groupMatch = match2[group];
      return makeSuccess(i + fullMatch.length, groupMatch);
    }
    return makeFailure(i, expected);
  });
}
function succeed(value) {
  return Parsimmon(function(__, i) {
    return makeSuccess(i, value);
  });
}
function lazy(f) {
  const parser = Parsimmon(function(input, i) {
    parser._ = f()._;
    return parser._(input, i);
  });
  return parser;
}
var index = Parsimmon(function(input, i) {
  return makeSuccess(i, makeLineColumnIndex(input, i));
});
var eof = Parsimmon(function(input, i) {
  if (i < input.length) {
    return makeFailure(i, "EOF");
  }
  return makeSuccess(i, null);
});
var optWhitespace = regexp(/\s*/u).desc("optional whitespace");
var whitespace = regexp(/\s+/u).desc("whitespace");
var P = {
  alt,
  createLanguage,
  index,
  lazy,
  makeFailure,
  makeSuccess,
  of: succeed,
  optWhitespace,
  regexp,
  sepBy,
  sepBy1,
  seq,
  seqMap,
  string,
  succeed,
  whitespace
};

// node_modules/@bitauth/libauth/build/lib/language/parse.js
var cashAssemblyParser = P.createLanguage({
  script: (r) => P.seqMap(P.optWhitespace, r.expression.sepBy(P.optWhitespace), P.optWhitespace, (_2, expressions) => expressions).node("Script"),
  expression: (r) => P.alt(r.comment, r.push, r.evaluation, r.utf8, r.binary, r.hex, r.bigint, r.identifier),
  comment: (r) => P.alt(r.singleLineComment, r.multiLineComment).node("Comment"),
  singleLineComment: () => P.seqMap(P.string("//").desc("the start of a single-line comment ('//')"), P.regexp(/[^\n]*/u), (__, comment) => comment.trim()),
  multiLineComment: () => P.seqMap(P.string("/*").desc("the start of a multi-line comment ('/*')"), P.regexp(/[\s\S]*?\*\//u).desc("the end of this multi-line comment ('*/')"), (__, comment) => comment.slice(0, -"*/".length).trim()),
  push: (r) => P.seqMap(P.string("<").desc("the start of a push statement ('<')"), r.script, P.string(">").desc("the end of this push statement ('>')"), (_2, push) => push).node("Push"),
  evaluation: (r) => P.seqMap(P.string("$").desc("the start of an evaluation ('$')"), P.string("(").desc("the opening parenthesis of this evaluation ('(')"), r.script, P.string(")").desc("the closing parenthesis of this evaluation (')')"), (_2, __, evaluation) => evaluation).node("Evaluation"),
  identifier: () => P.regexp(/[a-zA-Z_][.a-zA-Z0-9_-]*/u).desc("a valid identifier").node("Identifier"),
  utf8: () => P.alt(P.seqMap(P.string('"').desc('a double quote (")'), P.regexp(/[^"]*/u), P.string('"').desc('a closing double quote (")'), (__, literal) => literal), P.seqMap(P.string("'").desc("a single quote (')"), P.regexp(/[^']*/u), P.string("'").desc("a closing single quote (')"), (__, literal) => literal)).node("UTF8Literal"),
  hex: () => P.seqMap(P.string("0x").desc("a hex literal ('0x...')"), P.regexp(/[0-9a-f]_*(?:_*[0-9a-f]_*[0-9a-f]_*)*[0-9a-f]/iu).desc("a valid hexadecimal string"), (__, literal) => literal).node("HexLiteral"),
  binary: () => P.seqMap(P.string("0b").desc("a binary literal ('0b...')"), P.regexp(/[01]+(?:[01_]*[01]+)*/iu).desc("a string of binary digits"), (__, literal) => literal).node("BinaryLiteral"),
  bigint: () => P.regexp(/-?[0-9]+(?:[0-9_]*[0-9]+)*/u).desc("an integer literal").node("BigIntLiteral")
});
var parseScript = (script) => cashAssemblyParser.script.parse(script);

// node_modules/@bitauth/libauth/build/lib/language/reduce.js
var import_dist328 = __toESM(require_dist(), 1);
var import_dist329 = __toESM(require_dist2(), 1);
var import_dist330 = __toESM(require_dist3(), 1);
var emptyReductionTraceNode = (range2) => ({
  bytecode: Uint8Array.of(),
  range: range2
});
var verifyCashAssemblyEvaluationState = (state) => {
  if (state.error !== void 0) {
    return state.error;
  }
  if (state.controlStack.length !== 0) {
    return AuthenticationErrorCommon.nonEmptyControlStack;
  }
  if (state.stack.length !== 1) {
    return AuthenticationErrorCommon.requiresCleanStack;
  }
  return true;
};
var reduceScript = (resolvedScript, vm, createEvaluationProgram) => {
  const script = resolvedScript.map((segment) => {
    switch (segment.type) {
      case "bytecode":
        return { bytecode: segment.value, range: segment.range };
      case "push": {
        const push = reduceScript(segment.value, vm, createEvaluationProgram);
        const bytecode = encodeDataPush(push.bytecode);
        return {
          bytecode,
          ...push.errors === void 0 ? void 0 : { errors: push.errors },
          push,
          range: segment.range
        };
      }
      case "evaluation": {
        if (typeof vm === "undefined" || typeof createEvaluationProgram === "undefined") {
          return {
            errors: [
              {
                error: "Both a VM and a createState method are required to reduce evaluations.",
                range: segment.range
              }
            ],
            ...emptyReductionTraceNode(segment.range)
          };
        }
        const reductionTrace = reduceScript(segment.value, vm, createEvaluationProgram);
        if (reductionTrace.errors !== void 0) {
          return {
            ...emptyReductionTraceNode(segment.range),
            errors: reductionTrace.errors,
            source: reductionTrace,
            trace: []
          };
        }
        const trace = vm.debug(createEvaluationProgram(reductionTrace.bytecode));
        const lastState = trace[trace.length - 1];
        const result = verifyCashAssemblyEvaluationState(lastState);
        const bytecode = lastState.stack[lastState.stack.length - 1];
        return {
          ...typeof result === "string" ? {
            bytecode: Uint8Array.of(),
            errors: [
              {
                error: `Failed to reduce evaluation: ${result}`,
                range: segment.range
              }
            ]
          } : {
            bytecode
          },
          range: segment.range,
          source: reductionTrace,
          trace
        };
      }
      case "comment":
        return emptyReductionTraceNode(segment.range);
      case "error":
        return {
          errors: [
            {
              error: `Tried to reduce a CashAssembly script with resolution errors: ${segment.value}`,
              range: segment.range
            }
          ],
          ...emptyReductionTraceNode(segment.range)
        };
      default:
        throw new Error(`"${segment.type}" is not a known segment type.`);
    }
  });
  const reduction = script.reduce((all, segment) => ({
    bytecode: [...all.bytecode, segment.bytecode],
    ranges: [...all.ranges, segment.range],
    ...all.errors !== void 0 || segment.errors !== void 0 ? {
      errors: [
        ...all.errors === void 0 ? [] : all.errors,
        ...segment.errors === void 0 ? [] : segment.errors
      ]
    } : void 0
  }), { bytecode: [], ranges: [] });
  return {
    ...reduction.errors === void 0 ? void 0 : { errors: reduction.errors },
    bytecode: flattenBinArray(reduction.bytecode),
    range: mergeRanges(
      reduction.ranges,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      resolvedScript.length === 0 ? void 0 : resolvedScript[0].range
    ),
    script
  };
};

// node_modules/@bitauth/libauth/build/lib/language/resolve.js
var pluckRange = (node) => ({
  endColumn: node.end.column,
  endLineNumber: node.end.line,
  startColumn: node.start.column,
  startLineNumber: node.start.line
});
var removeNumericSeparators = (numericLiteral) => numericLiteral.replace(/_/gu, "");
var resolveScriptSegment = (segment, resolveIdentifiers) => {
  const resolved = segment.value.map((child) => {
    const range2 = pluckRange(child);
    switch (child.name) {
      case "Identifier": {
        const identifier = child.value;
        const result = resolveIdentifiers(identifier);
        const ret = result.status ? {
          range: range2,
          type: "bytecode",
          value: result.bytecode,
          ...result.type === IdentifierResolutionType.opcode ? {
            opcode: identifier
          } : result.type === IdentifierResolutionType.variable ? {
            ..."debug" in result ? { debug: result.debug } : {},
            ..."signature" in result ? { signature: result.signature } : {},
            variable: identifier
          } : (
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            result.type === IdentifierResolutionType.script ? { script: identifier, source: result.source } : { unknown: identifier }
          )
        } : {
          ..."debug" in result ? { debug: result.debug } : {},
          ..."recoverable" in result && result.recoverable ? {
            missingIdentifier: identifier,
            owningEntity: result.entityOwnership
          } : {},
          range: range2,
          type: "error",
          value: result.error
        };
        return ret;
      }
      case "Push":
        return {
          range: range2,
          type: "push",
          value: resolveScriptSegment(child.value, resolveIdentifiers)
        };
      case "Evaluation":
        return {
          range: range2,
          type: "evaluation",
          value: resolveScriptSegment(child.value, resolveIdentifiers)
        };
      case "BigIntLiteral":
        return {
          literal: child.value,
          literalType: "BigIntLiteral",
          range: range2,
          type: "bytecode",
          value: bigIntToVmNumber(BigInt(removeNumericSeparators(child.value)))
        };
      case "BinaryLiteral":
        return {
          literal: child.value,
          literalType: "BinaryLiteral",
          range: range2,
          type: "bytecode",
          value: binStringToBin(removeNumericSeparators(child.value))
        };
      case "HexLiteral":
        return {
          literal: child.value,
          literalType: "HexLiteral",
          range: range2,
          type: "bytecode",
          value: hexToBin(removeNumericSeparators(child.value))
        };
      case "UTF8Literal":
        return {
          literal: child.value,
          literalType: "UTF8Literal",
          range: range2,
          type: "bytecode",
          value: utf8ToBin(child.value)
        };
      case "Comment":
        return {
          range: range2,
          type: "comment",
          value: child.value
        };
      default:
        return {
          range: range2,
          type: "error",
          value: `Unrecognized segment: ${child.name}`
        };
    }
  });
  return resolved.length === 0 ? [{ range: pluckRange(segment), type: "comment", value: "" }] : resolved;
};
var BuiltInVariables;
(function(BuiltInVariables2) {
  BuiltInVariables2["currentBlockTime"] = "current_block_time";
  BuiltInVariables2["currentBlockHeight"] = "current_block_height";
  BuiltInVariables2["signingSerialization"] = "signing_serialization";
})(BuiltInVariables || (BuiltInVariables = {}));
var attemptCompilerOperation = ({ data, configuration, identifier, matchingOperations, operationExample = "operation_identifier", operationId, variableId, variableType }) => {
  if (matchingOperations === void 0) {
    return {
      error: `The "${variableId}" variable type can not be resolved because the "${variableType}" operation has not been included in this compiler's CompilationEnvironment.`,
      status: "error"
    };
  }
  if (typeof matchingOperations === "function") {
    const operation2 = matchingOperations;
    return operation2(identifier, data, configuration);
  }
  if (operationId === void 0) {
    return {
      error: `This "${variableId}" variable could not be resolved because this compiler's "${variableType}" operations require an operation identifier, e.g. '${variableId}.${operationExample}'.`,
      status: "error"
    };
  }
  const operation = matchingOperations[operationId];
  if (operation === void 0) {
    return {
      error: `The identifier "${identifier}" could not be resolved because the "${variableId}.${operationId}" operation is not available to this compiler.`,
      status: "error"
    };
  }
  return operation(identifier, data, configuration);
};
var resolveVariableIdentifier = ({ data, configuration, identifier }) => {
  const [variableId, operationId] = identifier.split(".");
  switch (variableId) {
    case BuiltInVariables.currentBlockHeight:
      return attemptCompilerOperation({
        configuration,
        data,
        identifier,
        matchingOperations: configuration.operations?.currentBlockHeight,
        operationId,
        variableId,
        variableType: "currentBlockHeight"
      });
    case BuiltInVariables.currentBlockTime:
      return attemptCompilerOperation({
        configuration,
        data,
        identifier,
        matchingOperations: configuration.operations?.currentBlockTime,
        operationId,
        variableId,
        variableType: "currentBlockTime"
      });
    case BuiltInVariables.signingSerialization:
      return attemptCompilerOperation({
        configuration,
        data,
        identifier,
        matchingOperations: configuration.operations?.signingSerialization,
        operationExample: "version",
        operationId,
        variableId,
        variableType: "signingSerialization"
      });
    default: {
      const expectedVariable = configuration.variables?.[variableId];
      if (expectedVariable === void 0) {
        return { status: "skip" };
      }
      return attemptCompilerOperation({
        configuration,
        data,
        identifier,
        operationId,
        variableId,
        ...{
          // eslint-disable-next-line @typescript-eslint/naming-convention
          AddressData: {
            matchingOperations: configuration.operations?.addressData,
            variableType: "addressData"
          },
          // eslint-disable-next-line @typescript-eslint/naming-convention
          HdKey: {
            matchingOperations: configuration.operations?.hdKey,
            operationExample: "public_key",
            variableType: "hdKey"
          },
          // eslint-disable-next-line @typescript-eslint/naming-convention
          Key: {
            matchingOperations: configuration.operations?.key,
            operationExample: "public_key",
            variableType: "key"
          },
          // eslint-disable-next-line @typescript-eslint/naming-convention
          WalletData: {
            matchingOperations: configuration.operations?.walletData,
            variableType: "walletData"
          }
        }[expectedVariable.type]
      });
    }
  }
};
var describeExpectedInput = (expectedArray) => {
  const EOF = "EOF";
  const newArray = expectedArray.filter((value) => value !== EOF);
  if (newArray.length !== expectedArray.length) {
    newArray.push("the end of the script");
  }
  const withoutLastElement = newArray.slice(0, newArray.length - 1);
  const lastElement = newArray[newArray.length - 1];
  const arrayRequiresCommas = 3;
  const arrayRequiresOr = 2;
  return `Encountered unexpected input while parsing script. Expected ${newArray.length >= arrayRequiresCommas ? withoutLastElement.join(", ").concat(`, or ${lastElement}`) : newArray.length === arrayRequiresOr ? newArray.join(" or ") : lastElement}.`;
};
var createEmptyRange = () => ({
  endColumn: 0,
  endLineNumber: 0,
  startColumn: 0,
  startLineNumber: 0
});
var compileScriptRaw = ({ data, configuration, scriptId }) => {
  const script = configuration.scripts[scriptId];
  if (script === void 0) {
    return {
      errorType: "parse",
      errors: [
        {
          error: `No script with an ID of "${scriptId}" was provided in the compiler configuration.`,
          range: createEmptyRange()
        }
      ],
      success: false
    };
  }
  if (configuration.sourceScriptIds?.includes(scriptId) === true) {
    return {
      errorType: "parse",
      errors: [
        {
          error: `A circular dependency was encountered: script "${scriptId}" relies on itself to be generated. (Source scripts: ${configuration.sourceScriptIds.join(" → ")})`,
          range: createEmptyRange()
        }
      ],
      success: false
    };
  }
  const sourceScriptIds = configuration.sourceScriptIds === void 0 ? [scriptId] : [...configuration.sourceScriptIds, scriptId];
  return compileScriptContents({
    configuration: { ...configuration, sourceScriptIds },
    data,
    script
  });
};
var resolveScriptIdentifier = ({ data, configuration, identifier }) => {
  if (configuration.scripts[identifier] === void 0) {
    return false;
  }
  const result = compileScriptRaw({
    configuration,
    data,
    scriptId: identifier
  });
  if (result.success) {
    return result;
  }
  return `Compilation error in resolved script "${identifier}": ${stringifyErrors(result.errors)}`;
};
var createIdentifierResolver = ({ data, configuration }) => (
  // eslint-disable-next-line complexity
  (identifier) => {
    const opcodeResult = configuration.opcodes?.[identifier];
    if (opcodeResult !== void 0) {
      return {
        bytecode: opcodeResult,
        status: true,
        type: IdentifierResolutionType.opcode
      };
    }
    const variableResult = resolveVariableIdentifier({
      configuration,
      data,
      identifier
    });
    if (variableResult.status !== "skip") {
      return variableResult.status === "error" ? {
        ..."debug" in variableResult ? { debug: variableResult.debug } : {},
        error: variableResult.error,
        ...configuration.entityOwnership === void 0 ? {} : {
          entityOwnership: (
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            configuration.entityOwnership[identifier.split(".")[0]]
          )
        },
        recoverable: "recoverable" in variableResult,
        status: false,
        type: IdentifierResolutionErrorType.variable
      } : {
        ..."debug" in variableResult ? { debug: variableResult.debug } : {},
        bytecode: variableResult.bytecode,
        ..."signature" in variableResult ? {
          signature: variableResult.signature
        } : {},
        status: true,
        type: IdentifierResolutionType.variable
      };
    }
    const scriptResult = resolveScriptIdentifier({
      configuration,
      data,
      identifier
    });
    if (scriptResult !== false) {
      return typeof scriptResult === "string" ? {
        error: scriptResult,
        scriptId: identifier,
        status: false,
        type: IdentifierResolutionErrorType.script
      } : {
        bytecode: scriptResult.bytecode,
        source: scriptResult.resolve,
        status: true,
        type: IdentifierResolutionType.script
      };
    }
    return {
      error: `Unknown identifier "${identifier}".`,
      status: false,
      type: IdentifierResolutionErrorType.unknown
    };
  }
);
var compileScriptContents = ({ data, configuration, script }) => {
  const parseResult = parseScript(script);
  if (!parseResult.status) {
    return {
      errorType: "parse",
      errors: [
        {
          error: describeExpectedInput(parseResult.expected),
          range: {
            endColumn: parseResult.index.column,
            endLineNumber: parseResult.index.line,
            startColumn: parseResult.index.column,
            startLineNumber: parseResult.index.line
          }
        }
      ],
      success: false
    };
  }
  const resolver = createIdentifierResolver({ configuration, data });
  const resolvedScript = resolveScriptSegment(parseResult.value, resolver);
  const resolutionErrors = getResolutionErrors(resolvedScript);
  if (resolutionErrors.length !== 0) {
    return {
      errorType: "resolve",
      errors: resolutionErrors,
      parse: parseResult.value,
      resolve: resolvedScript,
      success: false
    };
  }
  const reduction = reduceScript(resolvedScript, configuration.vm, configuration.createAuthenticationProgram);
  return {
    ...reduction.errors === void 0 ? { bytecode: reduction.bytecode, success: true } : { errorType: "reduce", errors: reduction.errors, success: false },
    parse: parseResult.value,
    reduce: reduction,
    resolve: resolvedScript
  };
};

// node_modules/@bitauth/libauth/build/lib/language/compile.js
var compileScript = (scriptId, data, configuration) => {
  const locktimeDisablingSequenceNumber = 4294967295;
  const lockTimeTypeBecomesTimestamp = 5e8;
  if (data.compilationContext?.transaction.locktime !== void 0) {
    if (configuration.unlockingScriptTimeLockTypes?.[scriptId] === "height" && data.compilationContext.transaction.locktime >= lockTimeTypeBecomesTimestamp) {
      return {
        errorType: "parse",
        errors: [
          {
            error: `The script "${scriptId}" requires a height-based locktime (less than 500,000,000), but this transaction uses a timestamp-based locktime ("${data.compilationContext.transaction.locktime}").`,
            range: createEmptyRange()
          }
        ],
        success: false
      };
    }
    if (configuration.unlockingScriptTimeLockTypes?.[scriptId] === "timestamp" && data.compilationContext.transaction.locktime < lockTimeTypeBecomesTimestamp) {
      return {
        errorType: "parse",
        errors: [
          {
            error: `The script "${scriptId}" requires a timestamp-based locktime (greater than or equal to 500,000,000), but this transaction uses a height-based locktime ("${data.compilationContext.transaction.locktime}").`,
            range: createEmptyRange()
          }
        ],
        success: false
      };
    }
  }
  if (data.compilationContext?.transaction.inputs[data.compilationContext.inputIndex]?.sequenceNumber !== void 0 && configuration.unlockingScriptTimeLockTypes?.[scriptId] !== void 0 && // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  data.compilationContext.transaction.inputs[data.compilationContext.inputIndex].sequenceNumber === locktimeDisablingSequenceNumber) {
    return {
      errorType: "parse",
      errors: [
        {
          error: `The script "${scriptId}" requires a locktime, but this input's sequence number is set to disable transaction locktime (0xffffffff). This will cause the OP_CHECKLOCKTIMEVERIFY operation to error when the transaction is verified. To be valid, this input must use a sequence number that does not disable locktime.`,
          range: createEmptyRange()
        }
      ],
      success: false
    };
  }
  const rawResult = compileScriptRaw({
    configuration,
    data,
    scriptId
  });
  if (!rawResult.success) {
    return rawResult;
  }
  const unlocks = configuration.unlockingScripts?.[scriptId];
  const unlockingScriptType = unlocks === void 0 ? void 0 : configuration.lockingScriptTypes?.[unlocks];
  const isP2shUnlock = unlockingScriptType === "p2sh20" || unlockingScriptType === "p2sh32";
  const lockingScriptType = configuration.lockingScriptTypes?.[scriptId];
  const isP2shLock = lockingScriptType === "p2sh20" || lockingScriptType === "p2sh32";
  if (isP2shLock) {
    const transformedResult = compileScriptRaw({
      configuration: {
        ...configuration,
        scripts: {
          p2sh20Locking: "OP_HASH160 <$(<lockingBytecode> OP_HASH160)> OP_EQUAL",
          p2sh32Locking: "OP_HASH256 <$(<lockingBytecode> OP_HASH256)> OP_EQUAL"
        },
        variables: { lockingBytecode: { type: "AddressData" } }
      },
      data: { bytecode: { lockingBytecode: rawResult.bytecode } },
      scriptId: lockingScriptType === "p2sh20" ? "p2sh20Locking" : "p2sh32Locking"
    });
    if (!transformedResult.success) {
      return transformedResult;
    }
    return {
      ...rawResult,
      bytecode: transformedResult.bytecode,
      transformed: lockingScriptType === "p2sh20" ? "p2sh20-locking" : "p2sh32-locking"
    };
  }
  if (isP2shUnlock) {
    const lockingBytecodeResult = compileScriptRaw({
      configuration,
      data,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      scriptId: unlocks
    });
    if (!lockingBytecodeResult.success) {
      return lockingBytecodeResult;
    }
    const transformedResult = compileScriptRaw({
      configuration: {
        ...configuration,
        scripts: {
          p2shUnlocking: "unlockingBytecode <lockingBytecode>"
        },
        variables: {
          lockingBytecode: { type: "AddressData" },
          unlockingBytecode: { type: "AddressData" }
        }
      },
      data: {
        bytecode: {
          lockingBytecode: lockingBytecodeResult.bytecode,
          unlockingBytecode: rawResult.bytecode
        }
      },
      scriptId: "p2shUnlocking"
    });
    return {
      ...rawResult,
      bytecode: transformedResult.bytecode,
      transformed: unlockingScriptType === "p2sh20" ? "p2sh20-unlocking" : "p2sh32-unlocking"
    };
  }
  return rawResult;
};

// node_modules/@bitauth/libauth/build/lib/schema/schema.js
var import_dist349 = __toESM(require_dist(), 1);
var import_dist350 = __toESM(require_dist2(), 1);
var import_dist351 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/schema/authentication-template.js
var import_dist346 = __toESM(require_dist(), 1);
var import_dist347 = __toESM(require_dist2(), 1);
var import_dist348 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/schema/ajv/ajv-utils.js
var import_dist343 = __toESM(require_dist(), 1);
var import_dist344 = __toESM(require_dist2(), 1);
var import_dist345 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/schema/ajv/validate-authentication-template.js
var import_dist340 = __toESM(require_dist(), 1);
var import_dist341 = __toESM(require_dist2(), 1);
var import_dist342 = __toESM(require_dist3(), 1);
var validate_authentication_template_default = validate20;
var schema38 = {
  additionalProperties: false,
  properties: {
    lockingType: {
      description: 'Indicates if P2SH20 infrastructure should be used when producing bytecode related to this script. For more information on P2SH20, see BIP16.\n\nWhen compiling locking scripts of type `p2sh20`, the result will be placed in a P2SH20 "redeem script" format: `OP_HASH160 <$(<lockingBytecode> OP_HASH160)> OP_EQUAL`\n\nWhen compiling unlocking scripts that unlock locking scripts of type `p2sh20`, the result will be transformed into the P2SH20 unlocking format: `unlockingBytecode <lockingBytecode>` (where `lockingBytecode` is the compiled bytecode of the locking script, without the "redeem script" transformation.)\n\nThe presence of the `lockingType` property indicates that this script is a locking script. It must be present on any script referenced by the `unlocks` property of another script.',
      enum: ["p2sh20", "p2sh32", "standard"],
      type: "string"
    },
    name: {
      description: "A single-line, human-readable name for this script (for use in user interfaces).",
      type: "string"
    },
    script: {
      description: "The script definition in CashAssembly.",
      type: "string"
    }
  },
  required: ["lockingType", "script"],
  type: "object"
};
var schema41 = {
  additionalProperties: false,
  properties: {
    ageLock: {
      description: 'TODO: not yet implemented\n\nThe minimum input age required for this unlocking script to become valid.\n\nThis value is provided as a CashAssembly script that must compile to the least significant 3 bytes of the minimum sequence number required for this unlocking script to be valid (the "type bit" and the 2-byte "value" – see BIP68 for details). This script has access to all other template scripts and variables, but cyclical references will produce an error at compile time.\n\nIn supporting wallets, this value can be computed at address creation time, and the remaining time for which any UTXO remains "age-locked" can be displayed in user interfaces (by parsing the "type bit" and "value" as described in BIP68).\n\nNote, because the precise value used by `OP_CHECKSEQUENCEVERIFY` can be provided in the unlocking script, it is trivial to create an unlocking script for which a proper value for `ageLock` is not possible to determine until the spending transaction is prepared. These cases are intentionally out-of-scope for this property. Instead, `ageLock` should only be used for unlocking scripts where the expected value can be compiled at address creation time.',
      type: "string"
    },
    estimate: {
      description: 'The identifier of the scenario to use for this unlocking script when compiling an estimated transaction.\n\nUsing estimate scenarios, it\'s possible for wallet software to compute an "estimated transaction", an invalid transaction that is guaranteed to be the same byte length as the final transaction. This length can be used to calculate the required transaction fee and assign values to the transaction\'s change output(s). Because estimate scenarios provide "estimated" values for all variables, this estimation can be done by a single entity without input from other entities.\n\nIf not provided, the default scenario will be used for estimation. The default scenario only provides values for each `Key` and `HdKey` variable, so compilations requiring other variables will produce errors. See `AuthenticationTemplateScenario.extends` for details.',
      type: "string"
    },
    fails: {
      description: "A list of the scenario identifiers that – when used to compile this unlocking script and the script it unlocks – result in bytecode that fails program verification.\n\nThese scenarios can be used to test this script in development and review.",
      items: { type: "string" },
      type: "array"
    },
    invalid: {
      description: "A list of the scenario identifiers that – when used to compile this unlocking script and the script it unlocks – result in a compilation error.\n\nThese scenarios can be used to test this script in development and review.",
      items: { type: "string" },
      type: "array"
    },
    name: {
      description: "A single-line, human-readable name for this script (for use in user interfaces).",
      type: "string"
    },
    passes: {
      description: "A list of the scenario identifiers that – when used to compile this unlocking script and the script it unlocks – result in bytecode that passes program verification.\n\nThese scenarios can be used to test this script in development and review.",
      items: { type: "string" },
      type: "array"
    },
    script: {
      description: "The script definition in CashAssembly.",
      type: "string"
    },
    timeLockType: {
      description: "The expected type of time locks in this script.\n\nBecause `OP_CHECKLOCKTIMEVERIFY` reads from a transaction's `locktime` property, every input to a given transaction must share the same time lock type. This differs from `OP_CHECKSEQUENCEVERIFY` in that each input has its own `sequenceNumber`, so compatibility is not required.\n\nIf a transaction includes multiple inputs using scripts with `timeLockType` defined, and the types are not compatible, generation should fail.\n\nThe `timestamp` type indicates that the transaction's locktime is provided as a UNIX timestamp (the `locktime` value is greater than or equal to `500000000`).\n\nThe `height` type indicates that the transaction's locktime is provided as a block height (the `locktime` value is less than `500000000`).\n\nIf `timeLockType` is undefined, the script is assumed to have no reliance on absolute time locks.",
      enum: ["height", "timestamp"],
      type: "string"
    },
    unlocks: {
      description: "The identifier of the script that can be unlocked by this script.\n\nThe presence of the `unlocks` property indicates that this script is an unlocking script, and the script it unlocks must be a locking script.",
      type: "string"
    }
  },
  required: ["script", "unlocks"],
  type: "object"
};
var schema42 = {
  description: "Allowable identifiers for authentication virtual machine versions. The `BCH` prefix identifies the Bitcoin Cash network, the `XEC` prefix identifies the eCash network, the `BSV` prefix identifies the Bitcoin SV network, and the `BTC` prefix identifies the Bitcoin Core network. VM versions are named according to the date they were deployed on the indicated network.\n\nFor each network prefix, a `_SPEC` VM version is reserved to indicate that the template requires a custom, not-yet-deployed VM version (e.g. one or more CHIPs). By convention, templates marked for `_SPEC` VMs should indicate their requirements in the template description. After deployment of the `_SPEC` VM, when template compatibility is verified, the template's `supported` array should be updated to indicate compatibility with the live VM version.",
  enum: [
    "BCH_2020_05",
    "BCH_2021_05",
    "BCH_2022_05",
    "BCH_2023_05",
    "BCH_SPEC",
    "BSV_2020_02",
    "BSV_SPEC",
    "BTC_2017_08",
    "BTC_SPEC",
    "XEC_2020_05",
    "XEC_SPEC"
  ],
  type: "string"
};
function validate23(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  let vErrors = null;
  let errors = 0;
  const _errs0 = errors;
  let valid0 = false;
  const _errs1 = errors;
  const _errs2 = errors;
  if (errors === _errs2) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.type === void 0 && (missing0 = "type")) {
        const err0 = {
          instancePath,
          schemaPath: "#/definitions/AuthenticationTemplateAddressData/required",
          keyword: "required",
          params: { missingProperty: missing0 },
          message: "must have required property '" + missing0 + "'"
        };
        if (vErrors === null) {
          vErrors = [err0];
        } else {
          vErrors.push(err0);
        }
        errors++;
      } else {
        const _errs4 = errors;
        for (const key0 in data) {
          if (!(key0 === "description" || key0 === "name" || key0 === "type")) {
            const err1 = {
              instancePath,
              schemaPath: "#/definitions/AuthenticationTemplateAddressData/additionalProperties",
              keyword: "additionalProperties",
              params: { additionalProperty: key0 },
              message: "must NOT have additional properties"
            };
            if (vErrors === null) {
              vErrors = [err1];
            } else {
              vErrors.push(err1);
            }
            errors++;
            break;
          }
        }
        if (_errs4 === errors) {
          if (data.description !== void 0) {
            const _errs5 = errors;
            if (typeof data.description !== "string") {
              const err2 = {
                instancePath: instancePath + "/description",
                schemaPath: "#/definitions/AuthenticationTemplateAddressData/properties/description/type",
                keyword: "type",
                params: { type: "string" },
                message: "must be string"
              };
              if (vErrors === null) {
                vErrors = [err2];
              } else {
                vErrors.push(err2);
              }
              errors++;
            }
            var valid2 = _errs5 === errors;
          } else {
            var valid2 = true;
          }
          if (valid2) {
            if (data.name !== void 0) {
              const _errs7 = errors;
              if (typeof data.name !== "string") {
                const err3 = {
                  instancePath: instancePath + "/name",
                  schemaPath: "#/definitions/AuthenticationTemplateAddressData/properties/name/type",
                  keyword: "type",
                  params: { type: "string" },
                  message: "must be string"
                };
                if (vErrors === null) {
                  vErrors = [err3];
                } else {
                  vErrors.push(err3);
                }
                errors++;
              }
              var valid2 = _errs7 === errors;
            } else {
              var valid2 = true;
            }
            if (valid2) {
              if (data.type !== void 0) {
                let data2 = data.type;
                const _errs9 = errors;
                if (typeof data2 !== "string") {
                  const err4 = {
                    instancePath: instancePath + "/type",
                    schemaPath: "#/definitions/AuthenticationTemplateAddressData/properties/type/type",
                    keyword: "type",
                    params: { type: "string" },
                    message: "must be string"
                  };
                  if (vErrors === null) {
                    vErrors = [err4];
                  } else {
                    vErrors.push(err4);
                  }
                  errors++;
                }
                if ("AddressData" !== data2) {
                  const err5 = {
                    instancePath: instancePath + "/type",
                    schemaPath: "#/definitions/AuthenticationTemplateAddressData/properties/type/const",
                    keyword: "const",
                    params: { allowedValue: "AddressData" },
                    message: "must be equal to constant"
                  };
                  if (vErrors === null) {
                    vErrors = [err5];
                  } else {
                    vErrors.push(err5);
                  }
                  errors++;
                }
                var valid2 = _errs9 === errors;
              } else {
                var valid2 = true;
              }
            }
          }
        }
      }
    } else {
      const err6 = {
        instancePath,
        schemaPath: "#/definitions/AuthenticationTemplateAddressData/type",
        keyword: "type",
        params: { type: "object" },
        message: "must be object"
      };
      if (vErrors === null) {
        vErrors = [err6];
      } else {
        vErrors.push(err6);
      }
      errors++;
    }
  }
  var _valid0 = _errs1 === errors;
  valid0 = valid0 || _valid0;
  if (!valid0) {
    const _errs11 = errors;
    const _errs12 = errors;
    if (errors === _errs12) {
      if (data && typeof data == "object" && !Array.isArray(data)) {
        let missing1;
        if (data.type === void 0 && (missing1 = "type")) {
          const err7 = {
            instancePath,
            schemaPath: "#/definitions/AuthenticationTemplateHdKey/required",
            keyword: "required",
            params: { missingProperty: missing1 },
            message: "must have required property '" + missing1 + "'"
          };
          if (vErrors === null) {
            vErrors = [err7];
          } else {
            vErrors.push(err7);
          }
          errors++;
        } else {
          const _errs14 = errors;
          for (const key1 in data) {
            if (!(key1 === "addressOffset" || key1 === "description" || key1 === "hdPublicKeyDerivationPath" || key1 === "name" || key1 === "privateDerivationPath" || key1 === "publicDerivationPath" || key1 === "type")) {
              const err8 = {
                instancePath,
                schemaPath: "#/definitions/AuthenticationTemplateHdKey/additionalProperties",
                keyword: "additionalProperties",
                params: { additionalProperty: key1 },
                message: "must NOT have additional properties"
              };
              if (vErrors === null) {
                vErrors = [err8];
              } else {
                vErrors.push(err8);
              }
              errors++;
              break;
            }
          }
          if (_errs14 === errors) {
            if (data.addressOffset !== void 0) {
              let data3 = data.addressOffset;
              const _errs15 = errors;
              if (!(typeof data3 == "number" && isFinite(data3))) {
                const err9 = {
                  instancePath: instancePath + "/addressOffset",
                  schemaPath: "#/definitions/AuthenticationTemplateHdKey/properties/addressOffset/type",
                  keyword: "type",
                  params: { type: "number" },
                  message: "must be number"
                };
                if (vErrors === null) {
                  vErrors = [err9];
                } else {
                  vErrors.push(err9);
                }
                errors++;
              }
              var valid4 = _errs15 === errors;
            } else {
              var valid4 = true;
            }
            if (valid4) {
              if (data.description !== void 0) {
                const _errs17 = errors;
                if (typeof data.description !== "string") {
                  const err10 = {
                    instancePath: instancePath + "/description",
                    schemaPath: "#/definitions/AuthenticationTemplateHdKey/properties/description/type",
                    keyword: "type",
                    params: { type: "string" },
                    message: "must be string"
                  };
                  if (vErrors === null) {
                    vErrors = [err10];
                  } else {
                    vErrors.push(err10);
                  }
                  errors++;
                }
                var valid4 = _errs17 === errors;
              } else {
                var valid4 = true;
              }
              if (valid4) {
                if (data.hdPublicKeyDerivationPath !== void 0) {
                  const _errs19 = errors;
                  if (typeof data.hdPublicKeyDerivationPath !== "string") {
                    const err11 = {
                      instancePath: instancePath + "/hdPublicKeyDerivationPath",
                      schemaPath: "#/definitions/AuthenticationTemplateHdKey/properties/hdPublicKeyDerivationPath/type",
                      keyword: "type",
                      params: { type: "string" },
                      message: "must be string"
                    };
                    if (vErrors === null) {
                      vErrors = [err11];
                    } else {
                      vErrors.push(err11);
                    }
                    errors++;
                  }
                  var valid4 = _errs19 === errors;
                } else {
                  var valid4 = true;
                }
                if (valid4) {
                  if (data.name !== void 0) {
                    const _errs21 = errors;
                    if (typeof data.name !== "string") {
                      const err12 = {
                        instancePath: instancePath + "/name",
                        schemaPath: "#/definitions/AuthenticationTemplateHdKey/properties/name/type",
                        keyword: "type",
                        params: { type: "string" },
                        message: "must be string"
                      };
                      if (vErrors === null) {
                        vErrors = [err12];
                      } else {
                        vErrors.push(err12);
                      }
                      errors++;
                    }
                    var valid4 = _errs21 === errors;
                  } else {
                    var valid4 = true;
                  }
                  if (valid4) {
                    if (data.privateDerivationPath !== void 0) {
                      const _errs23 = errors;
                      if (typeof data.privateDerivationPath !== "string") {
                        const err13 = {
                          instancePath: instancePath + "/privateDerivationPath",
                          schemaPath: "#/definitions/AuthenticationTemplateHdKey/properties/privateDerivationPath/type",
                          keyword: "type",
                          params: { type: "string" },
                          message: "must be string"
                        };
                        if (vErrors === null) {
                          vErrors = [err13];
                        } else {
                          vErrors.push(err13);
                        }
                        errors++;
                      }
                      var valid4 = _errs23 === errors;
                    } else {
                      var valid4 = true;
                    }
                    if (valid4) {
                      if (data.publicDerivationPath !== void 0) {
                        const _errs25 = errors;
                        if (typeof data.publicDerivationPath !== "string") {
                          const err14 = {
                            instancePath: instancePath + "/publicDerivationPath",
                            schemaPath: "#/definitions/AuthenticationTemplateHdKey/properties/publicDerivationPath/type",
                            keyword: "type",
                            params: { type: "string" },
                            message: "must be string"
                          };
                          if (vErrors === null) {
                            vErrors = [err14];
                          } else {
                            vErrors.push(err14);
                          }
                          errors++;
                        }
                        var valid4 = _errs25 === errors;
                      } else {
                        var valid4 = true;
                      }
                      if (valid4) {
                        if (data.type !== void 0) {
                          let data9 = data.type;
                          const _errs27 = errors;
                          if (typeof data9 !== "string") {
                            const err15 = {
                              instancePath: instancePath + "/type",
                              schemaPath: "#/definitions/AuthenticationTemplateHdKey/properties/type/type",
                              keyword: "type",
                              params: { type: "string" },
                              message: "must be string"
                            };
                            if (vErrors === null) {
                              vErrors = [err15];
                            } else {
                              vErrors.push(err15);
                            }
                            errors++;
                          }
                          if ("HdKey" !== data9) {
                            const err16 = {
                              instancePath: instancePath + "/type",
                              schemaPath: "#/definitions/AuthenticationTemplateHdKey/properties/type/const",
                              keyword: "const",
                              params: { allowedValue: "HdKey" },
                              message: "must be equal to constant"
                            };
                            if (vErrors === null) {
                              vErrors = [err16];
                            } else {
                              vErrors.push(err16);
                            }
                            errors++;
                          }
                          var valid4 = _errs27 === errors;
                        } else {
                          var valid4 = true;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      } else {
        const err17 = {
          instancePath,
          schemaPath: "#/definitions/AuthenticationTemplateHdKey/type",
          keyword: "type",
          params: { type: "object" },
          message: "must be object"
        };
        if (vErrors === null) {
          vErrors = [err17];
        } else {
          vErrors.push(err17);
        }
        errors++;
      }
    }
    var _valid0 = _errs11 === errors;
    valid0 = valid0 || _valid0;
    if (!valid0) {
      const _errs29 = errors;
      const _errs30 = errors;
      if (errors === _errs30) {
        if (data && typeof data == "object" && !Array.isArray(data)) {
          let missing2;
          if (data.type === void 0 && (missing2 = "type")) {
            const err18 = {
              instancePath,
              schemaPath: "#/definitions/AuthenticationTemplateKey/required",
              keyword: "required",
              params: { missingProperty: missing2 },
              message: "must have required property '" + missing2 + "'"
            };
            if (vErrors === null) {
              vErrors = [err18];
            } else {
              vErrors.push(err18);
            }
            errors++;
          } else {
            const _errs32 = errors;
            for (const key2 in data) {
              if (!(key2 === "description" || key2 === "name" || key2 === "type")) {
                const err19 = {
                  instancePath,
                  schemaPath: "#/definitions/AuthenticationTemplateKey/additionalProperties",
                  keyword: "additionalProperties",
                  params: { additionalProperty: key2 },
                  message: "must NOT have additional properties"
                };
                if (vErrors === null) {
                  vErrors = [err19];
                } else {
                  vErrors.push(err19);
                }
                errors++;
                break;
              }
            }
            if (_errs32 === errors) {
              if (data.description !== void 0) {
                const _errs33 = errors;
                if (typeof data.description !== "string") {
                  const err20 = {
                    instancePath: instancePath + "/description",
                    schemaPath: "#/definitions/AuthenticationTemplateKey/properties/description/type",
                    keyword: "type",
                    params: { type: "string" },
                    message: "must be string"
                  };
                  if (vErrors === null) {
                    vErrors = [err20];
                  } else {
                    vErrors.push(err20);
                  }
                  errors++;
                }
                var valid6 = _errs33 === errors;
              } else {
                var valid6 = true;
              }
              if (valid6) {
                if (data.name !== void 0) {
                  const _errs35 = errors;
                  if (typeof data.name !== "string") {
                    const err21 = {
                      instancePath: instancePath + "/name",
                      schemaPath: "#/definitions/AuthenticationTemplateKey/properties/name/type",
                      keyword: "type",
                      params: { type: "string" },
                      message: "must be string"
                    };
                    if (vErrors === null) {
                      vErrors = [err21];
                    } else {
                      vErrors.push(err21);
                    }
                    errors++;
                  }
                  var valid6 = _errs35 === errors;
                } else {
                  var valid6 = true;
                }
                if (valid6) {
                  if (data.type !== void 0) {
                    let data12 = data.type;
                    const _errs37 = errors;
                    if (typeof data12 !== "string") {
                      const err22 = {
                        instancePath: instancePath + "/type",
                        schemaPath: "#/definitions/AuthenticationTemplateKey/properties/type/type",
                        keyword: "type",
                        params: { type: "string" },
                        message: "must be string"
                      };
                      if (vErrors === null) {
                        vErrors = [err22];
                      } else {
                        vErrors.push(err22);
                      }
                      errors++;
                    }
                    if ("Key" !== data12) {
                      const err23 = {
                        instancePath: instancePath + "/type",
                        schemaPath: "#/definitions/AuthenticationTemplateKey/properties/type/const",
                        keyword: "const",
                        params: { allowedValue: "Key" },
                        message: "must be equal to constant"
                      };
                      if (vErrors === null) {
                        vErrors = [err23];
                      } else {
                        vErrors.push(err23);
                      }
                      errors++;
                    }
                    var valid6 = _errs37 === errors;
                  } else {
                    var valid6 = true;
                  }
                }
              }
            }
          }
        } else {
          const err24 = {
            instancePath,
            schemaPath: "#/definitions/AuthenticationTemplateKey/type",
            keyword: "type",
            params: { type: "object" },
            message: "must be object"
          };
          if (vErrors === null) {
            vErrors = [err24];
          } else {
            vErrors.push(err24);
          }
          errors++;
        }
      }
      var _valid0 = _errs29 === errors;
      valid0 = valid0 || _valid0;
      if (!valid0) {
        const _errs39 = errors;
        const _errs40 = errors;
        if (errors === _errs40) {
          if (data && typeof data == "object" && !Array.isArray(data)) {
            let missing3;
            if (data.type === void 0 && (missing3 = "type")) {
              const err25 = {
                instancePath,
                schemaPath: "#/definitions/AuthenticationTemplateWalletData/required",
                keyword: "required",
                params: { missingProperty: missing3 },
                message: "must have required property '" + missing3 + "'"
              };
              if (vErrors === null) {
                vErrors = [err25];
              } else {
                vErrors.push(err25);
              }
              errors++;
            } else {
              const _errs42 = errors;
              for (const key3 in data) {
                if (!(key3 === "description" || key3 === "name" || key3 === "type")) {
                  const err26 = {
                    instancePath,
                    schemaPath: "#/definitions/AuthenticationTemplateWalletData/additionalProperties",
                    keyword: "additionalProperties",
                    params: { additionalProperty: key3 },
                    message: "must NOT have additional properties"
                  };
                  if (vErrors === null) {
                    vErrors = [err26];
                  } else {
                    vErrors.push(err26);
                  }
                  errors++;
                  break;
                }
              }
              if (_errs42 === errors) {
                if (data.description !== void 0) {
                  const _errs43 = errors;
                  if (typeof data.description !== "string") {
                    const err27 = {
                      instancePath: instancePath + "/description",
                      schemaPath: "#/definitions/AuthenticationTemplateWalletData/properties/description/type",
                      keyword: "type",
                      params: { type: "string" },
                      message: "must be string"
                    };
                    if (vErrors === null) {
                      vErrors = [err27];
                    } else {
                      vErrors.push(err27);
                    }
                    errors++;
                  }
                  var valid8 = _errs43 === errors;
                } else {
                  var valid8 = true;
                }
                if (valid8) {
                  if (data.name !== void 0) {
                    const _errs45 = errors;
                    if (typeof data.name !== "string") {
                      const err28 = {
                        instancePath: instancePath + "/name",
                        schemaPath: "#/definitions/AuthenticationTemplateWalletData/properties/name/type",
                        keyword: "type",
                        params: { type: "string" },
                        message: "must be string"
                      };
                      if (vErrors === null) {
                        vErrors = [err28];
                      } else {
                        vErrors.push(err28);
                      }
                      errors++;
                    }
                    var valid8 = _errs45 === errors;
                  } else {
                    var valid8 = true;
                  }
                  if (valid8) {
                    if (data.type !== void 0) {
                      let data15 = data.type;
                      const _errs47 = errors;
                      if (typeof data15 !== "string") {
                        const err29 = {
                          instancePath: instancePath + "/type",
                          schemaPath: "#/definitions/AuthenticationTemplateWalletData/properties/type/type",
                          keyword: "type",
                          params: { type: "string" },
                          message: "must be string"
                        };
                        if (vErrors === null) {
                          vErrors = [err29];
                        } else {
                          vErrors.push(err29);
                        }
                        errors++;
                      }
                      if ("WalletData" !== data15) {
                        const err30 = {
                          instancePath: instancePath + "/type",
                          schemaPath: "#/definitions/AuthenticationTemplateWalletData/properties/type/const",
                          keyword: "const",
                          params: { allowedValue: "WalletData" },
                          message: "must be equal to constant"
                        };
                        if (vErrors === null) {
                          vErrors = [err30];
                        } else {
                          vErrors.push(err30);
                        }
                        errors++;
                      }
                      var valid8 = _errs47 === errors;
                    } else {
                      var valid8 = true;
                    }
                  }
                }
              }
            }
          } else {
            const err31 = {
              instancePath,
              schemaPath: "#/definitions/AuthenticationTemplateWalletData/type",
              keyword: "type",
              params: { type: "object" },
              message: "must be object"
            };
            if (vErrors === null) {
              vErrors = [err31];
            } else {
              vErrors.push(err31);
            }
            errors++;
          }
        }
        var _valid0 = _errs39 === errors;
        valid0 = valid0 || _valid0;
      }
    }
  }
  if (!valid0) {
    const err32 = {
      instancePath,
      schemaPath: "#/anyOf",
      keyword: "anyOf",
      params: {},
      message: "must match a schema in anyOf"
    };
    if (vErrors === null) {
      vErrors = [err32];
    } else {
      vErrors.push(err32);
    }
    errors++;
    validate23.errors = vErrors;
    return false;
  } else {
    errors = _errs0;
    if (vErrors !== null) {
      if (_errs0) {
        vErrors.length = _errs0;
      } else {
        vErrors = null;
      }
    }
  }
  validate23.errors = vErrors;
  return errors === 0;
}
function validate22(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      const _errs1 = errors;
      for (const key0 in data) {
        if (!(key0 === "description" || key0 === "name" || key0 === "scripts" || key0 === "variables")) {
          validate22.errors = [
            {
              instancePath,
              schemaPath: "#/additionalProperties",
              keyword: "additionalProperties",
              params: { additionalProperty: key0 },
              message: "must NOT have additional properties"
            }
          ];
          return false;
          break;
        }
      }
      if (_errs1 === errors) {
        if (data.description !== void 0) {
          const _errs2 = errors;
          if (typeof data.description !== "string") {
            validate22.errors = [
              {
                instancePath: instancePath + "/description",
                schemaPath: "#/properties/description/type",
                keyword: "type",
                params: { type: "string" },
                message: "must be string"
              }
            ];
            return false;
          }
          var valid0 = _errs2 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.name !== void 0) {
            const _errs4 = errors;
            if (typeof data.name !== "string") {
              validate22.errors = [
                {
                  instancePath: instancePath + "/name",
                  schemaPath: "#/properties/name/type",
                  keyword: "type",
                  params: { type: "string" },
                  message: "must be string"
                }
              ];
              return false;
            }
            var valid0 = _errs4 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.scripts !== void 0) {
              let data2 = data.scripts;
              const _errs6 = errors;
              if (errors === _errs6) {
                if (Array.isArray(data2)) {
                  var valid1 = true;
                  const len0 = data2.length;
                  for (let i0 = 0; i0 < len0; i0++) {
                    const _errs8 = errors;
                    if (typeof data2[i0] !== "string") {
                      validate22.errors = [
                        {
                          instancePath: instancePath + "/scripts/" + i0,
                          schemaPath: "#/properties/scripts/items/type",
                          keyword: "type",
                          params: { type: "string" },
                          message: "must be string"
                        }
                      ];
                      return false;
                    }
                    var valid1 = _errs8 === errors;
                    if (!valid1) {
                      break;
                    }
                  }
                } else {
                  validate22.errors = [
                    {
                      instancePath: instancePath + "/scripts",
                      schemaPath: "#/properties/scripts/type",
                      keyword: "type",
                      params: { type: "array" },
                      message: "must be array"
                    }
                  ];
                  return false;
                }
              }
              var valid0 = _errs6 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.variables !== void 0) {
                let data4 = data.variables;
                const _errs10 = errors;
                if (errors === _errs10) {
                  if (data4 && typeof data4 == "object" && !Array.isArray(data4)) {
                    for (const key1 in data4) {
                      const _errs13 = errors;
                      if (!validate23(data4[key1], {
                        instancePath: instancePath + "/variables/" + key1.replace(/~/g, "~0").replace(/\//g, "~1"),
                        parentData: data4,
                        parentDataProperty: key1,
                        rootData
                      })) {
                        vErrors = vErrors === null ? validate23.errors : vErrors.concat(validate23.errors);
                        errors = vErrors.length;
                      }
                      var valid2 = _errs13 === errors;
                      if (!valid2) {
                        break;
                      }
                    }
                  } else {
                    validate22.errors = [
                      {
                        instancePath: instancePath + "/variables",
                        schemaPath: "#/properties/variables/type",
                        keyword: "type",
                        params: { type: "object" },
                        message: "must be object"
                      }
                    ];
                    return false;
                  }
                }
                var valid0 = _errs10 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate22.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: { type: "object" },
          message: "must be object"
        }
      ];
      return false;
    }
  }
  validate22.errors = vErrors;
  return errors === 0;
}
var schema32 = {
  additionalProperties: false,
  description: "An example output used to define a scenario for an authentication template.",
  properties: {
    lockingBytecode: {
      anyOf: [
        { $ref: "#/definitions/AuthenticationTemplateScenarioBytecode" },
        {
          items: { const: "slot", type: "string" },
          maxItems: 1,
          minItems: 1,
          type: "array"
        }
      ],
      description: 'The locking bytecode used to encumber this output.\n\n`lockingBytecode` values may be provided as a hexadecimal-encoded string or as an object describing the required compilation. If undefined, defaults to  `{}`, which uses the default values for `script` and `overrides`, respectively.\n\nOnly source outputs may specify a `lockingBytecode` of `["slot"]`; this identifies the source output in which the locking script under test will be placed. (To be valid, every scenario\'s `sourceOutputs` property must have exactly one source output slot and one input slot at the same index.)'
    },
    token: {
      additionalProperties: false,
      description: "The CashToken contents of this output. This property is only defined if the output contains one or more tokens. For details, see `CHIP-2022-02-CashTokens`.",
      properties: {
        amount: {
          description: 'The number of fungible tokens (of `category`) held in this output.\n\nBecause `Number.MAX_SAFE_INTEGER` (`9007199254740991`) is less than the maximum token amount (`9223372036854775807`), this value may also be provided as a string, e.g. `"9223372036854775807"`.\n\nIf undefined, this defaults to: `0`.',
          type: ["number", "string"]
        },
        category: {
          description: "The 32-byte, hexadecimal-encoded token category ID to which the token(s) in this output belong in big-endian byte order. This is the byte order typically seen in block explorers and user interfaces (as opposed to little-endian byte order, which is used in standard P2P network messages).\n\nIf undefined, this defaults to the value: `0000000000000000000000000000000000000000000000000000000000000002`",
          type: "string"
        },
        nft: {
          additionalProperties: false,
          description: "If present, the non-fungible token (NFT) held by this output. If the output does not include a non-fungible token, `undefined`.",
          properties: {
            capability: {
              description: "The capability of this non-fungible token, must be either `minting`, `mutable`, or `none`.\n\nIf undefined, this defaults to: `none`.",
              enum: ["minting", "mutable", "none"],
              type: "string"
            },
            commitment: {
              description: 'The hex-encoded commitment contents included in the non-fungible token held in this output.\n\nIf undefined, this defaults to: `""` (a zero-length commitment).',
              type: "string"
            }
          },
          type: "object"
        }
      },
      type: "object"
    },
    valueSatoshis: {
      description: 'The value of the output in satoshis, the smallest unit of bitcoin.\n\nIn a valid transaction, this is a positive integer, from `0` to the maximum number of satoshis available to the transaction.\n\nThe maximum number of satoshis in existence is about 1/4 of `Number.MAX_SAFE_INTEGER` (`9007199254740991`), so typically, this value is defined using a `number`. However, this value may also be defined using a 16-character, hexadecimal-encoded `string`, to allow for the full range of the 64-bit unsigned, little-endian integer used to encode `valueSatoshis` in the encoded output format, e.g. `"ffffffffffffffff"`. This is useful for representing scenarios where intentionally excessive values are provided (to ensure an otherwise properly-signed transaction can never be included in the blockchain), e.g. transaction size estimations or off-chain Bitauth signatures.\n\nIf undefined, this defaults to: `0`.',
      type: ["number", "string"]
    }
  },
  type: "object"
};
function validate28(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  let vErrors = null;
  let errors = 0;
  const _errs0 = errors;
  let valid0 = false;
  const _errs1 = errors;
  if (typeof data !== "string") {
    const err0 = {
      instancePath,
      schemaPath: "#/anyOf/0/type",
      keyword: "type",
      params: { type: "string" },
      message: "must be string"
    };
    if (vErrors === null) {
      vErrors = [err0];
    } else {
      vErrors.push(err0);
    }
    errors++;
  }
  var _valid0 = _errs1 === errors;
  valid0 = valid0 || _valid0;
  if (!valid0) {
    const _errs3 = errors;
    if (errors === _errs3) {
      if (data && typeof data == "object" && !Array.isArray(data)) {
        const _errs5 = errors;
        for (const key0 in data) {
          if (!(key0 === "overrides" || key0 === "script")) {
            const err1 = {
              instancePath,
              schemaPath: "#/anyOf/1/additionalProperties",
              keyword: "additionalProperties",
              params: { additionalProperty: key0 },
              message: "must NOT have additional properties"
            };
            if (vErrors === null) {
              vErrors = [err1];
            } else {
              vErrors.push(err1);
            }
            errors++;
            break;
          }
        }
        if (_errs5 === errors) {
          if (data.overrides !== void 0) {
            let data0 = data.overrides;
            const _errs6 = errors;
            const _errs7 = errors;
            if (errors === _errs7) {
              if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
                const _errs9 = errors;
                for (const key1 in data0) {
                  if (!(key1 === "bytecode" || key1 === "currentBlockHeight" || key1 === "currentBlockTime" || key1 === "hdKeys" || key1 === "keys")) {
                    const err2 = {
                      instancePath: instancePath + "/overrides",
                      schemaPath: "#/definitions/AuthenticationTemplateScenarioData/additionalProperties",
                      keyword: "additionalProperties",
                      params: { additionalProperty: key1 },
                      message: "must NOT have additional properties"
                    };
                    if (vErrors === null) {
                      vErrors = [err2];
                    } else {
                      vErrors.push(err2);
                    }
                    errors++;
                    break;
                  }
                }
                if (_errs9 === errors) {
                  if (data0.bytecode !== void 0) {
                    let data1 = data0.bytecode;
                    const _errs10 = errors;
                    if (errors === _errs10) {
                      if (data1 && typeof data1 == "object" && !Array.isArray(data1)) {
                        for (const key2 in data1) {
                          const _errs13 = errors;
                          if (typeof data1[key2] !== "string") {
                            const err3 = {
                              instancePath: instancePath + "/overrides/bytecode/" + key2.replace(/~/g, "~0").replace(/\//g, "~1"),
                              schemaPath: "#/definitions/AuthenticationTemplateScenarioData/properties/bytecode/additionalProperties/type",
                              keyword: "type",
                              params: { type: "string" },
                              message: "must be string"
                            };
                            if (vErrors === null) {
                              vErrors = [err3];
                            } else {
                              vErrors.push(err3);
                            }
                            errors++;
                          }
                          var valid4 = _errs13 === errors;
                          if (!valid4) {
                            break;
                          }
                        }
                      } else {
                        const err4 = {
                          instancePath: instancePath + "/overrides/bytecode",
                          schemaPath: "#/definitions/AuthenticationTemplateScenarioData/properties/bytecode/type",
                          keyword: "type",
                          params: { type: "object" },
                          message: "must be object"
                        };
                        if (vErrors === null) {
                          vErrors = [err4];
                        } else {
                          vErrors.push(err4);
                        }
                        errors++;
                      }
                    }
                    var valid3 = _errs10 === errors;
                  } else {
                    var valid3 = true;
                  }
                  if (valid3) {
                    if (data0.currentBlockHeight !== void 0) {
                      let data3 = data0.currentBlockHeight;
                      const _errs15 = errors;
                      if (!(typeof data3 == "number" && isFinite(data3))) {
                        const err5 = {
                          instancePath: instancePath + "/overrides/currentBlockHeight",
                          schemaPath: "#/definitions/AuthenticationTemplateScenarioData/properties/currentBlockHeight/type",
                          keyword: "type",
                          params: { type: "number" },
                          message: "must be number"
                        };
                        if (vErrors === null) {
                          vErrors = [err5];
                        } else {
                          vErrors.push(err5);
                        }
                        errors++;
                      }
                      var valid3 = _errs15 === errors;
                    } else {
                      var valid3 = true;
                    }
                    if (valid3) {
                      if (data0.currentBlockTime !== void 0) {
                        let data4 = data0.currentBlockTime;
                        const _errs17 = errors;
                        if (!(typeof data4 == "number" && isFinite(data4))) {
                          const err6 = {
                            instancePath: instancePath + "/overrides/currentBlockTime",
                            schemaPath: "#/definitions/AuthenticationTemplateScenarioData/properties/currentBlockTime/type",
                            keyword: "type",
                            params: { type: "number" },
                            message: "must be number"
                          };
                          if (vErrors === null) {
                            vErrors = [err6];
                          } else {
                            vErrors.push(err6);
                          }
                          errors++;
                        }
                        var valid3 = _errs17 === errors;
                      } else {
                        var valid3 = true;
                      }
                      if (valid3) {
                        if (data0.hdKeys !== void 0) {
                          let data5 = data0.hdKeys;
                          const _errs19 = errors;
                          if (errors === _errs19) {
                            if (data5 && typeof data5 == "object" && !Array.isArray(data5)) {
                              const _errs21 = errors;
                              for (const key3 in data5) {
                                if (!(key3 === "addressIndex" || key3 === "hdPrivateKeys" || key3 === "hdPublicKeys")) {
                                  const err7 = {
                                    instancePath: instancePath + "/overrides/hdKeys",
                                    schemaPath: "#/definitions/AuthenticationTemplateScenarioData/properties/hdKeys/additionalProperties",
                                    keyword: "additionalProperties",
                                    params: { additionalProperty: key3 },
                                    message: "must NOT have additional properties"
                                  };
                                  if (vErrors === null) {
                                    vErrors = [err7];
                                  } else {
                                    vErrors.push(err7);
                                  }
                                  errors++;
                                  break;
                                }
                              }
                              if (_errs21 === errors) {
                                if (data5.addressIndex !== void 0) {
                                  let data6 = data5.addressIndex;
                                  const _errs22 = errors;
                                  if (!(typeof data6 == "number" && isFinite(data6))) {
                                    const err8 = {
                                      instancePath: instancePath + "/overrides/hdKeys/addressIndex",
                                      schemaPath: "#/definitions/AuthenticationTemplateScenarioData/properties/hdKeys/properties/addressIndex/type",
                                      keyword: "type",
                                      params: { type: "number" },
                                      message: "must be number"
                                    };
                                    if (vErrors === null) {
                                      vErrors = [err8];
                                    } else {
                                      vErrors.push(err8);
                                    }
                                    errors++;
                                  }
                                  var valid5 = _errs22 === errors;
                                } else {
                                  var valid5 = true;
                                }
                                if (valid5) {
                                  if (data5.hdPrivateKeys !== void 0) {
                                    let data7 = data5.hdPrivateKeys;
                                    const _errs24 = errors;
                                    if (errors === _errs24) {
                                      if (data7 && typeof data7 == "object" && !Array.isArray(data7)) {
                                        for (const key4 in data7) {
                                          const _errs27 = errors;
                                          if (typeof data7[key4] !== "string") {
                                            const err9 = {
                                              instancePath: instancePath + "/overrides/hdKeys/hdPrivateKeys/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"),
                                              schemaPath: "#/definitions/AuthenticationTemplateScenarioData/properties/hdKeys/properties/hdPrivateKeys/additionalProperties/type",
                                              keyword: "type",
                                              params: { type: "string" },
                                              message: "must be string"
                                            };
                                            if (vErrors === null) {
                                              vErrors = [err9];
                                            } else {
                                              vErrors.push(err9);
                                            }
                                            errors++;
                                          }
                                          var valid6 = _errs27 === errors;
                                          if (!valid6) {
                                            break;
                                          }
                                        }
                                      } else {
                                        const err10 = {
                                          instancePath: instancePath + "/overrides/hdKeys/hdPrivateKeys",
                                          schemaPath: "#/definitions/AuthenticationTemplateScenarioData/properties/hdKeys/properties/hdPrivateKeys/type",
                                          keyword: "type",
                                          params: { type: "object" },
                                          message: "must be object"
                                        };
                                        if (vErrors === null) {
                                          vErrors = [err10];
                                        } else {
                                          vErrors.push(err10);
                                        }
                                        errors++;
                                      }
                                    }
                                    var valid5 = _errs24 === errors;
                                  } else {
                                    var valid5 = true;
                                  }
                                  if (valid5) {
                                    if (data5.hdPublicKeys !== void 0) {
                                      let data9 = data5.hdPublicKeys;
                                      const _errs29 = errors;
                                      if (errors === _errs29) {
                                        if (data9 && typeof data9 == "object" && !Array.isArray(data9)) {
                                          for (const key5 in data9) {
                                            const _errs32 = errors;
                                            if (typeof data9[key5] !== "string") {
                                              const err11 = {
                                                instancePath: instancePath + "/overrides/hdKeys/hdPublicKeys/" + key5.replace(/~/g, "~0").replace(/\//g, "~1"),
                                                schemaPath: "#/definitions/AuthenticationTemplateScenarioData/properties/hdKeys/properties/hdPublicKeys/additionalProperties/type",
                                                keyword: "type",
                                                params: { type: "string" },
                                                message: "must be string"
                                              };
                                              if (vErrors === null) {
                                                vErrors = [err11];
                                              } else {
                                                vErrors.push(err11);
                                              }
                                              errors++;
                                            }
                                            var valid7 = _errs32 === errors;
                                            if (!valid7) {
                                              break;
                                            }
                                          }
                                        } else {
                                          const err12 = {
                                            instancePath: instancePath + "/overrides/hdKeys/hdPublicKeys",
                                            schemaPath: "#/definitions/AuthenticationTemplateScenarioData/properties/hdKeys/properties/hdPublicKeys/type",
                                            keyword: "type",
                                            params: { type: "object" },
                                            message: "must be object"
                                          };
                                          if (vErrors === null) {
                                            vErrors = [err12];
                                          } else {
                                            vErrors.push(err12);
                                          }
                                          errors++;
                                        }
                                      }
                                      var valid5 = _errs29 === errors;
                                    } else {
                                      var valid5 = true;
                                    }
                                  }
                                }
                              }
                            } else {
                              const err13 = {
                                instancePath: instancePath + "/overrides/hdKeys",
                                schemaPath: "#/definitions/AuthenticationTemplateScenarioData/properties/hdKeys/type",
                                keyword: "type",
                                params: { type: "object" },
                                message: "must be object"
                              };
                              if (vErrors === null) {
                                vErrors = [err13];
                              } else {
                                vErrors.push(err13);
                              }
                              errors++;
                            }
                          }
                          var valid3 = _errs19 === errors;
                        } else {
                          var valid3 = true;
                        }
                        if (valid3) {
                          if (data0.keys !== void 0) {
                            let data11 = data0.keys;
                            const _errs34 = errors;
                            if (errors === _errs34) {
                              if (data11 && typeof data11 == "object" && !Array.isArray(data11)) {
                                const _errs36 = errors;
                                for (const key6 in data11) {
                                  if (!(key6 === "privateKeys")) {
                                    const err14 = {
                                      instancePath: instancePath + "/overrides/keys",
                                      schemaPath: "#/definitions/AuthenticationTemplateScenarioData/properties/keys/additionalProperties",
                                      keyword: "additionalProperties",
                                      params: { additionalProperty: key6 },
                                      message: "must NOT have additional properties"
                                    };
                                    if (vErrors === null) {
                                      vErrors = [err14];
                                    } else {
                                      vErrors.push(err14);
                                    }
                                    errors++;
                                    break;
                                  }
                                }
                                if (_errs36 === errors) {
                                  if (data11.privateKeys !== void 0) {
                                    let data12 = data11.privateKeys;
                                    const _errs37 = errors;
                                    if (errors === _errs37) {
                                      if (data12 && typeof data12 == "object" && !Array.isArray(data12)) {
                                        for (const key7 in data12) {
                                          const _errs40 = errors;
                                          if (typeof data12[key7] !== "string") {
                                            const err15 = {
                                              instancePath: instancePath + "/overrides/keys/privateKeys/" + key7.replace(/~/g, "~0").replace(/\//g, "~1"),
                                              schemaPath: "#/definitions/AuthenticationTemplateScenarioData/properties/keys/properties/privateKeys/additionalProperties/type",
                                              keyword: "type",
                                              params: { type: "string" },
                                              message: "must be string"
                                            };
                                            if (vErrors === null) {
                                              vErrors = [err15];
                                            } else {
                                              vErrors.push(err15);
                                            }
                                            errors++;
                                          }
                                          var valid9 = _errs40 === errors;
                                          if (!valid9) {
                                            break;
                                          }
                                        }
                                      } else {
                                        const err16 = {
                                          instancePath: instancePath + "/overrides/keys/privateKeys",
                                          schemaPath: "#/definitions/AuthenticationTemplateScenarioData/properties/keys/properties/privateKeys/type",
                                          keyword: "type",
                                          params: { type: "object" },
                                          message: "must be object"
                                        };
                                        if (vErrors === null) {
                                          vErrors = [err16];
                                        } else {
                                          vErrors.push(err16);
                                        }
                                        errors++;
                                      }
                                    }
                                  }
                                }
                              } else {
                                const err17 = {
                                  instancePath: instancePath + "/overrides/keys",
                                  schemaPath: "#/definitions/AuthenticationTemplateScenarioData/properties/keys/type",
                                  keyword: "type",
                                  params: { type: "object" },
                                  message: "must be object"
                                };
                                if (vErrors === null) {
                                  vErrors = [err17];
                                } else {
                                  vErrors.push(err17);
                                }
                                errors++;
                              }
                            }
                            var valid3 = _errs34 === errors;
                          } else {
                            var valid3 = true;
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                const err18 = {
                  instancePath: instancePath + "/overrides",
                  schemaPath: "#/definitions/AuthenticationTemplateScenarioData/type",
                  keyword: "type",
                  params: { type: "object" },
                  message: "must be object"
                };
                if (vErrors === null) {
                  vErrors = [err18];
                } else {
                  vErrors.push(err18);
                }
                errors++;
              }
            }
            var valid1 = _errs6 === errors;
          } else {
            var valid1 = true;
          }
          if (valid1) {
            if (data.script !== void 0) {
              let data14 = data.script;
              const _errs42 = errors;
              const _errs43 = errors;
              let valid10 = false;
              const _errs44 = errors;
              if (typeof data14 !== "string") {
                const err19 = {
                  instancePath: instancePath + "/script",
                  schemaPath: "#/anyOf/1/properties/script/anyOf/0/type",
                  keyword: "type",
                  params: { type: "string" },
                  message: "must be string"
                };
                if (vErrors === null) {
                  vErrors = [err19];
                } else {
                  vErrors.push(err19);
                }
                errors++;
              }
              var _valid1 = _errs44 === errors;
              valid10 = valid10 || _valid1;
              if (!valid10) {
                const _errs46 = errors;
                if (errors === _errs46) {
                  if (Array.isArray(data14)) {
                    if (data14.length > 1) {
                      const err20 = {
                        instancePath: instancePath + "/script",
                        schemaPath: "#/anyOf/1/properties/script/anyOf/1/maxItems",
                        keyword: "maxItems",
                        params: { limit: 1 },
                        message: "must NOT have more than 1 items"
                      };
                      if (vErrors === null) {
                        vErrors = [err20];
                      } else {
                        vErrors.push(err20);
                      }
                      errors++;
                    } else {
                      if (data14.length < 1) {
                        const err21 = {
                          instancePath: instancePath + "/script",
                          schemaPath: "#/anyOf/1/properties/script/anyOf/1/minItems",
                          keyword: "minItems",
                          params: { limit: 1 },
                          message: "must NOT have fewer than 1 items"
                        };
                        if (vErrors === null) {
                          vErrors = [err21];
                        } else {
                          vErrors.push(err21);
                        }
                        errors++;
                      } else {
                        var valid11 = true;
                        const len0 = data14.length;
                        for (let i0 = 0; i0 < len0; i0++) {
                          let data15 = data14[i0];
                          const _errs48 = errors;
                          if (typeof data15 !== "string") {
                            const err22 = {
                              instancePath: instancePath + "/script/" + i0,
                              schemaPath: "#/anyOf/1/properties/script/anyOf/1/items/type",
                              keyword: "type",
                              params: { type: "string" },
                              message: "must be string"
                            };
                            if (vErrors === null) {
                              vErrors = [err22];
                            } else {
                              vErrors.push(err22);
                            }
                            errors++;
                          }
                          if ("copy" !== data15) {
                            const err23 = {
                              instancePath: instancePath + "/script/" + i0,
                              schemaPath: "#/anyOf/1/properties/script/anyOf/1/items/const",
                              keyword: "const",
                              params: { allowedValue: "copy" },
                              message: "must be equal to constant"
                            };
                            if (vErrors === null) {
                              vErrors = [err23];
                            } else {
                              vErrors.push(err23);
                            }
                            errors++;
                          }
                          var valid11 = _errs48 === errors;
                          if (!valid11) {
                            break;
                          }
                        }
                      }
                    }
                  } else {
                    const err24 = {
                      instancePath: instancePath + "/script",
                      schemaPath: "#/anyOf/1/properties/script/anyOf/1/type",
                      keyword: "type",
                      params: { type: "array" },
                      message: "must be array"
                    };
                    if (vErrors === null) {
                      vErrors = [err24];
                    } else {
                      vErrors.push(err24);
                    }
                    errors++;
                  }
                }
                var _valid1 = _errs46 === errors;
                valid10 = valid10 || _valid1;
              }
              if (!valid10) {
                const err25 = {
                  instancePath: instancePath + "/script",
                  schemaPath: "#/anyOf/1/properties/script/anyOf",
                  keyword: "anyOf",
                  params: {},
                  message: "must match a schema in anyOf"
                };
                if (vErrors === null) {
                  vErrors = [err25];
                } else {
                  vErrors.push(err25);
                }
                errors++;
              } else {
                errors = _errs43;
                if (vErrors !== null) {
                  if (_errs43) {
                    vErrors.length = _errs43;
                  } else {
                    vErrors = null;
                  }
                }
              }
              var valid1 = _errs42 === errors;
            } else {
              var valid1 = true;
            }
          }
        }
      } else {
        const err26 = {
          instancePath,
          schemaPath: "#/anyOf/1/type",
          keyword: "type",
          params: { type: "object" },
          message: "must be object"
        };
        if (vErrors === null) {
          vErrors = [err26];
        } else {
          vErrors.push(err26);
        }
        errors++;
      }
    }
    var _valid0 = _errs3 === errors;
    valid0 = valid0 || _valid0;
  }
  if (!valid0) {
    const err27 = {
      instancePath,
      schemaPath: "#/anyOf",
      keyword: "anyOf",
      params: {},
      message: "must match a schema in anyOf"
    };
    if (vErrors === null) {
      vErrors = [err27];
    } else {
      vErrors.push(err27);
    }
    errors++;
    validate28.errors = vErrors;
    return false;
  } else {
    errors = _errs0;
    if (vErrors !== null) {
      if (_errs0) {
        vErrors.length = _errs0;
      } else {
        vErrors = null;
      }
    }
  }
  validate28.errors = vErrors;
  return errors === 0;
}
function validate27(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      const _errs1 = errors;
      for (const key0 in data) {
        if (!(key0 === "lockingBytecode" || key0 === "token" || key0 === "valueSatoshis")) {
          validate27.errors = [
            {
              instancePath,
              schemaPath: "#/additionalProperties",
              keyword: "additionalProperties",
              params: { additionalProperty: key0 },
              message: "must NOT have additional properties"
            }
          ];
          return false;
          break;
        }
      }
      if (_errs1 === errors) {
        if (data.lockingBytecode !== void 0) {
          let data0 = data.lockingBytecode;
          const _errs2 = errors;
          const _errs3 = errors;
          let valid1 = false;
          const _errs4 = errors;
          if (!validate28(data0, {
            instancePath: instancePath + "/lockingBytecode",
            parentData: data,
            parentDataProperty: "lockingBytecode",
            rootData
          })) {
            vErrors = vErrors === null ? validate28.errors : vErrors.concat(validate28.errors);
            errors = vErrors.length;
          }
          var _valid0 = _errs4 === errors;
          valid1 = valid1 || _valid0;
          if (!valid1) {
            const _errs5 = errors;
            if (errors === _errs5) {
              if (Array.isArray(data0)) {
                if (data0.length > 1) {
                  const err0 = {
                    instancePath: instancePath + "/lockingBytecode",
                    schemaPath: "#/properties/lockingBytecode/anyOf/1/maxItems",
                    keyword: "maxItems",
                    params: { limit: 1 },
                    message: "must NOT have more than 1 items"
                  };
                  if (vErrors === null) {
                    vErrors = [err0];
                  } else {
                    vErrors.push(err0);
                  }
                  errors++;
                } else {
                  if (data0.length < 1) {
                    const err1 = {
                      instancePath: instancePath + "/lockingBytecode",
                      schemaPath: "#/properties/lockingBytecode/anyOf/1/minItems",
                      keyword: "minItems",
                      params: { limit: 1 },
                      message: "must NOT have fewer than 1 items"
                    };
                    if (vErrors === null) {
                      vErrors = [err1];
                    } else {
                      vErrors.push(err1);
                    }
                    errors++;
                  } else {
                    var valid2 = true;
                    const len0 = data0.length;
                    for (let i0 = 0; i0 < len0; i0++) {
                      let data1 = data0[i0];
                      const _errs7 = errors;
                      if (typeof data1 !== "string") {
                        const err2 = {
                          instancePath: instancePath + "/lockingBytecode/" + i0,
                          schemaPath: "#/properties/lockingBytecode/anyOf/1/items/type",
                          keyword: "type",
                          params: { type: "string" },
                          message: "must be string"
                        };
                        if (vErrors === null) {
                          vErrors = [err2];
                        } else {
                          vErrors.push(err2);
                        }
                        errors++;
                      }
                      if ("slot" !== data1) {
                        const err3 = {
                          instancePath: instancePath + "/lockingBytecode/" + i0,
                          schemaPath: "#/properties/lockingBytecode/anyOf/1/items/const",
                          keyword: "const",
                          params: { allowedValue: "slot" },
                          message: "must be equal to constant"
                        };
                        if (vErrors === null) {
                          vErrors = [err3];
                        } else {
                          vErrors.push(err3);
                        }
                        errors++;
                      }
                      var valid2 = _errs7 === errors;
                      if (!valid2) {
                        break;
                      }
                    }
                  }
                }
              } else {
                const err4 = {
                  instancePath: instancePath + "/lockingBytecode",
                  schemaPath: "#/properties/lockingBytecode/anyOf/1/type",
                  keyword: "type",
                  params: { type: "array" },
                  message: "must be array"
                };
                if (vErrors === null) {
                  vErrors = [err4];
                } else {
                  vErrors.push(err4);
                }
                errors++;
              }
            }
            var _valid0 = _errs5 === errors;
            valid1 = valid1 || _valid0;
          }
          if (!valid1) {
            const err5 = {
              instancePath: instancePath + "/lockingBytecode",
              schemaPath: "#/properties/lockingBytecode/anyOf",
              keyword: "anyOf",
              params: {},
              message: "must match a schema in anyOf"
            };
            if (vErrors === null) {
              vErrors = [err5];
            } else {
              vErrors.push(err5);
            }
            errors++;
            validate27.errors = vErrors;
            return false;
          } else {
            errors = _errs3;
            if (vErrors !== null) {
              if (_errs3) {
                vErrors.length = _errs3;
              } else {
                vErrors = null;
              }
            }
          }
          var valid0 = _errs2 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.token !== void 0) {
            let data2 = data.token;
            const _errs9 = errors;
            if (errors === _errs9) {
              if (data2 && typeof data2 == "object" && !Array.isArray(data2)) {
                const _errs11 = errors;
                for (const key1 in data2) {
                  if (!(key1 === "amount" || key1 === "category" || key1 === "nft")) {
                    validate27.errors = [
                      {
                        instancePath: instancePath + "/token",
                        schemaPath: "#/properties/token/additionalProperties",
                        keyword: "additionalProperties",
                        params: { additionalProperty: key1 },
                        message: "must NOT have additional properties"
                      }
                    ];
                    return false;
                    break;
                  }
                }
                if (_errs11 === errors) {
                  if (data2.amount !== void 0) {
                    let data3 = data2.amount;
                    const _errs12 = errors;
                    if (!(typeof data3 == "number" && isFinite(data3)) && typeof data3 !== "string") {
                      validate27.errors = [
                        {
                          instancePath: instancePath + "/token/amount",
                          schemaPath: "#/properties/token/properties/amount/type",
                          keyword: "type",
                          params: {
                            type: schema32.properties.token.properties.amount.type
                          },
                          message: "must be number,string"
                        }
                      ];
                      return false;
                    }
                    var valid3 = _errs12 === errors;
                  } else {
                    var valid3 = true;
                  }
                  if (valid3) {
                    if (data2.category !== void 0) {
                      const _errs14 = errors;
                      if (typeof data2.category !== "string") {
                        validate27.errors = [
                          {
                            instancePath: instancePath + "/token/category",
                            schemaPath: "#/properties/token/properties/category/type",
                            keyword: "type",
                            params: { type: "string" },
                            message: "must be string"
                          }
                        ];
                        return false;
                      }
                      var valid3 = _errs14 === errors;
                    } else {
                      var valid3 = true;
                    }
                    if (valid3) {
                      if (data2.nft !== void 0) {
                        let data5 = data2.nft;
                        const _errs16 = errors;
                        if (errors === _errs16) {
                          if (data5 && typeof data5 == "object" && !Array.isArray(data5)) {
                            const _errs18 = errors;
                            for (const key2 in data5) {
                              if (!(key2 === "capability" || key2 === "commitment")) {
                                validate27.errors = [
                                  {
                                    instancePath: instancePath + "/token/nft",
                                    schemaPath: "#/properties/token/properties/nft/additionalProperties",
                                    keyword: "additionalProperties",
                                    params: { additionalProperty: key2 },
                                    message: "must NOT have additional properties"
                                  }
                                ];
                                return false;
                                break;
                              }
                            }
                            if (_errs18 === errors) {
                              if (data5.capability !== void 0) {
                                let data6 = data5.capability;
                                const _errs19 = errors;
                                if (typeof data6 !== "string") {
                                  validate27.errors = [
                                    {
                                      instancePath: instancePath + "/token/nft/capability",
                                      schemaPath: "#/properties/token/properties/nft/properties/capability/type",
                                      keyword: "type",
                                      params: { type: "string" },
                                      message: "must be string"
                                    }
                                  ];
                                  return false;
                                }
                                if (!(data6 === "minting" || data6 === "mutable" || data6 === "none")) {
                                  validate27.errors = [
                                    {
                                      instancePath: instancePath + "/token/nft/capability",
                                      schemaPath: "#/properties/token/properties/nft/properties/capability/enum",
                                      keyword: "enum",
                                      params: {
                                        allowedValues: schema32.properties.token.properties.nft.properties.capability.enum
                                      },
                                      message: "must be equal to one of the allowed values"
                                    }
                                  ];
                                  return false;
                                }
                                var valid4 = _errs19 === errors;
                              } else {
                                var valid4 = true;
                              }
                              if (valid4) {
                                if (data5.commitment !== void 0) {
                                  const _errs21 = errors;
                                  if (typeof data5.commitment !== "string") {
                                    validate27.errors = [
                                      {
                                        instancePath: instancePath + "/token/nft/commitment",
                                        schemaPath: "#/properties/token/properties/nft/properties/commitment/type",
                                        keyword: "type",
                                        params: { type: "string" },
                                        message: "must be string"
                                      }
                                    ];
                                    return false;
                                  }
                                  var valid4 = _errs21 === errors;
                                } else {
                                  var valid4 = true;
                                }
                              }
                            }
                          } else {
                            validate27.errors = [
                              {
                                instancePath: instancePath + "/token/nft",
                                schemaPath: "#/properties/token/properties/nft/type",
                                keyword: "type",
                                params: { type: "object" },
                                message: "must be object"
                              }
                            ];
                            return false;
                          }
                        }
                        var valid3 = _errs16 === errors;
                      } else {
                        var valid3 = true;
                      }
                    }
                  }
                }
              } else {
                validate27.errors = [
                  {
                    instancePath: instancePath + "/token",
                    schemaPath: "#/properties/token/type",
                    keyword: "type",
                    params: { type: "object" },
                    message: "must be object"
                  }
                ];
                return false;
              }
            }
            var valid0 = _errs9 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.valueSatoshis !== void 0) {
              let data8 = data.valueSatoshis;
              const _errs23 = errors;
              if (!(typeof data8 == "number" && isFinite(data8)) && typeof data8 !== "string") {
                validate27.errors = [
                  {
                    instancePath: instancePath + "/valueSatoshis",
                    schemaPath: "#/properties/valueSatoshis/type",
                    keyword: "type",
                    params: { type: schema32.properties.valueSatoshis.type },
                    message: "must be number,string"
                  }
                ];
                return false;
              }
              var valid0 = _errs23 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate27.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: { type: "object" },
          message: "must be object"
        }
      ];
      return false;
    }
  }
  validate27.errors = vErrors;
  return errors === 0;
}
function validate31(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      const _errs1 = errors;
      for (const key0 in data) {
        if (!(key0 === "outpointIndex" || key0 === "outpointTransactionHash" || key0 === "sequenceNumber" || key0 === "unlockingBytecode")) {
          validate31.errors = [
            {
              instancePath,
              schemaPath: "#/additionalProperties",
              keyword: "additionalProperties",
              params: { additionalProperty: key0 },
              message: "must NOT have additional properties"
            }
          ];
          return false;
          break;
        }
      }
      if (_errs1 === errors) {
        if (data.outpointIndex !== void 0) {
          let data0 = data.outpointIndex;
          const _errs2 = errors;
          if (!(typeof data0 == "number" && isFinite(data0))) {
            validate31.errors = [
              {
                instancePath: instancePath + "/outpointIndex",
                schemaPath: "#/properties/outpointIndex/type",
                keyword: "type",
                params: { type: "number" },
                message: "must be number"
              }
            ];
            return false;
          }
          var valid0 = _errs2 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.outpointTransactionHash !== void 0) {
            const _errs4 = errors;
            if (typeof data.outpointTransactionHash !== "string") {
              validate31.errors = [
                {
                  instancePath: instancePath + "/outpointTransactionHash",
                  schemaPath: "#/properties/outpointTransactionHash/type",
                  keyword: "type",
                  params: { type: "string" },
                  message: "must be string"
                }
              ];
              return false;
            }
            var valid0 = _errs4 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.sequenceNumber !== void 0) {
              let data2 = data.sequenceNumber;
              const _errs6 = errors;
              if (!(typeof data2 == "number" && isFinite(data2))) {
                validate31.errors = [
                  {
                    instancePath: instancePath + "/sequenceNumber",
                    schemaPath: "#/properties/sequenceNumber/type",
                    keyword: "type",
                    params: { type: "number" },
                    message: "must be number"
                  }
                ];
                return false;
              }
              var valid0 = _errs6 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.unlockingBytecode !== void 0) {
                let data3 = data.unlockingBytecode;
                const _errs8 = errors;
                const _errs9 = errors;
                let valid1 = false;
                const _errs10 = errors;
                if (!validate28(data3, {
                  instancePath: instancePath + "/unlockingBytecode",
                  parentData: data,
                  parentDataProperty: "unlockingBytecode",
                  rootData
                })) {
                  vErrors = vErrors === null ? validate28.errors : vErrors.concat(validate28.errors);
                  errors = vErrors.length;
                }
                var _valid0 = _errs10 === errors;
                valid1 = valid1 || _valid0;
                if (!valid1) {
                  const _errs11 = errors;
                  if (errors === _errs11) {
                    if (Array.isArray(data3)) {
                      if (data3.length > 1) {
                        const err0 = {
                          instancePath: instancePath + "/unlockingBytecode",
                          schemaPath: "#/properties/unlockingBytecode/anyOf/1/maxItems",
                          keyword: "maxItems",
                          params: { limit: 1 },
                          message: "must NOT have more than 1 items"
                        };
                        if (vErrors === null) {
                          vErrors = [err0];
                        } else {
                          vErrors.push(err0);
                        }
                        errors++;
                      } else {
                        if (data3.length < 1) {
                          const err1 = {
                            instancePath: instancePath + "/unlockingBytecode",
                            schemaPath: "#/properties/unlockingBytecode/anyOf/1/minItems",
                            keyword: "minItems",
                            params: { limit: 1 },
                            message: "must NOT have fewer than 1 items"
                          };
                          if (vErrors === null) {
                            vErrors = [err1];
                          } else {
                            vErrors.push(err1);
                          }
                          errors++;
                        } else {
                          var valid2 = true;
                          const len0 = data3.length;
                          for (let i0 = 0; i0 < len0; i0++) {
                            let data4 = data3[i0];
                            const _errs13 = errors;
                            if (typeof data4 !== "string") {
                              const err2 = {
                                instancePath: instancePath + "/unlockingBytecode/" + i0,
                                schemaPath: "#/properties/unlockingBytecode/anyOf/1/items/type",
                                keyword: "type",
                                params: { type: "string" },
                                message: "must be string"
                              };
                              if (vErrors === null) {
                                vErrors = [err2];
                              } else {
                                vErrors.push(err2);
                              }
                              errors++;
                            }
                            if ("slot" !== data4) {
                              const err3 = {
                                instancePath: instancePath + "/unlockingBytecode/" + i0,
                                schemaPath: "#/properties/unlockingBytecode/anyOf/1/items/const",
                                keyword: "const",
                                params: { allowedValue: "slot" },
                                message: "must be equal to constant"
                              };
                              if (vErrors === null) {
                                vErrors = [err3];
                              } else {
                                vErrors.push(err3);
                              }
                              errors++;
                            }
                            var valid2 = _errs13 === errors;
                            if (!valid2) {
                              break;
                            }
                          }
                        }
                      }
                    } else {
                      const err4 = {
                        instancePath: instancePath + "/unlockingBytecode",
                        schemaPath: "#/properties/unlockingBytecode/anyOf/1/type",
                        keyword: "type",
                        params: { type: "array" },
                        message: "must be array"
                      };
                      if (vErrors === null) {
                        vErrors = [err4];
                      } else {
                        vErrors.push(err4);
                      }
                      errors++;
                    }
                  }
                  var _valid0 = _errs11 === errors;
                  valid1 = valid1 || _valid0;
                }
                if (!valid1) {
                  const err5 = {
                    instancePath: instancePath + "/unlockingBytecode",
                    schemaPath: "#/properties/unlockingBytecode/anyOf",
                    keyword: "anyOf",
                    params: {},
                    message: "must match a schema in anyOf"
                  };
                  if (vErrors === null) {
                    vErrors = [err5];
                  } else {
                    vErrors.push(err5);
                  }
                  errors++;
                  validate31.errors = vErrors;
                  return false;
                } else {
                  errors = _errs9;
                  if (vErrors !== null) {
                    if (_errs9) {
                      vErrors.length = _errs9;
                    } else {
                      vErrors = null;
                    }
                  }
                }
                var valid0 = _errs8 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate31.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: { type: "object" },
          message: "must be object"
        }
      ];
      return false;
    }
  }
  validate31.errors = vErrors;
  return errors === 0;
}
var schema36 = {
  additionalProperties: false,
  description: "An example output used to define a scenario for an authentication template.",
  properties: {
    lockingBytecode: {
      $ref: "#/definitions/AuthenticationTemplateScenarioBytecode",
      description: 'The locking bytecode used to encumber this output.\n\n`lockingBytecode` values may be provided as a hexadecimal-encoded string or as an object describing the required compilation. If undefined, defaults to  `{}`, which uses the default values for `script` and `overrides`, respectively.\n\nOnly source outputs may specify a `lockingBytecode` of `["slot"]`; this identifies the source output in which the locking script under test will be placed. (To be valid, every scenario\'s `sourceOutputs` property must have exactly one source output slot and one input slot at the same index.)'
    },
    token: {
      additionalProperties: false,
      description: "The CashToken contents of this output. This property is only defined if the output contains one or more tokens. For details, see `CHIP-2022-02-CashTokens`.",
      properties: {
        amount: {
          description: 'The number of fungible tokens (of `category`) held in this output.\n\nBecause `Number.MAX_SAFE_INTEGER` (`9007199254740991`) is less than the maximum token amount (`9223372036854775807`), this value may also be provided as a string, e.g. `"9223372036854775807"`.\n\nIf undefined, this defaults to: `0`.',
          type: ["number", "string"]
        },
        category: {
          description: "The 32-byte, hexadecimal-encoded token category ID to which the token(s) in this output belong in big-endian byte order. This is the byte order typically seen in block explorers and user interfaces (as opposed to little-endian byte order, which is used in standard P2P network messages).\n\nIf undefined, this defaults to the value: `0000000000000000000000000000000000000000000000000000000000000002`",
          type: "string"
        },
        nft: {
          additionalProperties: false,
          description: "If present, the non-fungible token (NFT) held by this output. If the output does not include a non-fungible token, `undefined`.",
          properties: {
            capability: {
              description: "The capability of this non-fungible token, must be either `minting`, `mutable`, or `none`.\n\nIf undefined, this defaults to: `none`.",
              enum: ["minting", "mutable", "none"],
              type: "string"
            },
            commitment: {
              description: 'The hex-encoded commitment contents included in the non-fungible token held in this output.\n\nIf undefined, this defaults to: `""` (a zero-length commitment).',
              type: "string"
            }
          },
          type: "object"
        }
      },
      type: "object"
    },
    valueSatoshis: {
      description: 'The value of the output in satoshis, the smallest unit of bitcoin.\n\nIn a valid transaction, this is a positive integer, from `0` to the maximum number of satoshis available to the transaction.\n\nThe maximum number of satoshis in existence is about 1/4 of `Number.MAX_SAFE_INTEGER` (`9007199254740991`), so typically, this value is defined using a `number`. However, this value may also be defined using a 16-character, hexadecimal-encoded `string`, to allow for the full range of the 64-bit unsigned, little-endian integer used to encode `valueSatoshis` in the encoded output format, e.g. `"ffffffffffffffff"`. This is useful for representing scenarios where intentionally excessive values are provided (to ensure an otherwise properly-signed transaction can never be included in the blockchain), e.g. transaction size estimations or off-chain Bitauth signatures.\n\nIf undefined, this defaults to: `0`.',
      type: ["number", "string"]
    }
  },
  type: "object"
};
function validate34(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      const _errs1 = errors;
      for (const key0 in data) {
        if (!(key0 === "lockingBytecode" || key0 === "token" || key0 === "valueSatoshis")) {
          validate34.errors = [
            {
              instancePath,
              schemaPath: "#/additionalProperties",
              keyword: "additionalProperties",
              params: { additionalProperty: key0 },
              message: "must NOT have additional properties"
            }
          ];
          return false;
          break;
        }
      }
      if (_errs1 === errors) {
        if (data.lockingBytecode !== void 0) {
          const _errs2 = errors;
          if (!validate28(data.lockingBytecode, {
            instancePath: instancePath + "/lockingBytecode",
            parentData: data,
            parentDataProperty: "lockingBytecode",
            rootData
          })) {
            vErrors = vErrors === null ? validate28.errors : vErrors.concat(validate28.errors);
            errors = vErrors.length;
          }
          var valid0 = _errs2 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.token !== void 0) {
            let data1 = data.token;
            const _errs3 = errors;
            if (errors === _errs3) {
              if (data1 && typeof data1 == "object" && !Array.isArray(data1)) {
                const _errs5 = errors;
                for (const key1 in data1) {
                  if (!(key1 === "amount" || key1 === "category" || key1 === "nft")) {
                    validate34.errors = [
                      {
                        instancePath: instancePath + "/token",
                        schemaPath: "#/properties/token/additionalProperties",
                        keyword: "additionalProperties",
                        params: { additionalProperty: key1 },
                        message: "must NOT have additional properties"
                      }
                    ];
                    return false;
                    break;
                  }
                }
                if (_errs5 === errors) {
                  if (data1.amount !== void 0) {
                    let data2 = data1.amount;
                    const _errs6 = errors;
                    if (!(typeof data2 == "number" && isFinite(data2)) && typeof data2 !== "string") {
                      validate34.errors = [
                        {
                          instancePath: instancePath + "/token/amount",
                          schemaPath: "#/properties/token/properties/amount/type",
                          keyword: "type",
                          params: {
                            type: schema36.properties.token.properties.amount.type
                          },
                          message: "must be number,string"
                        }
                      ];
                      return false;
                    }
                    var valid1 = _errs6 === errors;
                  } else {
                    var valid1 = true;
                  }
                  if (valid1) {
                    if (data1.category !== void 0) {
                      const _errs8 = errors;
                      if (typeof data1.category !== "string") {
                        validate34.errors = [
                          {
                            instancePath: instancePath + "/token/category",
                            schemaPath: "#/properties/token/properties/category/type",
                            keyword: "type",
                            params: { type: "string" },
                            message: "must be string"
                          }
                        ];
                        return false;
                      }
                      var valid1 = _errs8 === errors;
                    } else {
                      var valid1 = true;
                    }
                    if (valid1) {
                      if (data1.nft !== void 0) {
                        let data4 = data1.nft;
                        const _errs10 = errors;
                        if (errors === _errs10) {
                          if (data4 && typeof data4 == "object" && !Array.isArray(data4)) {
                            const _errs12 = errors;
                            for (const key2 in data4) {
                              if (!(key2 === "capability" || key2 === "commitment")) {
                                validate34.errors = [
                                  {
                                    instancePath: instancePath + "/token/nft",
                                    schemaPath: "#/properties/token/properties/nft/additionalProperties",
                                    keyword: "additionalProperties",
                                    params: { additionalProperty: key2 },
                                    message: "must NOT have additional properties"
                                  }
                                ];
                                return false;
                                break;
                              }
                            }
                            if (_errs12 === errors) {
                              if (data4.capability !== void 0) {
                                let data5 = data4.capability;
                                const _errs13 = errors;
                                if (typeof data5 !== "string") {
                                  validate34.errors = [
                                    {
                                      instancePath: instancePath + "/token/nft/capability",
                                      schemaPath: "#/properties/token/properties/nft/properties/capability/type",
                                      keyword: "type",
                                      params: { type: "string" },
                                      message: "must be string"
                                    }
                                  ];
                                  return false;
                                }
                                if (!(data5 === "minting" || data5 === "mutable" || data5 === "none")) {
                                  validate34.errors = [
                                    {
                                      instancePath: instancePath + "/token/nft/capability",
                                      schemaPath: "#/properties/token/properties/nft/properties/capability/enum",
                                      keyword: "enum",
                                      params: {
                                        allowedValues: schema36.properties.token.properties.nft.properties.capability.enum
                                      },
                                      message: "must be equal to one of the allowed values"
                                    }
                                  ];
                                  return false;
                                }
                                var valid2 = _errs13 === errors;
                              } else {
                                var valid2 = true;
                              }
                              if (valid2) {
                                if (data4.commitment !== void 0) {
                                  const _errs15 = errors;
                                  if (typeof data4.commitment !== "string") {
                                    validate34.errors = [
                                      {
                                        instancePath: instancePath + "/token/nft/commitment",
                                        schemaPath: "#/properties/token/properties/nft/properties/commitment/type",
                                        keyword: "type",
                                        params: { type: "string" },
                                        message: "must be string"
                                      }
                                    ];
                                    return false;
                                  }
                                  var valid2 = _errs15 === errors;
                                } else {
                                  var valid2 = true;
                                }
                              }
                            }
                          } else {
                            validate34.errors = [
                              {
                                instancePath: instancePath + "/token/nft",
                                schemaPath: "#/properties/token/properties/nft/type",
                                keyword: "type",
                                params: { type: "object" },
                                message: "must be object"
                              }
                            ];
                            return false;
                          }
                        }
                        var valid1 = _errs10 === errors;
                      } else {
                        var valid1 = true;
                      }
                    }
                  }
                }
              } else {
                validate34.errors = [
                  {
                    instancePath: instancePath + "/token",
                    schemaPath: "#/properties/token/type",
                    keyword: "type",
                    params: { type: "object" },
                    message: "must be object"
                  }
                ];
                return false;
              }
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.valueSatoshis !== void 0) {
              let data7 = data.valueSatoshis;
              const _errs17 = errors;
              if (!(typeof data7 == "number" && isFinite(data7)) && typeof data7 !== "string") {
                validate34.errors = [
                  {
                    instancePath: instancePath + "/valueSatoshis",
                    schemaPath: "#/properties/valueSatoshis/type",
                    keyword: "type",
                    params: { type: schema36.properties.valueSatoshis.type },
                    message: "must be number,string"
                  }
                ];
                return false;
              }
              var valid0 = _errs17 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate34.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: { type: "object" },
          message: "must be object"
        }
      ];
      return false;
    }
  }
  validate34.errors = vErrors;
  return errors === 0;
}
function validate26(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      const _errs1 = errors;
      for (const key0 in data) {
        if (!(key0 === "data" || key0 === "description" || key0 === "extends" || key0 === "name" || key0 === "sourceOutputs" || key0 === "transaction")) {
          validate26.errors = [
            {
              instancePath,
              schemaPath: "#/additionalProperties",
              keyword: "additionalProperties",
              params: { additionalProperty: key0 },
              message: "must NOT have additional properties"
            }
          ];
          return false;
          break;
        }
      }
      if (_errs1 === errors) {
        if (data.data !== void 0) {
          let data0 = data.data;
          const _errs2 = errors;
          const _errs3 = errors;
          if (errors === _errs3) {
            if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
              const _errs5 = errors;
              for (const key1 in data0) {
                if (!(key1 === "bytecode" || key1 === "currentBlockHeight" || key1 === "currentBlockTime" || key1 === "hdKeys" || key1 === "keys")) {
                  validate26.errors = [
                    {
                      instancePath: instancePath + "/data",
                      schemaPath: "#/definitions/AuthenticationTemplateScenarioData/additionalProperties",
                      keyword: "additionalProperties",
                      params: { additionalProperty: key1 },
                      message: "must NOT have additional properties"
                    }
                  ];
                  return false;
                  break;
                }
              }
              if (_errs5 === errors) {
                if (data0.bytecode !== void 0) {
                  let data1 = data0.bytecode;
                  const _errs6 = errors;
                  if (errors === _errs6) {
                    if (data1 && typeof data1 == "object" && !Array.isArray(data1)) {
                      for (const key2 in data1) {
                        const _errs9 = errors;
                        if (typeof data1[key2] !== "string") {
                          validate26.errors = [
                            {
                              instancePath: instancePath + "/data/bytecode/" + key2.replace(/~/g, "~0").replace(/\//g, "~1"),
                              schemaPath: "#/definitions/AuthenticationTemplateScenarioData/properties/bytecode/additionalProperties/type",
                              keyword: "type",
                              params: { type: "string" },
                              message: "must be string"
                            }
                          ];
                          return false;
                        }
                        var valid3 = _errs9 === errors;
                        if (!valid3) {
                          break;
                        }
                      }
                    } else {
                      validate26.errors = [
                        {
                          instancePath: instancePath + "/data/bytecode",
                          schemaPath: "#/definitions/AuthenticationTemplateScenarioData/properties/bytecode/type",
                          keyword: "type",
                          params: { type: "object" },
                          message: "must be object"
                        }
                      ];
                      return false;
                    }
                  }
                  var valid2 = _errs6 === errors;
                } else {
                  var valid2 = true;
                }
                if (valid2) {
                  if (data0.currentBlockHeight !== void 0) {
                    let data3 = data0.currentBlockHeight;
                    const _errs11 = errors;
                    if (!(typeof data3 == "number" && isFinite(data3))) {
                      validate26.errors = [
                        {
                          instancePath: instancePath + "/data/currentBlockHeight",
                          schemaPath: "#/definitions/AuthenticationTemplateScenarioData/properties/currentBlockHeight/type",
                          keyword: "type",
                          params: { type: "number" },
                          message: "must be number"
                        }
                      ];
                      return false;
                    }
                    var valid2 = _errs11 === errors;
                  } else {
                    var valid2 = true;
                  }
                  if (valid2) {
                    if (data0.currentBlockTime !== void 0) {
                      let data4 = data0.currentBlockTime;
                      const _errs13 = errors;
                      if (!(typeof data4 == "number" && isFinite(data4))) {
                        validate26.errors = [
                          {
                            instancePath: instancePath + "/data/currentBlockTime",
                            schemaPath: "#/definitions/AuthenticationTemplateScenarioData/properties/currentBlockTime/type",
                            keyword: "type",
                            params: { type: "number" },
                            message: "must be number"
                          }
                        ];
                        return false;
                      }
                      var valid2 = _errs13 === errors;
                    } else {
                      var valid2 = true;
                    }
                    if (valid2) {
                      if (data0.hdKeys !== void 0) {
                        let data5 = data0.hdKeys;
                        const _errs15 = errors;
                        if (errors === _errs15) {
                          if (data5 && typeof data5 == "object" && !Array.isArray(data5)) {
                            const _errs17 = errors;
                            for (const key3 in data5) {
                              if (!(key3 === "addressIndex" || key3 === "hdPrivateKeys" || key3 === "hdPublicKeys")) {
                                validate26.errors = [
                                  {
                                    instancePath: instancePath + "/data/hdKeys",
                                    schemaPath: "#/definitions/AuthenticationTemplateScenarioData/properties/hdKeys/additionalProperties",
                                    keyword: "additionalProperties",
                                    params: { additionalProperty: key3 },
                                    message: "must NOT have additional properties"
                                  }
                                ];
                                return false;
                                break;
                              }
                            }
                            if (_errs17 === errors) {
                              if (data5.addressIndex !== void 0) {
                                let data6 = data5.addressIndex;
                                const _errs18 = errors;
                                if (!(typeof data6 == "number" && isFinite(data6))) {
                                  validate26.errors = [
                                    {
                                      instancePath: instancePath + "/data/hdKeys/addressIndex",
                                      schemaPath: "#/definitions/AuthenticationTemplateScenarioData/properties/hdKeys/properties/addressIndex/type",
                                      keyword: "type",
                                      params: { type: "number" },
                                      message: "must be number"
                                    }
                                  ];
                                  return false;
                                }
                                var valid4 = _errs18 === errors;
                              } else {
                                var valid4 = true;
                              }
                              if (valid4) {
                                if (data5.hdPrivateKeys !== void 0) {
                                  let data7 = data5.hdPrivateKeys;
                                  const _errs20 = errors;
                                  if (errors === _errs20) {
                                    if (data7 && typeof data7 == "object" && !Array.isArray(data7)) {
                                      for (const key4 in data7) {
                                        const _errs23 = errors;
                                        if (typeof data7[key4] !== "string") {
                                          validate26.errors = [
                                            {
                                              instancePath: instancePath + "/data/hdKeys/hdPrivateKeys/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"),
                                              schemaPath: "#/definitions/AuthenticationTemplateScenarioData/properties/hdKeys/properties/hdPrivateKeys/additionalProperties/type",
                                              keyword: "type",
                                              params: { type: "string" },
                                              message: "must be string"
                                            }
                                          ];
                                          return false;
                                        }
                                        var valid5 = _errs23 === errors;
                                        if (!valid5) {
                                          break;
                                        }
                                      }
                                    } else {
                                      validate26.errors = [
                                        {
                                          instancePath: instancePath + "/data/hdKeys/hdPrivateKeys",
                                          schemaPath: "#/definitions/AuthenticationTemplateScenarioData/properties/hdKeys/properties/hdPrivateKeys/type",
                                          keyword: "type",
                                          params: { type: "object" },
                                          message: "must be object"
                                        }
                                      ];
                                      return false;
                                    }
                                  }
                                  var valid4 = _errs20 === errors;
                                } else {
                                  var valid4 = true;
                                }
                                if (valid4) {
                                  if (data5.hdPublicKeys !== void 0) {
                                    let data9 = data5.hdPublicKeys;
                                    const _errs25 = errors;
                                    if (errors === _errs25) {
                                      if (data9 && typeof data9 == "object" && !Array.isArray(data9)) {
                                        for (const key5 in data9) {
                                          const _errs28 = errors;
                                          if (typeof data9[key5] !== "string") {
                                            validate26.errors = [
                                              {
                                                instancePath: instancePath + "/data/hdKeys/hdPublicKeys/" + key5.replace(/~/g, "~0").replace(/\//g, "~1"),
                                                schemaPath: "#/definitions/AuthenticationTemplateScenarioData/properties/hdKeys/properties/hdPublicKeys/additionalProperties/type",
                                                keyword: "type",
                                                params: { type: "string" },
                                                message: "must be string"
                                              }
                                            ];
                                            return false;
                                          }
                                          var valid6 = _errs28 === errors;
                                          if (!valid6) {
                                            break;
                                          }
                                        }
                                      } else {
                                        validate26.errors = [
                                          {
                                            instancePath: instancePath + "/data/hdKeys/hdPublicKeys",
                                            schemaPath: "#/definitions/AuthenticationTemplateScenarioData/properties/hdKeys/properties/hdPublicKeys/type",
                                            keyword: "type",
                                            params: { type: "object" },
                                            message: "must be object"
                                          }
                                        ];
                                        return false;
                                      }
                                    }
                                    var valid4 = _errs25 === errors;
                                  } else {
                                    var valid4 = true;
                                  }
                                }
                              }
                            }
                          } else {
                            validate26.errors = [
                              {
                                instancePath: instancePath + "/data/hdKeys",
                                schemaPath: "#/definitions/AuthenticationTemplateScenarioData/properties/hdKeys/type",
                                keyword: "type",
                                params: { type: "object" },
                                message: "must be object"
                              }
                            ];
                            return false;
                          }
                        }
                        var valid2 = _errs15 === errors;
                      } else {
                        var valid2 = true;
                      }
                      if (valid2) {
                        if (data0.keys !== void 0) {
                          let data11 = data0.keys;
                          const _errs30 = errors;
                          if (errors === _errs30) {
                            if (data11 && typeof data11 == "object" && !Array.isArray(data11)) {
                              const _errs32 = errors;
                              for (const key6 in data11) {
                                if (!(key6 === "privateKeys")) {
                                  validate26.errors = [
                                    {
                                      instancePath: instancePath + "/data/keys",
                                      schemaPath: "#/definitions/AuthenticationTemplateScenarioData/properties/keys/additionalProperties",
                                      keyword: "additionalProperties",
                                      params: { additionalProperty: key6 },
                                      message: "must NOT have additional properties"
                                    }
                                  ];
                                  return false;
                                  break;
                                }
                              }
                              if (_errs32 === errors) {
                                if (data11.privateKeys !== void 0) {
                                  let data12 = data11.privateKeys;
                                  const _errs33 = errors;
                                  if (errors === _errs33) {
                                    if (data12 && typeof data12 == "object" && !Array.isArray(data12)) {
                                      for (const key7 in data12) {
                                        const _errs36 = errors;
                                        if (typeof data12[key7] !== "string") {
                                          validate26.errors = [
                                            {
                                              instancePath: instancePath + "/data/keys/privateKeys/" + key7.replace(/~/g, "~0").replace(/\//g, "~1"),
                                              schemaPath: "#/definitions/AuthenticationTemplateScenarioData/properties/keys/properties/privateKeys/additionalProperties/type",
                                              keyword: "type",
                                              params: { type: "string" },
                                              message: "must be string"
                                            }
                                          ];
                                          return false;
                                        }
                                        var valid8 = _errs36 === errors;
                                        if (!valid8) {
                                          break;
                                        }
                                      }
                                    } else {
                                      validate26.errors = [
                                        {
                                          instancePath: instancePath + "/data/keys/privateKeys",
                                          schemaPath: "#/definitions/AuthenticationTemplateScenarioData/properties/keys/properties/privateKeys/type",
                                          keyword: "type",
                                          params: { type: "object" },
                                          message: "must be object"
                                        }
                                      ];
                                      return false;
                                    }
                                  }
                                }
                              }
                            } else {
                              validate26.errors = [
                                {
                                  instancePath: instancePath + "/data/keys",
                                  schemaPath: "#/definitions/AuthenticationTemplateScenarioData/properties/keys/type",
                                  keyword: "type",
                                  params: { type: "object" },
                                  message: "must be object"
                                }
                              ];
                              return false;
                            }
                          }
                          var valid2 = _errs30 === errors;
                        } else {
                          var valid2 = true;
                        }
                      }
                    }
                  }
                }
              }
            } else {
              validate26.errors = [
                {
                  instancePath: instancePath + "/data",
                  schemaPath: "#/definitions/AuthenticationTemplateScenarioData/type",
                  keyword: "type",
                  params: { type: "object" },
                  message: "must be object"
                }
              ];
              return false;
            }
          }
          var valid0 = _errs2 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.description !== void 0) {
            const _errs38 = errors;
            if (typeof data.description !== "string") {
              validate26.errors = [
                {
                  instancePath: instancePath + "/description",
                  schemaPath: "#/properties/description/type",
                  keyword: "type",
                  params: { type: "string" },
                  message: "must be string"
                }
              ];
              return false;
            }
            var valid0 = _errs38 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.extends !== void 0) {
              const _errs40 = errors;
              if (typeof data.extends !== "string") {
                validate26.errors = [
                  {
                    instancePath: instancePath + "/extends",
                    schemaPath: "#/properties/extends/type",
                    keyword: "type",
                    params: { type: "string" },
                    message: "must be string"
                  }
                ];
                return false;
              }
              var valid0 = _errs40 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.name !== void 0) {
                const _errs42 = errors;
                if (typeof data.name !== "string") {
                  validate26.errors = [
                    {
                      instancePath: instancePath + "/name",
                      schemaPath: "#/properties/name/type",
                      keyword: "type",
                      params: { type: "string" },
                      message: "must be string"
                    }
                  ];
                  return false;
                }
                var valid0 = _errs42 === errors;
              } else {
                var valid0 = true;
              }
              if (valid0) {
                if (data.sourceOutputs !== void 0) {
                  let data17 = data.sourceOutputs;
                  const _errs44 = errors;
                  if (errors === _errs44) {
                    if (Array.isArray(data17)) {
                      var valid9 = true;
                      const len0 = data17.length;
                      for (let i0 = 0; i0 < len0; i0++) {
                        const _errs46 = errors;
                        if (!validate27(data17[i0], {
                          instancePath: instancePath + "/sourceOutputs/" + i0,
                          parentData: data17,
                          parentDataProperty: i0,
                          rootData
                        })) {
                          vErrors = vErrors === null ? validate27.errors : vErrors.concat(validate27.errors);
                          errors = vErrors.length;
                        }
                        var valid9 = _errs46 === errors;
                        if (!valid9) {
                          break;
                        }
                      }
                    } else {
                      validate26.errors = [
                        {
                          instancePath: instancePath + "/sourceOutputs",
                          schemaPath: "#/properties/sourceOutputs/type",
                          keyword: "type",
                          params: { type: "array" },
                          message: "must be array"
                        }
                      ];
                      return false;
                    }
                  }
                  var valid0 = _errs44 === errors;
                } else {
                  var valid0 = true;
                }
                if (valid0) {
                  if (data.transaction !== void 0) {
                    let data19 = data.transaction;
                    const _errs47 = errors;
                    if (errors === _errs47) {
                      if (data19 && typeof data19 == "object" && !Array.isArray(data19)) {
                        const _errs49 = errors;
                        for (const key8 in data19) {
                          if (!(key8 === "inputs" || key8 === "locktime" || key8 === "outputs" || key8 === "version")) {
                            validate26.errors = [
                              {
                                instancePath: instancePath + "/transaction",
                                schemaPath: "#/properties/transaction/additionalProperties",
                                keyword: "additionalProperties",
                                params: { additionalProperty: key8 },
                                message: "must NOT have additional properties"
                              }
                            ];
                            return false;
                            break;
                          }
                        }
                        if (_errs49 === errors) {
                          if (data19.inputs !== void 0) {
                            let data20 = data19.inputs;
                            const _errs50 = errors;
                            if (errors === _errs50) {
                              if (Array.isArray(data20)) {
                                var valid11 = true;
                                const len1 = data20.length;
                                for (let i1 = 0; i1 < len1; i1++) {
                                  const _errs52 = errors;
                                  if (!validate31(data20[i1], {
                                    instancePath: instancePath + "/transaction/inputs/" + i1,
                                    parentData: data20,
                                    parentDataProperty: i1,
                                    rootData
                                  })) {
                                    vErrors = vErrors === null ? validate31.errors : vErrors.concat(validate31.errors);
                                    errors = vErrors.length;
                                  }
                                  var valid11 = _errs52 === errors;
                                  if (!valid11) {
                                    break;
                                  }
                                }
                              } else {
                                validate26.errors = [
                                  {
                                    instancePath: instancePath + "/transaction/inputs",
                                    schemaPath: "#/properties/transaction/properties/inputs/type",
                                    keyword: "type",
                                    params: { type: "array" },
                                    message: "must be array"
                                  }
                                ];
                                return false;
                              }
                            }
                            var valid10 = _errs50 === errors;
                          } else {
                            var valid10 = true;
                          }
                          if (valid10) {
                            if (data19.locktime !== void 0) {
                              let data22 = data19.locktime;
                              const _errs53 = errors;
                              if (!(typeof data22 == "number" && isFinite(data22))) {
                                validate26.errors = [
                                  {
                                    instancePath: instancePath + "/transaction/locktime",
                                    schemaPath: "#/properties/transaction/properties/locktime/type",
                                    keyword: "type",
                                    params: { type: "number" },
                                    message: "must be number"
                                  }
                                ];
                                return false;
                              }
                              var valid10 = _errs53 === errors;
                            } else {
                              var valid10 = true;
                            }
                            if (valid10) {
                              if (data19.outputs !== void 0) {
                                let data23 = data19.outputs;
                                const _errs55 = errors;
                                if (errors === _errs55) {
                                  if (Array.isArray(data23)) {
                                    var valid12 = true;
                                    const len2 = data23.length;
                                    for (let i2 = 0; i2 < len2; i2++) {
                                      const _errs57 = errors;
                                      if (!validate34(data23[i2], {
                                        instancePath: instancePath + "/transaction/outputs/" + i2,
                                        parentData: data23,
                                        parentDataProperty: i2,
                                        rootData
                                      })) {
                                        vErrors = vErrors === null ? validate34.errors : vErrors.concat(validate34.errors);
                                        errors = vErrors.length;
                                      }
                                      var valid12 = _errs57 === errors;
                                      if (!valid12) {
                                        break;
                                      }
                                    }
                                  } else {
                                    validate26.errors = [
                                      {
                                        instancePath: instancePath + "/transaction/outputs",
                                        schemaPath: "#/properties/transaction/properties/outputs/type",
                                        keyword: "type",
                                        params: { type: "array" },
                                        message: "must be array"
                                      }
                                    ];
                                    return false;
                                  }
                                }
                                var valid10 = _errs55 === errors;
                              } else {
                                var valid10 = true;
                              }
                              if (valid10) {
                                if (data19.version !== void 0) {
                                  let data25 = data19.version;
                                  const _errs58 = errors;
                                  if (!(typeof data25 == "number" && isFinite(data25))) {
                                    validate26.errors = [
                                      {
                                        instancePath: instancePath + "/transaction/version",
                                        schemaPath: "#/properties/transaction/properties/version/type",
                                        keyword: "type",
                                        params: { type: "number" },
                                        message: "must be number"
                                      }
                                    ];
                                    return false;
                                  }
                                  var valid10 = _errs58 === errors;
                                } else {
                                  var valid10 = true;
                                }
                              }
                            }
                          }
                        }
                      } else {
                        validate26.errors = [
                          {
                            instancePath: instancePath + "/transaction",
                            schemaPath: "#/properties/transaction/type",
                            keyword: "type",
                            params: { type: "object" },
                            message: "must be object"
                          }
                        ];
                        return false;
                      }
                    }
                    var valid0 = _errs47 === errors;
                  } else {
                    var valid0 = true;
                  }
                }
              }
            }
          }
        }
      }
    } else {
      validate26.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: { type: "object" },
          message: "must be object"
        }
      ];
      return false;
    }
  }
  validate26.errors = vErrors;
  return errors === 0;
}
function validate38(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.script === void 0 && (missing0 = "script") || data.tests === void 0 && (missing0 = "tests")) {
        validate38.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'"
          }
        ];
        return false;
      } else {
        const _errs1 = errors;
        for (const key0 in data) {
          if (!(key0 === "name" || key0 === "pushed" || key0 === "script" || key0 === "tests")) {
            validate38.errors = [
              {
                instancePath,
                schemaPath: "#/additionalProperties",
                keyword: "additionalProperties",
                params: { additionalProperty: key0 },
                message: "must NOT have additional properties"
              }
            ];
            return false;
            break;
          }
        }
        if (_errs1 === errors) {
          if (data.name !== void 0) {
            const _errs2 = errors;
            if (typeof data.name !== "string") {
              validate38.errors = [
                {
                  instancePath: instancePath + "/name",
                  schemaPath: "#/properties/name/type",
                  keyword: "type",
                  params: { type: "string" },
                  message: "must be string"
                }
              ];
              return false;
            }
            var valid0 = _errs2 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.pushed !== void 0) {
              const _errs4 = errors;
              if (typeof data.pushed !== "boolean") {
                validate38.errors = [
                  {
                    instancePath: instancePath + "/pushed",
                    schemaPath: "#/properties/pushed/type",
                    keyword: "type",
                    params: { type: "boolean" },
                    message: "must be boolean"
                  }
                ];
                return false;
              }
              var valid0 = _errs4 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.script !== void 0) {
                const _errs6 = errors;
                if (typeof data.script !== "string") {
                  validate38.errors = [
                    {
                      instancePath: instancePath + "/script",
                      schemaPath: "#/properties/script/type",
                      keyword: "type",
                      params: { type: "string" },
                      message: "must be string"
                    }
                  ];
                  return false;
                }
                var valid0 = _errs6 === errors;
              } else {
                var valid0 = true;
              }
              if (valid0) {
                if (data.tests !== void 0) {
                  let data3 = data.tests;
                  const _errs8 = errors;
                  if (errors === _errs8) {
                    if (data3 && typeof data3 == "object" && !Array.isArray(data3)) {
                      for (const key1 in data3) {
                        let data4 = data3[key1];
                        const _errs11 = errors;
                        const _errs12 = errors;
                        if (errors === _errs12) {
                          if (data4 && typeof data4 == "object" && !Array.isArray(data4)) {
                            let missing1;
                            if (data4.check === void 0 && (missing1 = "check")) {
                              validate38.errors = [
                                {
                                  instancePath: instancePath + "/tests/" + key1.replace(/~/g, "~0").replace(/\//g, "~1"),
                                  schemaPath: "#/definitions/AuthenticationTemplateScriptTest/required",
                                  keyword: "required",
                                  params: { missingProperty: missing1 },
                                  message: "must have required property '" + missing1 + "'"
                                }
                              ];
                              return false;
                            } else {
                              const _errs14 = errors;
                              for (const key2 in data4) {
                                if (!(key2 === "check" || key2 === "fails" || key2 === "invalid" || key2 === "name" || key2 === "passes" || key2 === "setup")) {
                                  validate38.errors = [
                                    {
                                      instancePath: instancePath + "/tests/" + key1.replace(/~/g, "~0").replace(/\//g, "~1"),
                                      schemaPath: "#/definitions/AuthenticationTemplateScriptTest/additionalProperties",
                                      keyword: "additionalProperties",
                                      params: { additionalProperty: key2 },
                                      message: "must NOT have additional properties"
                                    }
                                  ];
                                  return false;
                                  break;
                                }
                              }
                              if (_errs14 === errors) {
                                if (data4.check !== void 0) {
                                  const _errs15 = errors;
                                  if (typeof data4.check !== "string") {
                                    validate38.errors = [
                                      {
                                        instancePath: instancePath + "/tests/" + key1.replace(/~/g, "~0").replace(/\//g, "~1") + "/check",
                                        schemaPath: "#/definitions/AuthenticationTemplateScriptTest/properties/check/type",
                                        keyword: "type",
                                        params: { type: "string" },
                                        message: "must be string"
                                      }
                                    ];
                                    return false;
                                  }
                                  var valid3 = _errs15 === errors;
                                } else {
                                  var valid3 = true;
                                }
                                if (valid3) {
                                  if (data4.fails !== void 0) {
                                    let data6 = data4.fails;
                                    const _errs17 = errors;
                                    if (errors === _errs17) {
                                      if (Array.isArray(data6)) {
                                        var valid4 = true;
                                        const len0 = data6.length;
                                        for (let i0 = 0; i0 < len0; i0++) {
                                          const _errs19 = errors;
                                          if (typeof data6[i0] !== "string") {
                                            validate38.errors = [
                                              {
                                                instancePath: instancePath + "/tests/" + key1.replace(/~/g, "~0").replace(/\//g, "~1") + "/fails/" + i0,
                                                schemaPath: "#/definitions/AuthenticationTemplateScriptTest/properties/fails/items/type",
                                                keyword: "type",
                                                params: { type: "string" },
                                                message: "must be string"
                                              }
                                            ];
                                            return false;
                                          }
                                          var valid4 = _errs19 === errors;
                                          if (!valid4) {
                                            break;
                                          }
                                        }
                                      } else {
                                        validate38.errors = [
                                          {
                                            instancePath: instancePath + "/tests/" + key1.replace(/~/g, "~0").replace(/\//g, "~1") + "/fails",
                                            schemaPath: "#/definitions/AuthenticationTemplateScriptTest/properties/fails/type",
                                            keyword: "type",
                                            params: { type: "array" },
                                            message: "must be array"
                                          }
                                        ];
                                        return false;
                                      }
                                    }
                                    var valid3 = _errs17 === errors;
                                  } else {
                                    var valid3 = true;
                                  }
                                  if (valid3) {
                                    if (data4.invalid !== void 0) {
                                      let data8 = data4.invalid;
                                      const _errs21 = errors;
                                      if (errors === _errs21) {
                                        if (Array.isArray(data8)) {
                                          var valid5 = true;
                                          const len1 = data8.length;
                                          for (let i1 = 0; i1 < len1; i1++) {
                                            const _errs23 = errors;
                                            if (typeof data8[i1] !== "string") {
                                              validate38.errors = [
                                                {
                                                  instancePath: instancePath + "/tests/" + key1.replace(/~/g, "~0").replace(/\//g, "~1") + "/invalid/" + i1,
                                                  schemaPath: "#/definitions/AuthenticationTemplateScriptTest/properties/invalid/items/type",
                                                  keyword: "type",
                                                  params: { type: "string" },
                                                  message: "must be string"
                                                }
                                              ];
                                              return false;
                                            }
                                            var valid5 = _errs23 === errors;
                                            if (!valid5) {
                                              break;
                                            }
                                          }
                                        } else {
                                          validate38.errors = [
                                            {
                                              instancePath: instancePath + "/tests/" + key1.replace(/~/g, "~0").replace(/\//g, "~1") + "/invalid",
                                              schemaPath: "#/definitions/AuthenticationTemplateScriptTest/properties/invalid/type",
                                              keyword: "type",
                                              params: { type: "array" },
                                              message: "must be array"
                                            }
                                          ];
                                          return false;
                                        }
                                      }
                                      var valid3 = _errs21 === errors;
                                    } else {
                                      var valid3 = true;
                                    }
                                    if (valid3) {
                                      if (data4.name !== void 0) {
                                        const _errs25 = errors;
                                        if (typeof data4.name !== "string") {
                                          validate38.errors = [
                                            {
                                              instancePath: instancePath + "/tests/" + key1.replace(/~/g, "~0").replace(/\//g, "~1") + "/name",
                                              schemaPath: "#/definitions/AuthenticationTemplateScriptTest/properties/name/type",
                                              keyword: "type",
                                              params: { type: "string" },
                                              message: "must be string"
                                            }
                                          ];
                                          return false;
                                        }
                                        var valid3 = _errs25 === errors;
                                      } else {
                                        var valid3 = true;
                                      }
                                      if (valid3) {
                                        if (data4.passes !== void 0) {
                                          let data11 = data4.passes;
                                          const _errs27 = errors;
                                          if (errors === _errs27) {
                                            if (Array.isArray(data11)) {
                                              var valid6 = true;
                                              const len2 = data11.length;
                                              for (let i2 = 0; i2 < len2; i2++) {
                                                const _errs29 = errors;
                                                if (typeof data11[i2] !== "string") {
                                                  validate38.errors = [
                                                    {
                                                      instancePath: instancePath + "/tests/" + key1.replace(/~/g, "~0").replace(/\//g, "~1") + "/passes/" + i2,
                                                      schemaPath: "#/definitions/AuthenticationTemplateScriptTest/properties/passes/items/type",
                                                      keyword: "type",
                                                      params: {
                                                        type: "string"
                                                      },
                                                      message: "must be string"
                                                    }
                                                  ];
                                                  return false;
                                                }
                                                var valid6 = _errs29 === errors;
                                                if (!valid6) {
                                                  break;
                                                }
                                              }
                                            } else {
                                              validate38.errors = [
                                                {
                                                  instancePath: instancePath + "/tests/" + key1.replace(/~/g, "~0").replace(/\//g, "~1") + "/passes",
                                                  schemaPath: "#/definitions/AuthenticationTemplateScriptTest/properties/passes/type",
                                                  keyword: "type",
                                                  params: { type: "array" },
                                                  message: "must be array"
                                                }
                                              ];
                                              return false;
                                            }
                                          }
                                          var valid3 = _errs27 === errors;
                                        } else {
                                          var valid3 = true;
                                        }
                                        if (valid3) {
                                          if (data4.setup !== void 0) {
                                            const _errs31 = errors;
                                            if (typeof data4.setup !== "string") {
                                              validate38.errors = [
                                                {
                                                  instancePath: instancePath + "/tests/" + key1.replace(/~/g, "~0").replace(/\//g, "~1") + "/setup",
                                                  schemaPath: "#/definitions/AuthenticationTemplateScriptTest/properties/setup/type",
                                                  keyword: "type",
                                                  params: { type: "string" },
                                                  message: "must be string"
                                                }
                                              ];
                                              return false;
                                            }
                                            var valid3 = _errs31 === errors;
                                          } else {
                                            var valid3 = true;
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            validate38.errors = [
                              {
                                instancePath: instancePath + "/tests/" + key1.replace(/~/g, "~0").replace(/\//g, "~1"),
                                schemaPath: "#/definitions/AuthenticationTemplateScriptTest/type",
                                keyword: "type",
                                params: { type: "object" },
                                message: "must be object"
                              }
                            ];
                            return false;
                          }
                        }
                        var valid1 = _errs11 === errors;
                        if (!valid1) {
                          break;
                        }
                      }
                    } else {
                      validate38.errors = [
                        {
                          instancePath: instancePath + "/tests",
                          schemaPath: "#/properties/tests/type",
                          keyword: "type",
                          params: { type: "object" },
                          message: "must be object"
                        }
                      ];
                      return false;
                    }
                  }
                  var valid0 = _errs8 === errors;
                } else {
                  var valid0 = true;
                }
              }
            }
          }
        }
      }
    } else {
      validate38.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: { type: "object" },
          message: "must be object"
        }
      ];
      return false;
    }
  }
  validate38.errors = vErrors;
  return errors === 0;
}
var func4 = Object.prototype.hasOwnProperty;
function validate21(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.entities === void 0 && (missing0 = "entities") || data.scripts === void 0 && (missing0 = "scripts") || data.supported === void 0 && (missing0 = "supported") || data.version === void 0 && (missing0 = "version")) {
        validate21.errors = [
          {
            instancePath,
            schemaPath: "#/required",
            keyword: "required",
            params: { missingProperty: missing0 },
            message: "must have required property '" + missing0 + "'"
          }
        ];
        return false;
      } else {
        const _errs1 = errors;
        for (const key0 in data) {
          if (!(key0 === "$schema" || key0 === "description" || key0 === "entities" || key0 === "name" || key0 === "scenarios" || key0 === "scripts" || key0 === "supported" || key0 === "version")) {
            validate21.errors = [
              {
                instancePath,
                schemaPath: "#/additionalProperties",
                keyword: "additionalProperties",
                params: { additionalProperty: key0 },
                message: "must NOT have additional properties"
              }
            ];
            return false;
            break;
          }
        }
        if (_errs1 === errors) {
          if (data.$schema !== void 0) {
            const _errs2 = errors;
            if (typeof data.$schema !== "string") {
              validate21.errors = [
                {
                  instancePath: instancePath + "/$schema",
                  schemaPath: "#/properties/%24schema/type",
                  keyword: "type",
                  params: { type: "string" },
                  message: "must be string"
                }
              ];
              return false;
            }
            var valid0 = _errs2 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.description !== void 0) {
              const _errs4 = errors;
              if (typeof data.description !== "string") {
                validate21.errors = [
                  {
                    instancePath: instancePath + "/description",
                    schemaPath: "#/properties/description/type",
                    keyword: "type",
                    params: { type: "string" },
                    message: "must be string"
                  }
                ];
                return false;
              }
              var valid0 = _errs4 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.entities !== void 0) {
                let data2 = data.entities;
                const _errs6 = errors;
                if (errors === _errs6) {
                  if (data2 && typeof data2 == "object" && !Array.isArray(data2)) {
                    for (const key1 in data2) {
                      const _errs9 = errors;
                      if (!validate22(data2[key1], {
                        instancePath: instancePath + "/entities/" + key1.replace(/~/g, "~0").replace(/\//g, "~1"),
                        parentData: data2,
                        parentDataProperty: key1,
                        rootData
                      })) {
                        vErrors = vErrors === null ? validate22.errors : vErrors.concat(validate22.errors);
                        errors = vErrors.length;
                      }
                      var valid1 = _errs9 === errors;
                      if (!valid1) {
                        break;
                      }
                    }
                  } else {
                    validate21.errors = [
                      {
                        instancePath: instancePath + "/entities",
                        schemaPath: "#/properties/entities/type",
                        keyword: "type",
                        params: { type: "object" },
                        message: "must be object"
                      }
                    ];
                    return false;
                  }
                }
                var valid0 = _errs6 === errors;
              } else {
                var valid0 = true;
              }
              if (valid0) {
                if (data.name !== void 0) {
                  const _errs10 = errors;
                  if (typeof data.name !== "string") {
                    validate21.errors = [
                      {
                        instancePath: instancePath + "/name",
                        schemaPath: "#/properties/name/type",
                        keyword: "type",
                        params: { type: "string" },
                        message: "must be string"
                      }
                    ];
                    return false;
                  }
                  var valid0 = _errs10 === errors;
                } else {
                  var valid0 = true;
                }
                if (valid0) {
                  if (data.scenarios !== void 0) {
                    let data5 = data.scenarios;
                    const _errs12 = errors;
                    if (errors === _errs12) {
                      if (data5 && typeof data5 == "object" && !Array.isArray(data5)) {
                        for (const key2 in data5) {
                          const _errs15 = errors;
                          if (!validate26(data5[key2], {
                            instancePath: instancePath + "/scenarios/" + key2.replace(/~/g, "~0").replace(/\//g, "~1"),
                            parentData: data5,
                            parentDataProperty: key2,
                            rootData
                          })) {
                            vErrors = vErrors === null ? validate26.errors : vErrors.concat(validate26.errors);
                            errors = vErrors.length;
                          }
                          var valid2 = _errs15 === errors;
                          if (!valid2) {
                            break;
                          }
                        }
                      } else {
                        validate21.errors = [
                          {
                            instancePath: instancePath + "/scenarios",
                            schemaPath: "#/properties/scenarios/type",
                            keyword: "type",
                            params: { type: "object" },
                            message: "must be object"
                          }
                        ];
                        return false;
                      }
                    }
                    var valid0 = _errs12 === errors;
                  } else {
                    var valid0 = true;
                  }
                  if (valid0) {
                    if (data.scripts !== void 0) {
                      let data7 = data.scripts;
                      const _errs16 = errors;
                      if (errors === _errs16) {
                        if (data7 && typeof data7 == "object" && !Array.isArray(data7)) {
                          for (const key3 in data7) {
                            let data8 = data7[key3];
                            const _errs19 = errors;
                            const _errs20 = errors;
                            let valid4 = false;
                            const _errs21 = errors;
                            const _errs22 = errors;
                            if (errors === _errs22) {
                              if (data8 && typeof data8 == "object" && !Array.isArray(data8)) {
                                let missing1;
                                if (data8.script === void 0 && (missing1 = "script")) {
                                  const err0 = {
                                    instancePath: instancePath + "/scripts/" + key3.replace(/~/g, "~0").replace(/\//g, "~1"),
                                    schemaPath: "#/definitions/AuthenticationTemplateScript/required",
                                    keyword: "required",
                                    params: { missingProperty: missing1 },
                                    message: "must have required property '" + missing1 + "'"
                                  };
                                  if (vErrors === null) {
                                    vErrors = [err0];
                                  } else {
                                    vErrors.push(err0);
                                  }
                                  errors++;
                                } else {
                                  const _errs24 = errors;
                                  for (const key4 in data8) {
                                    if (!(key4 === "name" || key4 === "script")) {
                                      const err1 = {
                                        instancePath: instancePath + "/scripts/" + key3.replace(/~/g, "~0").replace(/\//g, "~1"),
                                        schemaPath: "#/definitions/AuthenticationTemplateScript/additionalProperties",
                                        keyword: "additionalProperties",
                                        params: { additionalProperty: key4 },
                                        message: "must NOT have additional properties"
                                      };
                                      if (vErrors === null) {
                                        vErrors = [err1];
                                      } else {
                                        vErrors.push(err1);
                                      }
                                      errors++;
                                      break;
                                    }
                                  }
                                  if (_errs24 === errors) {
                                    if (data8.name !== void 0) {
                                      const _errs25 = errors;
                                      if (typeof data8.name !== "string") {
                                        const err2 = {
                                          instancePath: instancePath + "/scripts/" + key3.replace(/~/g, "~0").replace(/\//g, "~1") + "/name",
                                          schemaPath: "#/definitions/AuthenticationTemplateScript/properties/name/type",
                                          keyword: "type",
                                          params: { type: "string" },
                                          message: "must be string"
                                        };
                                        if (vErrors === null) {
                                          vErrors = [err2];
                                        } else {
                                          vErrors.push(err2);
                                        }
                                        errors++;
                                      }
                                      var valid6 = _errs25 === errors;
                                    } else {
                                      var valid6 = true;
                                    }
                                    if (valid6) {
                                      if (data8.script !== void 0) {
                                        const _errs27 = errors;
                                        if (typeof data8.script !== "string") {
                                          const err3 = {
                                            instancePath: instancePath + "/scripts/" + key3.replace(/~/g, "~0").replace(/\//g, "~1") + "/script",
                                            schemaPath: "#/definitions/AuthenticationTemplateScript/properties/script/type",
                                            keyword: "type",
                                            params: { type: "string" },
                                            message: "must be string"
                                          };
                                          if (vErrors === null) {
                                            vErrors = [err3];
                                          } else {
                                            vErrors.push(err3);
                                          }
                                          errors++;
                                        }
                                        var valid6 = _errs27 === errors;
                                      } else {
                                        var valid6 = true;
                                      }
                                    }
                                  }
                                }
                              } else {
                                const err4 = {
                                  instancePath: instancePath + "/scripts/" + key3.replace(/~/g, "~0").replace(/\//g, "~1"),
                                  schemaPath: "#/definitions/AuthenticationTemplateScript/type",
                                  keyword: "type",
                                  params: { type: "object" },
                                  message: "must be object"
                                };
                                if (vErrors === null) {
                                  vErrors = [err4];
                                } else {
                                  vErrors.push(err4);
                                }
                                errors++;
                              }
                            }
                            var _valid0 = _errs21 === errors;
                            valid4 = valid4 || _valid0;
                            if (!valid4) {
                              const _errs29 = errors;
                              const _errs30 = errors;
                              if (errors === _errs30) {
                                if (data8 && typeof data8 == "object" && !Array.isArray(data8)) {
                                  let missing2;
                                  if (data8.lockingType === void 0 && (missing2 = "lockingType") || data8.script === void 0 && (missing2 = "script")) {
                                    const err5 = {
                                      instancePath: instancePath + "/scripts/" + key3.replace(/~/g, "~0").replace(/\//g, "~1"),
                                      schemaPath: "#/definitions/AuthenticationTemplateScriptLocking/required",
                                      keyword: "required",
                                      params: { missingProperty: missing2 },
                                      message: "must have required property '" + missing2 + "'"
                                    };
                                    if (vErrors === null) {
                                      vErrors = [err5];
                                    } else {
                                      vErrors.push(err5);
                                    }
                                    errors++;
                                  } else {
                                    const _errs32 = errors;
                                    for (const key5 in data8) {
                                      if (!(key5 === "lockingType" || key5 === "name" || key5 === "script")) {
                                        const err6 = {
                                          instancePath: instancePath + "/scripts/" + key3.replace(/~/g, "~0").replace(/\//g, "~1"),
                                          schemaPath: "#/definitions/AuthenticationTemplateScriptLocking/additionalProperties",
                                          keyword: "additionalProperties",
                                          params: { additionalProperty: key5 },
                                          message: "must NOT have additional properties"
                                        };
                                        if (vErrors === null) {
                                          vErrors = [err6];
                                        } else {
                                          vErrors.push(err6);
                                        }
                                        errors++;
                                        break;
                                      }
                                    }
                                    if (_errs32 === errors) {
                                      if (data8.lockingType !== void 0) {
                                        let data11 = data8.lockingType;
                                        const _errs33 = errors;
                                        if (typeof data11 !== "string") {
                                          const err7 = {
                                            instancePath: instancePath + "/scripts/" + key3.replace(/~/g, "~0").replace(/\//g, "~1") + "/lockingType",
                                            schemaPath: "#/definitions/AuthenticationTemplateScriptLocking/properties/lockingType/type",
                                            keyword: "type",
                                            params: { type: "string" },
                                            message: "must be string"
                                          };
                                          if (vErrors === null) {
                                            vErrors = [err7];
                                          } else {
                                            vErrors.push(err7);
                                          }
                                          errors++;
                                        }
                                        if (!(data11 === "p2sh20" || data11 === "p2sh32" || data11 === "standard")) {
                                          const err8 = {
                                            instancePath: instancePath + "/scripts/" + key3.replace(/~/g, "~0").replace(/\//g, "~1") + "/lockingType",
                                            schemaPath: "#/definitions/AuthenticationTemplateScriptLocking/properties/lockingType/enum",
                                            keyword: "enum",
                                            params: {
                                              allowedValues: schema38.properties.lockingType.enum
                                            },
                                            message: "must be equal to one of the allowed values"
                                          };
                                          if (vErrors === null) {
                                            vErrors = [err8];
                                          } else {
                                            vErrors.push(err8);
                                          }
                                          errors++;
                                        }
                                        var valid8 = _errs33 === errors;
                                      } else {
                                        var valid8 = true;
                                      }
                                      if (valid8) {
                                        if (data8.name !== void 0) {
                                          const _errs35 = errors;
                                          if (typeof data8.name !== "string") {
                                            const err9 = {
                                              instancePath: instancePath + "/scripts/" + key3.replace(/~/g, "~0").replace(/\//g, "~1") + "/name",
                                              schemaPath: "#/definitions/AuthenticationTemplateScriptLocking/properties/name/type",
                                              keyword: "type",
                                              params: { type: "string" },
                                              message: "must be string"
                                            };
                                            if (vErrors === null) {
                                              vErrors = [err9];
                                            } else {
                                              vErrors.push(err9);
                                            }
                                            errors++;
                                          }
                                          var valid8 = _errs35 === errors;
                                        } else {
                                          var valid8 = true;
                                        }
                                        if (valid8) {
                                          if (data8.script !== void 0) {
                                            const _errs37 = errors;
                                            if (typeof data8.script !== "string") {
                                              const err10 = {
                                                instancePath: instancePath + "/scripts/" + key3.replace(/~/g, "~0").replace(/\//g, "~1") + "/script",
                                                schemaPath: "#/definitions/AuthenticationTemplateScriptLocking/properties/script/type",
                                                keyword: "type",
                                                params: { type: "string" },
                                                message: "must be string"
                                              };
                                              if (vErrors === null) {
                                                vErrors = [err10];
                                              } else {
                                                vErrors.push(err10);
                                              }
                                              errors++;
                                            }
                                            var valid8 = _errs37 === errors;
                                          } else {
                                            var valid8 = true;
                                          }
                                        }
                                      }
                                    }
                                  }
                                } else {
                                  const err11 = {
                                    instancePath: instancePath + "/scripts/" + key3.replace(/~/g, "~0").replace(/\//g, "~1"),
                                    schemaPath: "#/definitions/AuthenticationTemplateScriptLocking/type",
                                    keyword: "type",
                                    params: { type: "object" },
                                    message: "must be object"
                                  };
                                  if (vErrors === null) {
                                    vErrors = [err11];
                                  } else {
                                    vErrors.push(err11);
                                  }
                                  errors++;
                                }
                              }
                              var _valid0 = _errs29 === errors;
                              valid4 = valid4 || _valid0;
                              if (!valid4) {
                                const _errs39 = errors;
                                if (!validate38(data8, {
                                  instancePath: instancePath + "/scripts/" + key3.replace(/~/g, "~0").replace(/\//g, "~1"),
                                  parentData: data7,
                                  parentDataProperty: key3,
                                  rootData
                                })) {
                                  vErrors = vErrors === null ? validate38.errors : vErrors.concat(validate38.errors);
                                  errors = vErrors.length;
                                }
                                var _valid0 = _errs39 === errors;
                                valid4 = valid4 || _valid0;
                                if (!valid4) {
                                  const _errs40 = errors;
                                  const _errs41 = errors;
                                  if (errors === _errs41) {
                                    if (data8 && typeof data8 == "object" && !Array.isArray(data8)) {
                                      let missing3;
                                      if (data8.script === void 0 && (missing3 = "script") || data8.unlocks === void 0 && (missing3 = "unlocks")) {
                                        const err12 = {
                                          instancePath: instancePath + "/scripts/" + key3.replace(/~/g, "~0").replace(/\//g, "~1"),
                                          schemaPath: "#/definitions/AuthenticationTemplateScriptUnlocking/required",
                                          keyword: "required",
                                          params: { missingProperty: missing3 },
                                          message: "must have required property '" + missing3 + "'"
                                        };
                                        if (vErrors === null) {
                                          vErrors = [err12];
                                        } else {
                                          vErrors.push(err12);
                                        }
                                        errors++;
                                      } else {
                                        const _errs43 = errors;
                                        for (const key6 in data8) {
                                          if (!func4.call(schema41.properties, key6)) {
                                            const err13 = {
                                              instancePath: instancePath + "/scripts/" + key3.replace(/~/g, "~0").replace(/\//g, "~1"),
                                              schemaPath: "#/definitions/AuthenticationTemplateScriptUnlocking/additionalProperties",
                                              keyword: "additionalProperties",
                                              params: {
                                                additionalProperty: key6
                                              },
                                              message: "must NOT have additional properties"
                                            };
                                            if (vErrors === null) {
                                              vErrors = [err13];
                                            } else {
                                              vErrors.push(err13);
                                            }
                                            errors++;
                                            break;
                                          }
                                        }
                                        if (_errs43 === errors) {
                                          if (data8.ageLock !== void 0) {
                                            const _errs44 = errors;
                                            if (typeof data8.ageLock !== "string") {
                                              const err14 = {
                                                instancePath: instancePath + "/scripts/" + key3.replace(/~/g, "~0").replace(/\//g, "~1") + "/ageLock",
                                                schemaPath: "#/definitions/AuthenticationTemplateScriptUnlocking/properties/ageLock/type",
                                                keyword: "type",
                                                params: { type: "string" },
                                                message: "must be string"
                                              };
                                              if (vErrors === null) {
                                                vErrors = [err14];
                                              } else {
                                                vErrors.push(err14);
                                              }
                                              errors++;
                                            }
                                            var valid10 = _errs44 === errors;
                                          } else {
                                            var valid10 = true;
                                          }
                                          if (valid10) {
                                            if (data8.estimate !== void 0) {
                                              const _errs46 = errors;
                                              if (typeof data8.estimate !== "string") {
                                                const err15 = {
                                                  instancePath: instancePath + "/scripts/" + key3.replace(/~/g, "~0").replace(/\//g, "~1") + "/estimate",
                                                  schemaPath: "#/definitions/AuthenticationTemplateScriptUnlocking/properties/estimate/type",
                                                  keyword: "type",
                                                  params: { type: "string" },
                                                  message: "must be string"
                                                };
                                                if (vErrors === null) {
                                                  vErrors = [err15];
                                                } else {
                                                  vErrors.push(err15);
                                                }
                                                errors++;
                                              }
                                              var valid10 = _errs46 === errors;
                                            } else {
                                              var valid10 = true;
                                            }
                                            if (valid10) {
                                              if (data8.fails !== void 0) {
                                                let data16 = data8.fails;
                                                const _errs48 = errors;
                                                if (errors === _errs48) {
                                                  if (Array.isArray(data16)) {
                                                    var valid11 = true;
                                                    const len0 = data16.length;
                                                    for (let i0 = 0; i0 < len0; i0++) {
                                                      const _errs50 = errors;
                                                      if (typeof data16[i0] !== "string") {
                                                        const err16 = {
                                                          instancePath: instancePath + "/scripts/" + key3.replace(/~/g, "~0").replace(/\//g, "~1") + "/fails/" + i0,
                                                          schemaPath: "#/definitions/AuthenticationTemplateScriptUnlocking/properties/fails/items/type",
                                                          keyword: "type",
                                                          params: {
                                                            type: "string"
                                                          },
                                                          message: "must be string"
                                                        };
                                                        if (vErrors === null) {
                                                          vErrors = [err16];
                                                        } else {
                                                          vErrors.push(err16);
                                                        }
                                                        errors++;
                                                      }
                                                      var valid11 = _errs50 === errors;
                                                      if (!valid11) {
                                                        break;
                                                      }
                                                    }
                                                  } else {
                                                    const err17 = {
                                                      instancePath: instancePath + "/scripts/" + key3.replace(/~/g, "~0").replace(/\//g, "~1") + "/fails",
                                                      schemaPath: "#/definitions/AuthenticationTemplateScriptUnlocking/properties/fails/type",
                                                      keyword: "type",
                                                      params: { type: "array" },
                                                      message: "must be array"
                                                    };
                                                    if (vErrors === null) {
                                                      vErrors = [err17];
                                                    } else {
                                                      vErrors.push(err17);
                                                    }
                                                    errors++;
                                                  }
                                                }
                                                var valid10 = _errs48 === errors;
                                              } else {
                                                var valid10 = true;
                                              }
                                              if (valid10) {
                                                if (data8.invalid !== void 0) {
                                                  let data18 = data8.invalid;
                                                  const _errs52 = errors;
                                                  if (errors === _errs52) {
                                                    if (Array.isArray(data18)) {
                                                      var valid12 = true;
                                                      const len1 = data18.length;
                                                      for (let i1 = 0; i1 < len1; i1++) {
                                                        const _errs54 = errors;
                                                        if (typeof data18[i1] !== "string") {
                                                          const err18 = {
                                                            instancePath: instancePath + "/scripts/" + key3.replace(/~/g, "~0").replace(/\//g, "~1") + "/invalid/" + i1,
                                                            schemaPath: "#/definitions/AuthenticationTemplateScriptUnlocking/properties/invalid/items/type",
                                                            keyword: "type",
                                                            params: {
                                                              type: "string"
                                                            },
                                                            message: "must be string"
                                                          };
                                                          if (vErrors === null) {
                                                            vErrors = [err18];
                                                          } else {
                                                            vErrors.push(err18);
                                                          }
                                                          errors++;
                                                        }
                                                        var valid12 = _errs54 === errors;
                                                        if (!valid12) {
                                                          break;
                                                        }
                                                      }
                                                    } else {
                                                      const err19 = {
                                                        instancePath: instancePath + "/scripts/" + key3.replace(/~/g, "~0").replace(/\//g, "~1") + "/invalid",
                                                        schemaPath: "#/definitions/AuthenticationTemplateScriptUnlocking/properties/invalid/type",
                                                        keyword: "type",
                                                        params: {
                                                          type: "array"
                                                        },
                                                        message: "must be array"
                                                      };
                                                      if (vErrors === null) {
                                                        vErrors = [err19];
                                                      } else {
                                                        vErrors.push(err19);
                                                      }
                                                      errors++;
                                                    }
                                                  }
                                                  var valid10 = _errs52 === errors;
                                                } else {
                                                  var valid10 = true;
                                                }
                                                if (valid10) {
                                                  if (data8.name !== void 0) {
                                                    const _errs56 = errors;
                                                    if (typeof data8.name !== "string") {
                                                      const err20 = {
                                                        instancePath: instancePath + "/scripts/" + key3.replace(/~/g, "~0").replace(/\//g, "~1") + "/name",
                                                        schemaPath: "#/definitions/AuthenticationTemplateScriptUnlocking/properties/name/type",
                                                        keyword: "type",
                                                        params: {
                                                          type: "string"
                                                        },
                                                        message: "must be string"
                                                      };
                                                      if (vErrors === null) {
                                                        vErrors = [err20];
                                                      } else {
                                                        vErrors.push(err20);
                                                      }
                                                      errors++;
                                                    }
                                                    var valid10 = _errs56 === errors;
                                                  } else {
                                                    var valid10 = true;
                                                  }
                                                  if (valid10) {
                                                    if (data8.passes !== void 0) {
                                                      let data21 = data8.passes;
                                                      const _errs58 = errors;
                                                      if (errors === _errs58) {
                                                        if (Array.isArray(data21)) {
                                                          var valid13 = true;
                                                          const len2 = data21.length;
                                                          for (let i2 = 0; i2 < len2; i2++) {
                                                            const _errs60 = errors;
                                                            if (typeof data21[i2] !== "string") {
                                                              const err21 = {
                                                                instancePath: instancePath + "/scripts/" + key3.replace(/~/g, "~0").replace(/\//g, "~1") + "/passes/" + i2,
                                                                schemaPath: "#/definitions/AuthenticationTemplateScriptUnlocking/properties/passes/items/type",
                                                                keyword: "type",
                                                                params: {
                                                                  type: "string"
                                                                },
                                                                message: "must be string"
                                                              };
                                                              if (vErrors === null) {
                                                                vErrors = [
                                                                  err21
                                                                ];
                                                              } else {
                                                                vErrors.push(err21);
                                                              }
                                                              errors++;
                                                            }
                                                            var valid13 = _errs60 === errors;
                                                            if (!valid13) {
                                                              break;
                                                            }
                                                          }
                                                        } else {
                                                          const err22 = {
                                                            instancePath: instancePath + "/scripts/" + key3.replace(/~/g, "~0").replace(/\//g, "~1") + "/passes",
                                                            schemaPath: "#/definitions/AuthenticationTemplateScriptUnlocking/properties/passes/type",
                                                            keyword: "type",
                                                            params: {
                                                              type: "array"
                                                            },
                                                            message: "must be array"
                                                          };
                                                          if (vErrors === null) {
                                                            vErrors = [err22];
                                                          } else {
                                                            vErrors.push(err22);
                                                          }
                                                          errors++;
                                                        }
                                                      }
                                                      var valid10 = _errs58 === errors;
                                                    } else {
                                                      var valid10 = true;
                                                    }
                                                    if (valid10) {
                                                      if (data8.script !== void 0) {
                                                        const _errs62 = errors;
                                                        if (typeof data8.script !== "string") {
                                                          const err23 = {
                                                            instancePath: instancePath + "/scripts/" + key3.replace(/~/g, "~0").replace(/\//g, "~1") + "/script",
                                                            schemaPath: "#/definitions/AuthenticationTemplateScriptUnlocking/properties/script/type",
                                                            keyword: "type",
                                                            params: {
                                                              type: "string"
                                                            },
                                                            message: "must be string"
                                                          };
                                                          if (vErrors === null) {
                                                            vErrors = [err23];
                                                          } else {
                                                            vErrors.push(err23);
                                                          }
                                                          errors++;
                                                        }
                                                        var valid10 = _errs62 === errors;
                                                      } else {
                                                        var valid10 = true;
                                                      }
                                                      if (valid10) {
                                                        if (data8.timeLockType !== void 0) {
                                                          let data24 = data8.timeLockType;
                                                          const _errs64 = errors;
                                                          if (typeof data24 !== "string") {
                                                            const err24 = {
                                                              instancePath: instancePath + "/scripts/" + key3.replace(/~/g, "~0").replace(/\//g, "~1") + "/timeLockType",
                                                              schemaPath: "#/definitions/AuthenticationTemplateScriptUnlocking/properties/timeLockType/type",
                                                              keyword: "type",
                                                              params: {
                                                                type: "string"
                                                              },
                                                              message: "must be string"
                                                            };
                                                            if (vErrors === null) {
                                                              vErrors = [err24];
                                                            } else {
                                                              vErrors.push(err24);
                                                            }
                                                            errors++;
                                                          }
                                                          if (!(data24 === "height" || data24 === "timestamp")) {
                                                            const err25 = {
                                                              instancePath: instancePath + "/scripts/" + key3.replace(/~/g, "~0").replace(/\//g, "~1") + "/timeLockType",
                                                              schemaPath: "#/definitions/AuthenticationTemplateScriptUnlocking/properties/timeLockType/enum",
                                                              keyword: "enum",
                                                              params: {
                                                                allowedValues: schema41.properties.timeLockType.enum
                                                              },
                                                              message: "must be equal to one of the allowed values"
                                                            };
                                                            if (vErrors === null) {
                                                              vErrors = [err25];
                                                            } else {
                                                              vErrors.push(err25);
                                                            }
                                                            errors++;
                                                          }
                                                          var valid10 = _errs64 === errors;
                                                        } else {
                                                          var valid10 = true;
                                                        }
                                                        if (valid10) {
                                                          if (data8.unlocks !== void 0) {
                                                            const _errs66 = errors;
                                                            if (typeof data8.unlocks !== "string") {
                                                              const err26 = {
                                                                instancePath: instancePath + "/scripts/" + key3.replace(/~/g, "~0").replace(/\//g, "~1") + "/unlocks",
                                                                schemaPath: "#/definitions/AuthenticationTemplateScriptUnlocking/properties/unlocks/type",
                                                                keyword: "type",
                                                                params: {
                                                                  type: "string"
                                                                },
                                                                message: "must be string"
                                                              };
                                                              if (vErrors === null) {
                                                                vErrors = [
                                                                  err26
                                                                ];
                                                              } else {
                                                                vErrors.push(err26);
                                                              }
                                                              errors++;
                                                            }
                                                            var valid10 = _errs66 === errors;
                                                          } else {
                                                            var valid10 = true;
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    } else {
                                      const err27 = {
                                        instancePath: instancePath + "/scripts/" + key3.replace(/~/g, "~0").replace(/\//g, "~1"),
                                        schemaPath: "#/definitions/AuthenticationTemplateScriptUnlocking/type",
                                        keyword: "type",
                                        params: { type: "object" },
                                        message: "must be object"
                                      };
                                      if (vErrors === null) {
                                        vErrors = [err27];
                                      } else {
                                        vErrors.push(err27);
                                      }
                                      errors++;
                                    }
                                  }
                                  var _valid0 = _errs40 === errors;
                                  valid4 = valid4 || _valid0;
                                }
                              }
                            }
                            if (!valid4) {
                              const err28 = {
                                instancePath: instancePath + "/scripts/" + key3.replace(/~/g, "~0").replace(/\//g, "~1"),
                                schemaPath: "#/properties/scripts/additionalProperties/anyOf",
                                keyword: "anyOf",
                                params: {},
                                message: "must match a schema in anyOf"
                              };
                              if (vErrors === null) {
                                vErrors = [err28];
                              } else {
                                vErrors.push(err28);
                              }
                              errors++;
                              validate21.errors = vErrors;
                              return false;
                            } else {
                              errors = _errs20;
                              if (vErrors !== null) {
                                if (_errs20) {
                                  vErrors.length = _errs20;
                                } else {
                                  vErrors = null;
                                }
                              }
                            }
                            var valid3 = _errs19 === errors;
                            if (!valid3) {
                              break;
                            }
                          }
                        } else {
                          validate21.errors = [
                            {
                              instancePath: instancePath + "/scripts",
                              schemaPath: "#/properties/scripts/type",
                              keyword: "type",
                              params: { type: "object" },
                              message: "must be object"
                            }
                          ];
                          return false;
                        }
                      }
                      var valid0 = _errs16 === errors;
                    } else {
                      var valid0 = true;
                    }
                    if (valid0) {
                      if (data.supported !== void 0) {
                        let data26 = data.supported;
                        const _errs68 = errors;
                        if (errors === _errs68) {
                          if (Array.isArray(data26)) {
                            var valid14 = true;
                            const len3 = data26.length;
                            for (let i3 = 0; i3 < len3; i3++) {
                              let data27 = data26[i3];
                              const _errs70 = errors;
                              if (typeof data27 !== "string") {
                                validate21.errors = [
                                  {
                                    instancePath: instancePath + "/supported/" + i3,
                                    schemaPath: "#/definitions/AuthenticationVirtualMachineIdentifier/type",
                                    keyword: "type",
                                    params: { type: "string" },
                                    message: "must be string"
                                  }
                                ];
                                return false;
                              }
                              if (!(data27 === "BCH_2020_05" || data27 === "BCH_2021_05" || data27 === "BCH_2022_05" || data27 === "BCH_2023_05" || data27 === "BCH_SPEC" || data27 === "BSV_2020_02" || data27 === "BSV_SPEC" || data27 === "BTC_2017_08" || data27 === "BTC_SPEC" || data27 === "XEC_2020_05" || data27 === "XEC_SPEC")) {
                                validate21.errors = [
                                  {
                                    instancePath: instancePath + "/supported/" + i3,
                                    schemaPath: "#/definitions/AuthenticationVirtualMachineIdentifier/enum",
                                    keyword: "enum",
                                    params: { allowedValues: schema42.enum },
                                    message: "must be equal to one of the allowed values"
                                  }
                                ];
                                return false;
                              }
                              var valid14 = _errs70 === errors;
                              if (!valid14) {
                                break;
                              }
                            }
                          } else {
                            validate21.errors = [
                              {
                                instancePath: instancePath + "/supported",
                                schemaPath: "#/properties/supported/type",
                                keyword: "type",
                                params: { type: "array" },
                                message: "must be array"
                              }
                            ];
                            return false;
                          }
                        }
                        var valid0 = _errs68 === errors;
                      } else {
                        var valid0 = true;
                      }
                      if (valid0) {
                        if (data.version !== void 0) {
                          let data28 = data.version;
                          const _errs73 = errors;
                          if (!(typeof data28 == "number" && isFinite(data28))) {
                            validate21.errors = [
                              {
                                instancePath: instancePath + "/version",
                                schemaPath: "#/properties/version/type",
                                keyword: "type",
                                params: { type: "number" },
                                message: "must be number"
                              }
                            ];
                            return false;
                          }
                          if (0 !== data28) {
                            validate21.errors = [
                              {
                                instancePath: instancePath + "/version",
                                schemaPath: "#/properties/version/const",
                                keyword: "const",
                                params: { allowedValue: 0 },
                                message: "must be equal to constant"
                              }
                            ];
                            return false;
                          }
                          var valid0 = _errs73 === errors;
                        } else {
                          var valid0 = true;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
      validate21.errors = [
        {
          instancePath,
          schemaPath: "#/type",
          keyword: "type",
          params: { type: "object" },
          message: "must be object"
        }
      ];
      return false;
    }
  }
  validate21.errors = vErrors;
  return errors === 0;
}
function validate20(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  let vErrors = null;
  let errors = 0;
  if (!validate21(data, {
    instancePath,
    parentData,
    parentDataProperty,
    rootData
  })) {
    vErrors = vErrors === null ? validate21.errors : vErrors.concat(validate21.errors);
    errors = vErrors.length;
  }
  validate20.errors = vErrors;
  return errors === 0;
}

// node_modules/@bitauth/libauth/build/lib/schema/ajv/ajv-utils.js
var avjErrorsToDescription = (errors) => (
  // TODO: translate instancePath
  errors.map((error) => `${error.instancePath}: ${error.message}`).join(",")
);
var ajvStandaloneJsonParse = (untrustedJsonOrObject, validator) => {
  try {
    const parsed = typeof untrustedJsonOrObject === "string" ? JSON.parse(untrustedJsonOrObject) : untrustedJsonOrObject;
    if (validator(parsed)) {
      return parsed;
    }
    return avjErrorsToDescription(validate_authentication_template_default.errors);
  } catch (e) {
    return `Invalid JSON. ${String(e)}`;
  }
};

// node_modules/@bitauth/libauth/build/lib/schema/authentication-template.js
var importAuthenticationTemplate = (untrustedJsonOrObject) => {
  const errorPrefix = `Authentication template import failed:`;
  const template = ajvStandaloneJsonParse(untrustedJsonOrObject, validate_authentication_template_default);
  if (typeof template === "string") {
    return `${errorPrefix}${template}`;
  }
  return template;
};

// node_modules/@bitauth/libauth/build/lib/compiler/compiler.js
var import_dist385 = __toESM(require_dist(), 1);
var import_dist386 = __toESM(require_dist2(), 1);
var import_dist387 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/compiler/compiler-bch/compiler-bch.js
var import_dist367 = __toESM(require_dist(), 1);
var import_dist368 = __toESM(require_dist2(), 1);
var import_dist369 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/compiler/compiler-operation-helpers.js
var import_dist355 = __toESM(require_dist(), 1);
var import_dist356 = __toESM(require_dist2(), 1);
var import_dist357 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/compiler/compiler-defaults.js
var import_dist352 = __toESM(require_dist(), 1);
var import_dist353 = __toESM(require_dist2(), 1);
var import_dist354 = __toESM(require_dist3(), 1);
var CompilerDefaults;
(function(CompilerDefaults2) {
  CompilerDefaults2[CompilerDefaults2["defaultScenarioAddressIndex"] = 0] = "defaultScenarioAddressIndex";
  CompilerDefaults2["defaultScenarioBytecode"] = "";
  CompilerDefaults2[CompilerDefaults2["defaultScenarioCurrentBlockHeight"] = 2] = "defaultScenarioCurrentBlockHeight";
  CompilerDefaults2[CompilerDefaults2["defaultScenarioCurrentBlockTime"] = 1231469665] = "defaultScenarioCurrentBlockTime";
  CompilerDefaults2["defaultScenarioInputOutpointTransactionHash"] = "0000000000000000000000000000000000000000000000000000000000000001";
  CompilerDefaults2["defaultScenarioOutputTokenCategory"] = "0000000000000000000000000000000000000000000000000000000000000002";
  CompilerDefaults2[CompilerDefaults2["defaultScenarioInputSequenceNumber"] = 0] = "defaultScenarioInputSequenceNumber";
  CompilerDefaults2[CompilerDefaults2["defaultScenarioOutputValueSatoshis"] = 0] = "defaultScenarioOutputValueSatoshis";
  CompilerDefaults2[CompilerDefaults2["defaultScenarioTransactionLocktime"] = 0] = "defaultScenarioTransactionLocktime";
  CompilerDefaults2[CompilerDefaults2["defaultScenarioTransactionVersion"] = 2] = "defaultScenarioTransactionVersion";
  CompilerDefaults2[CompilerDefaults2["hdKeyAddressOffset"] = 0] = "hdKeyAddressOffset";
  CompilerDefaults2["hdKeyHdPublicKeyDerivationPath"] = "m";
  CompilerDefaults2["hdKeyPrivateDerivationPath"] = "m/i";
  CompilerDefaults2["scenarioBytecodeScriptPrefix"] = "_scenario.";
})(CompilerDefaults || (CompilerDefaults = {}));

// node_modules/@bitauth/libauth/build/lib/compiler/compiler-operation-helpers.js
var attemptCompilerOperations = (operations, finalOperation) => (identifier, data, configuration) => {
  for (const operation of operations) {
    const result = operation(identifier, data, configuration);
    if (result.status !== "skip")
      return result;
  }
  return finalOperation(identifier, data, configuration);
};
var compilerOperationRequires = ({
  /**
   * If `true`, the accepted operation may return `false`, and any missing
   * properties will cause the returned operation to return `false` (meaning
   * the operation should be skipped)
   */
  canBeSkipped,
  /**
   * An array of the top-level properties required in the
   * {@link CompilationData}.
   */
  dataProperties,
  /**
   * An array of the top-level properties required in the
   * {@link CompilerConfiguration}
   */
  configurationProperties,
  /**
   * The operation to run if all required properties exist
   */
  operation
}) => (
  // eslint-disable-next-line complexity
  (identifier, data, configuration) => {
    for (const property of configurationProperties) {
      if (configuration[property] === void 0)
        return canBeSkipped ? { status: "skip" } : {
          error: `Cannot resolve "${identifier}" - the "${property}" property was not provided in the compiler configuration.`,
          status: "error"
        };
    }
    for (const property of dataProperties) {
      if (data[property] === void 0)
        return canBeSkipped ? { status: "skip" } : {
          error: `Cannot resolve "${identifier}" - the "${property}" property was not provided in the compilation data.`,
          status: "error"
        };
    }
    return operation(identifier, data, configuration);
  }
);
var compilerOperationAttemptBytecodeResolution = compilerOperationRequires({
  canBeSkipped: true,
  configurationProperties: [],
  dataProperties: ["bytecode"],
  operation: (identifier, data) => {
    const bytecode = data.bytecode[identifier];
    if (bytecode !== void 0) {
      return { bytecode, status: "success" };
    }
    return { status: "skip" };
  }
});
var compilerOperationHelperDeriveHdPrivateNode = ({ addressIndex, entityId, entityHdPrivateKey, configuration, hdKey, identifier }) => {
  const addressOffset = hdKey.addressOffset ?? CompilerDefaults.hdKeyAddressOffset;
  const privateDerivationPath = hdKey.privateDerivationPath ?? CompilerDefaults.hdKeyPrivateDerivationPath;
  const i = addressIndex + addressOffset;
  const validPrivatePathWithIndex = /^m(?:\/(?:[0-9]+|i)'?)*$/u;
  if (!validPrivatePathWithIndex.test(privateDerivationPath)) {
    return {
      error: `Could not generate ${identifier} - the path "${privateDerivationPath}" is not a valid "privateDerivationPath".`,
      status: "error"
    };
  }
  const instancePath = privateDerivationPath.replace("i", i.toString());
  const masterContents = decodeHdPrivateKey(entityHdPrivateKey, configuration);
  if (typeof masterContents === "string") {
    return {
      error: `Could not generate ${identifier} - the HD private key provided for ${entityId} could not be decoded: ${masterContents}`,
      status: "error"
    };
  }
  const instanceNode = deriveHdPath(masterContents.node, instancePath, configuration);
  if (typeof instanceNode === "string") {
    return {
      error: `Could not generate ${identifier} - the path "${instancePath}" could not be derived for entity "${entityId}": ${instanceNode}`,
      status: "error"
    };
  }
  return {
    bytecode: instanceNode.privateKey,
    status: "success"
  };
};
var compilerOperationHelperUnknownEntity = (identifier, variableId) => ({
  error: `Identifier "${identifier}" refers to an HdKey, but the "entityOwnership" for "${variableId}" is not available in this compiler configuration.`,
  status: "error"
});
var compilerOperationHelperAddressIndex = (identifier) => ({
  error: `Identifier "${identifier}" refers to an HdKey, but "hdKeys.addressIndex" was not provided in the compilation data.`,
  status: "error"
});
var compilerOperationHelperDeriveHdKeyPrivate = ({ configuration, hdKeys, identifier }) => {
  const { addressIndex, hdPrivateKeys } = hdKeys;
  const [variableId] = identifier.split(".");
  const entityId = configuration.entityOwnership[variableId];
  if (entityId === void 0) {
    return compilerOperationHelperUnknownEntity(identifier, variableId);
  }
  if (addressIndex === void 0) {
    return compilerOperationHelperAddressIndex(identifier);
  }
  const entityHdPrivateKey = hdPrivateKeys === void 0 ? void 0 : hdPrivateKeys[entityId];
  if (entityHdPrivateKey === void 0) {
    return {
      error: `Identifier "${identifier}" refers to an HdKey owned by "${entityId}", but an HD private key for this entity (or an existing signature) was not provided in the compilation data.`,
      recoverable: true,
      status: "error"
    };
  }
  const hdKey = configuration.variables[variableId];
  return compilerOperationHelperDeriveHdPrivateNode({
    addressIndex,
    configuration,
    entityHdPrivateKey,
    entityId,
    hdKey,
    identifier
  });
};
var compilerOperationHelperCompileScript = ({ targetScriptId, data, configuration }) => {
  const signingTarget = configuration.scripts[targetScriptId];
  const compiledTarget = resolveScriptIdentifier({
    configuration,
    data,
    identifier: targetScriptId
  });
  if (signingTarget === void 0 || compiledTarget === false) {
    return false;
  }
  if (typeof compiledTarget === "string") {
    return {
      error: compiledTarget,
      status: "error"
    };
  }
  return compiledTarget.bytecode;
};
var compilerOperationHelperGenerateCoveredBytecode = ({ data, configuration, identifier, sourceScriptIds, unlockingScripts }) => {
  const currentScriptId = sourceScriptIds[sourceScriptIds.length - 1];
  if (currentScriptId === void 0) {
    return {
      error: `Identifier "${identifier}" requires a signing serialization, but "coveredBytecode" cannot be determined because the compiler configuration's "sourceScriptIds" is empty.`,
      status: "error"
    };
  }
  const targetLockingScriptId = unlockingScripts[currentScriptId];
  if (targetLockingScriptId === void 0) {
    return {
      error: `Identifier "${identifier}" requires a signing serialization, but "coveredBytecode" cannot be determined because "${currentScriptId}" is not present in the compiler configuration's "unlockingScripts".`,
      status: "error"
    };
  }
  const result = compilerOperationHelperCompileScript({
    configuration,
    data,
    targetScriptId: targetLockingScriptId
  });
  if (result === false) {
    return {
      error: `Identifier "${identifier}" requires a signing serialization that covers an unknown locking script, "${targetLockingScriptId}".`,
      status: "error"
    };
  }
  return result;
};

// node_modules/@bitauth/libauth/build/lib/compiler/compiler-operations.js
var import_dist358 = __toESM(require_dist(), 1);
var import_dist359 = __toESM(require_dist2(), 1);
var import_dist360 = __toESM(require_dist3(), 1);
var compilerOperationAddressData = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: [],
  dataProperties: ["bytecode"],
  operation: (identifier, data) => {
    const bytecode = data.bytecode[identifier];
    if (bytecode !== void 0) {
      return { bytecode, status: "success" };
    }
    return {
      error: `Identifier "${identifier}" refers to an AddressData, but "${identifier}" was not provided in the CompilationData "bytecode".`,
      recoverable: true,
      status: "error"
    };
  }
});
var compilerOperationWalletData = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: [],
  dataProperties: ["bytecode"],
  operation: (identifier, data) => {
    const bytecode = data.bytecode[identifier];
    if (bytecode !== void 0) {
      return { bytecode, status: "success" };
    }
    return {
      error: `Identifier "${identifier}" refers to a WalletData, but "${identifier}" was not provided in the CompilationData "bytecode".`,
      recoverable: true,
      status: "error"
    };
  }
});
var compilerOperationCurrentBlockTime = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: [],
  dataProperties: ["currentBlockTime"],
  operation: (_2, data) => ({
    bytecode: numberToBinUint32LE(data.currentBlockTime),
    status: "success"
  })
});
var compilerOperationCurrentBlockHeight = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: [],
  dataProperties: ["currentBlockHeight"],
  operation: (_2, data) => ({
    bytecode: bigIntToVmNumber(BigInt(data.currentBlockHeight)),
    status: "success"
  })
});
var compilerOperationSigningSerializationCorrespondingOutput = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: [],
  dataProperties: ["compilationContext"],
  operation: (_2, data) => {
    const { correspondingOutput } = generateSigningSerializationComponentsBCH(data.compilationContext);
    return correspondingOutput === void 0 ? { bytecode: Uint8Array.of(), status: "success" } : {
      bytecode: correspondingOutput,
      status: "success"
    };
  }
});
var compilerOperationSigningSerializationCorrespondingOutputHash = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: ["sha256"],
  dataProperties: ["compilationContext"],
  operation: (_2, data, configuration) => {
    const { correspondingOutput } = generateSigningSerializationComponentsBCH(data.compilationContext);
    return correspondingOutput === void 0 ? { bytecode: Uint8Array.of(), status: "success" } : {
      bytecode: configuration.sha256.hash(configuration.sha256.hash(correspondingOutput)),
      status: "success"
    };
  }
});
var compilerOperationHelperSigningSerializationCoveredBytecode = (returnLength) => compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: ["sourceScriptIds", "unlockingScripts"],
  dataProperties: ["compilationContext"],
  operation: (identifier, data, configuration) => {
    const { unlockingScripts, sourceScriptIds } = configuration;
    const result = compilerOperationHelperGenerateCoveredBytecode({
      configuration,
      data,
      identifier,
      sourceScriptIds,
      unlockingScripts
    });
    if ("error" in result) {
      return result;
    }
    return {
      bytecode: returnLength ? bigIntToCompactSize(BigInt(result.length)) : result,
      status: "success"
    };
  }
});
var compilerOperationSigningSerializationCoveredBytecode = compilerOperationHelperSigningSerializationCoveredBytecode(false);
var compilerOperationSigningSerializationCoveredBytecodeLength = compilerOperationHelperSigningSerializationCoveredBytecode(true);
var compilerOperationSigningSerializationLocktime = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: [],
  dataProperties: ["compilationContext"],
  operation: (_2, data) => ({
    bytecode: numberToBinUint32LE(data.compilationContext.transaction.locktime),
    status: "success"
  })
});
var compilerOperationSigningSerializationOutpointIndex = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: [],
  dataProperties: ["compilationContext"],
  operation: (_2, data) => ({
    bytecode: numberToBinUint32LE(
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      data.compilationContext.transaction.inputs[data.compilationContext.inputIndex].outpointIndex
    ),
    status: "success"
  })
});
var compilerOperationSigningSerializationOutpointTransactionHash = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: [],
  dataProperties: ["compilationContext"],
  operation: (_2, data) => ({
    bytecode: (
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      data.compilationContext.transaction.inputs[data.compilationContext.inputIndex].outpointTransactionHash
    ),
    status: "success"
  })
});
var compilerOperationSigningSerializationOutputValue = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: [],
  dataProperties: ["compilationContext"],
  operation: (_2, data) => ({
    bytecode: valueSatoshisToBin(
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      data.compilationContext.sourceOutputs[data.compilationContext.inputIndex].valueSatoshis
    ),
    status: "success"
  })
});
var compilerOperationSigningSerializationSequenceNumber = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: [],
  dataProperties: ["compilationContext"],
  operation: (_2, data) => ({
    bytecode: numberToBinUint32LE(
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      data.compilationContext.transaction.inputs[data.compilationContext.inputIndex].sequenceNumber
    ),
    status: "success"
  })
});
var compilerOperationSigningSerializationTransactionOutpoints = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: [],
  dataProperties: ["compilationContext"],
  operation: (_2, data) => ({
    bytecode: encodeTransactionOutpoints(data.compilationContext.transaction.inputs),
    status: "success"
  })
});
var compilerOperationSigningSerializationTransactionOutpointsHash = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: ["sha256"],
  dataProperties: ["compilationContext"],
  operation: (_2, data, configuration) => ({
    bytecode: configuration.sha256.hash(configuration.sha256.hash(encodeTransactionOutpoints(data.compilationContext.transaction.inputs))),
    status: "success"
  })
});
var compilerOperationSigningSerializationTransactionOutputs = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: [],
  dataProperties: ["compilationContext"],
  operation: (_2, data) => ({
    bytecode: encodeTransactionOutputsForSigning(data.compilationContext.transaction.outputs),
    status: "success"
  })
});
var compilerOperationSigningSerializationTransactionOutputsHash = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: ["sha256"],
  dataProperties: ["compilationContext"],
  operation: (_2, data, configuration) => ({
    bytecode: configuration.sha256.hash(configuration.sha256.hash(encodeTransactionOutputsForSigning(data.compilationContext.transaction.outputs))),
    status: "success"
  })
});
var compilerOperationSigningSerializationTransactionSequenceNumbers = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: [],
  dataProperties: ["compilationContext"],
  operation: (_2, data) => ({
    bytecode: encodeTransactionInputSequenceNumbersForSigning(data.compilationContext.transaction.inputs),
    status: "success"
  })
});
var compilerOperationSigningSerializationTransactionSequenceNumbersHash = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: ["sha256"],
  dataProperties: ["compilationContext"],
  operation: (_2, data, configuration) => ({
    bytecode: configuration.sha256.hash(configuration.sha256.hash(encodeTransactionInputSequenceNumbersForSigning(data.compilationContext.transaction.inputs))),
    status: "success"
  })
});
var compilerOperationSigningSerializationVersion = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: [],
  dataProperties: ["compilationContext"],
  operation: (_2, data) => ({
    bytecode: numberToBinUint32LE(data.compilationContext.transaction.version),
    status: "success"
  })
});
var compilerOperationKeyPublicKeyCommon = attemptCompilerOperations([compilerOperationAttemptBytecodeResolution], compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: ["secp256k1"],
  dataProperties: ["keys"],
  operation: (identifier, data, configuration) => {
    const { keys } = data;
    const { secp256k1: secp256k12 } = configuration;
    const { privateKeys } = keys;
    const [variableId] = identifier.split(".");
    if (privateKeys?.[variableId] !== void 0) {
      return {
        bytecode: secp256k12.derivePublicKeyCompressed(
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          privateKeys[variableId]
        ),
        status: "success"
      };
    }
    return {
      error: `Identifier "${identifier}" refers to a public key, but no public or private keys for "${variableId}" were provided in the compilation data.`,
      recoverable: true,
      status: "error"
    };
  }
}));
var compilerOperationHdKeyPublicKeyCommon = attemptCompilerOperations([compilerOperationAttemptBytecodeResolution], compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: [
    "entityOwnership",
    "ripemd160",
    "secp256k1",
    "sha256",
    "sha512",
    "variables"
  ],
  dataProperties: ["hdKeys"],
  operation: (
    // eslint-disable-next-line complexity
    (identifier, data, configuration) => {
      const { hdKeys } = data;
      const { hdPrivateKeys, addressIndex, hdPublicKeys } = hdKeys;
      const [variableId] = identifier.split(".");
      const entityId = configuration.entityOwnership[variableId];
      if (entityId === void 0) {
        return compilerOperationHelperUnknownEntity(identifier, variableId);
      }
      if (addressIndex === void 0) {
        return compilerOperationHelperAddressIndex(identifier);
      }
      const entityHdPrivateKey = hdPrivateKeys === void 0 ? void 0 : hdPrivateKeys[entityId];
      const hdKey = configuration.variables[variableId];
      if (entityHdPrivateKey !== void 0) {
        const privateResult = compilerOperationHelperDeriveHdPrivateNode({
          addressIndex,
          configuration,
          entityHdPrivateKey,
          entityId,
          hdKey,
          identifier
        });
        if (privateResult.status === "error")
          return privateResult;
        return {
          bytecode: configuration.secp256k1.derivePublicKeyCompressed(privateResult.bytecode),
          status: "success"
        };
      }
      const entityHdPublicKey = hdPublicKeys === void 0 ? void 0 : hdPublicKeys[entityId];
      if (entityHdPublicKey === void 0) {
        return {
          error: `Identifier "${identifier}" refers to an HdKey owned by "${entityId}", but an HD private key or HD public key for this entity was not provided in the compilation data.`,
          recoverable: true,
          status: "error"
        };
      }
      const addressOffset = hdKey.addressOffset ?? CompilerDefaults.hdKeyAddressOffset;
      const privateDerivationPath = hdKey.privateDerivationPath ?? CompilerDefaults.hdKeyPrivateDerivationPath;
      const publicDerivationPath = hdKey.publicDerivationPath ?? privateDerivationPath.replace("m", "M");
      const validPublicPathWithIndex = /^M(?:\/(?:[0-9]+|i))*$/u;
      if (!validPublicPathWithIndex.test(publicDerivationPath)) {
        return {
          error: `Could not generate ${identifier} - the path "${publicDerivationPath}" is not a valid "publicDerivationPath".`,
          status: "error"
        };
      }
      const i = addressIndex + addressOffset;
      const instancePath = publicDerivationPath.replace("i", i.toString());
      const masterContents = decodeHdPublicKey(entityHdPublicKey, configuration);
      if (typeof masterContents === "string") {
        return {
          error: `Could not generate "${identifier}" - the HD public key provided for "${entityId}" could not be decoded: ${masterContents}`,
          status: "error"
        };
      }
      const instanceNode = deriveHdPath(masterContents.node, instancePath, configuration);
      if (typeof instanceNode === "string") {
        return {
          error: `Could not generate "${identifier}" - the path "${instancePath}" could not be derived for entity "${entityId}": ${instanceNode}`,
          status: "error"
        };
      }
      return { bytecode: instanceNode.publicKey, status: "success" };
    }
  )
}));
var compilerOperationsCommon = {
  addressData: compilerOperationAddressData,
  currentBlockHeight: compilerOperationCurrentBlockHeight,
  currentBlockTime: compilerOperationCurrentBlockTime,
  hdKey: {
    public_key: compilerOperationHdKeyPublicKeyCommon
  },
  key: {
    public_key: compilerOperationKeyPublicKeyCommon
  },
  signingSerialization: {
    corresponding_output: compilerOperationSigningSerializationCorrespondingOutput,
    corresponding_output_hash: compilerOperationSigningSerializationCorrespondingOutputHash,
    covered_bytecode: compilerOperationSigningSerializationCoveredBytecode,
    covered_bytecode_length: compilerOperationSigningSerializationCoveredBytecodeLength,
    locktime: compilerOperationSigningSerializationLocktime,
    outpoint_index: compilerOperationSigningSerializationOutpointIndex,
    outpoint_transaction_hash: compilerOperationSigningSerializationOutpointTransactionHash,
    output_value: compilerOperationSigningSerializationOutputValue,
    sequence_number: compilerOperationSigningSerializationSequenceNumber,
    transaction_outpoints: compilerOperationSigningSerializationTransactionOutpoints,
    transaction_outpoints_hash: compilerOperationSigningSerializationTransactionOutpointsHash,
    transaction_outputs: compilerOperationSigningSerializationTransactionOutputs,
    transaction_outputs_hash: compilerOperationSigningSerializationTransactionOutputsHash,
    transaction_sequence_numbers: compilerOperationSigningSerializationTransactionSequenceNumbers,
    transaction_sequence_numbers_hash: compilerOperationSigningSerializationTransactionSequenceNumbersHash,
    version: compilerOperationSigningSerializationVersion
  },
  walletData: compilerOperationWalletData
};

// node_modules/@bitauth/libauth/build/lib/compiler/compiler-utils.js
var import_dist364 = __toESM(require_dist(), 1);
var import_dist365 = __toESM(require_dist2(), 1);
var import_dist366 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/compiler/scenarios.js
var import_dist361 = __toESM(require_dist(), 1);
var import_dist362 = __toESM(require_dist2(), 1);
var import_dist363 = __toESM(require_dist3(), 1);
var defaultScenarioOutputLockingBytecode = () => ({});
var generateDefaultScenarioDefinition = (configuration) => {
  const { variables, entityOwnership } = configuration;
  const keyVariableIds = variables === void 0 ? [] : Object.entries(variables).filter((entry) => entry[1].type === "Key").map(([id]) => id);
  const entityIds = entityOwnership === void 0 ? [] : Object.keys(Object.values(entityOwnership).reduce((all, entityId) => ({ ...all, [entityId]: true }), {}));
  const valueMap = [...keyVariableIds, ...entityIds].sort((idA, idB) => idA.localeCompare(idB, "en")).reduce((all, id, index2) => ({
    ...all,
    [id]: bigIntToBinUint256BEClamped(BigInt(index2 + 1))
  }), {});
  const privateKeys = variables === void 0 ? void 0 : Object.entries(variables).reduce((all, [variableId, variable]) => variable.type === "Key" ? {
    ...all,
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    [variableId]: binToHex(valueMap[variableId])
  } : all, {});
  const defaultScenario = {
    data: {
      currentBlockHeight: CompilerDefaults.defaultScenarioCurrentBlockHeight,
      currentBlockTime: CompilerDefaults.defaultScenarioCurrentBlockTime,
      ...privateKeys === void 0 || Object.keys(privateKeys).length === 0 ? {} : { keys: { privateKeys } }
    },
    sourceOutputs: [{ lockingBytecode: ["slot"] }],
    transaction: {
      inputs: [{ unlockingBytecode: ["slot"] }],
      locktime: CompilerDefaults.defaultScenarioTransactionLocktime,
      outputs: [{ lockingBytecode: defaultScenarioOutputLockingBytecode() }],
      version: CompilerDefaults.defaultScenarioTransactionVersion
    }
  };
  const hasHdKeys = variables === void 0 ? false : Object.values(variables).findIndex((variable) => variable.type === "HdKey") !== -1;
  if (!hasHdKeys) {
    return defaultScenario;
  }
  const { sha256: sha2562, sha512: sha5122 } = configuration;
  if (sha2562 === void 0) {
    return 'An implementations of "sha256" is required to generate defaults for HD keys, but the "sha256" property is not included in this compiler configuration.';
  }
  if (sha5122 === void 0) {
    return 'An implementations of "sha512" is required to generate defaults for HD keys, but the "sha512" property is not included in this compiler configuration.';
  }
  const crypto = { sha256: sha2562, sha512: sha5122 };
  const hdPrivateKeys = entityIds.reduce((all, entityId) => {
    const assumeValid = true;
    const masterNode = deriveHdPrivateNodeFromSeed(
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      valueMap[entityId],
      assumeValid,
      crypto
    );
    const hdPrivateKey = encodeHdPrivateKey({
      network: "mainnet",
      node: masterNode
    }, crypto);
    return { ...all, [entityId]: hdPrivateKey };
  }, {});
  return {
    ...defaultScenario,
    data: {
      ...defaultScenario.data,
      hdKeys: {
        addressIndex: CompilerDefaults.defaultScenarioAddressIndex,
        hdPrivateKeys
      }
    }
  };
};
var extendScenarioDefinitionData = (parentData, childData) => ({
  ...parentData,
  ...childData,
  ...parentData.bytecode === void 0 && childData.bytecode === void 0 ? {} : {
    bytecode: {
      ...parentData.bytecode,
      ...childData.bytecode
    }
  },
  ...parentData.hdKeys === void 0 && childData.hdKeys === void 0 ? {} : {
    hdKeys: {
      ...parentData.hdKeys,
      ...childData.hdKeys,
      ...parentData.hdKeys?.hdPrivateKeys === void 0 && childData.hdKeys?.hdPrivateKeys === void 0 ? {} : {
        hdPrivateKeys: {
          ...parentData.hdKeys?.hdPrivateKeys,
          ...childData.hdKeys?.hdPrivateKeys
        }
      },
      ...parentData.hdKeys?.hdPublicKeys === void 0 && childData.hdKeys?.hdPublicKeys === void 0 ? {} : {
        hdPublicKeys: {
          ...parentData.hdKeys?.hdPublicKeys,
          ...childData.hdKeys?.hdPublicKeys
        }
      }
    }
  },
  ...parentData.keys === void 0 && childData.keys === void 0 ? {} : {
    keys: {
      privateKeys: {
        ...parentData.keys?.privateKeys,
        ...childData.keys?.privateKeys
      }
    }
  }
});
var extendScenarioDefinition = (parentScenario, childScenario) => ({
  ...parentScenario.data === void 0 && childScenario.data === void 0 ? {} : {
    data: extendScenarioDefinitionData(parentScenario.data ?? {}, childScenario.data ?? {})
  },
  ...parentScenario.transaction === void 0 && childScenario.transaction === void 0 ? {} : {
    transaction: {
      ...parentScenario.transaction,
      ...childScenario.transaction
    }
  },
  ...parentScenario.sourceOutputs === void 0 && childScenario.sourceOutputs === void 0 ? {} : {
    sourceOutputs: childScenario.sourceOutputs ?? parentScenario.sourceOutputs
  }
});
var generateExtendedScenario = ({ configuration, scenarioId, sourceScenarioIds = [] }) => {
  if (scenarioId === void 0) {
    return generateDefaultScenarioDefinition(configuration);
  }
  if (sourceScenarioIds.includes(scenarioId)) {
    return `Cannot extend scenario "${scenarioId}": scenario "${scenarioId}" extends itself. Scenario inheritance path: ${sourceScenarioIds.join(" → ")}`;
  }
  const scenario = configuration.scenarios?.[scenarioId];
  if (scenario === void 0) {
    return `Cannot extend scenario "${scenarioId}": a scenario with the identifier ${scenarioId} is not included in this compiler configuration.`;
  }
  const parentScenario = scenario.extends === void 0 ? generateDefaultScenarioDefinition(configuration) : generateExtendedScenario({
    configuration,
    scenarioId: scenario.extends,
    sourceScenarioIds: [...sourceScenarioIds, scenarioId]
  });
  if (typeof parentScenario === "string") {
    return parentScenario;
  }
  return extendScenarioDefinition(parentScenario, scenario);
};
var extendedScenarioDefinitionToCompilationData = (definition) => ({
  ...definition.data.currentBlockHeight === void 0 ? {} : {
    currentBlockHeight: definition.data.currentBlockHeight
  },
  ...definition.data.currentBlockTime === void 0 ? {} : {
    currentBlockTime: definition.data.currentBlockTime
  },
  ...definition.data.hdKeys === void 0 ? {} : {
    hdKeys: {
      ...definition.data.hdKeys.addressIndex === void 0 ? {} : {
        addressIndex: definition.data.hdKeys.addressIndex
      },
      ...definition.data.hdKeys.hdPrivateKeys !== void 0 && Object.keys(definition.data.hdKeys.hdPrivateKeys).length > 0 ? {
        hdPrivateKeys: definition.data.hdKeys.hdPrivateKeys
      } : {},
      ...definition.data.hdKeys.hdPublicKeys === void 0 ? {} : {
        hdPublicKeys: definition.data.hdKeys.hdPublicKeys
      }
    }
  },
  ...definition.data.keys?.privateKeys !== void 0 && Object.keys(definition.data.keys.privateKeys).length > 0 ? {
    keys: {
      privateKeys: Object.entries(definition.data.keys.privateKeys).reduce((all, [id, hex]) => ({ ...all, [id]: hexToBin(hex) }), {})
    }
  } : {}
});
var extendCompilationDataWithScenarioBytecode = ({ compilationData, configuration, scenarioDataBytecodeScripts }) => {
  const prefixBytecodeScriptId = (id) => `${CompilerDefaults.scenarioBytecodeScriptPrefix}${id}`;
  const bytecodeScripts = Object.entries(scenarioDataBytecodeScripts).reduce((all, [id, script]) => ({
    ...all,
    [prefixBytecodeScriptId(id)]: script
  }), {});
  const bytecodeScriptExtendedConfiguration = {
    ...configuration,
    scripts: {
      ...configuration.scripts,
      ...bytecodeScripts
    }
  };
  const bytecodeCompilations = Object.keys(scenarioDataBytecodeScripts).map((id) => {
    const result = compileScriptRaw({
      configuration: bytecodeScriptExtendedConfiguration,
      data: compilationData,
      scriptId: prefixBytecodeScriptId(id)
    });
    if (result.success) {
      return {
        bytecode: result.bytecode,
        id
      };
    }
    return {
      errors: result.errors,
      id
    };
  });
  const failedResults = bytecodeCompilations.filter((result) => "errors" in result);
  if (failedResults.length > 0) {
    return `${failedResults.map((result) => `Compilation error while generating bytecode for "${result.id}": ${stringifyErrors(result.errors)}`).join("; ")}`;
  }
  const compiledBytecode = bytecodeCompilations.reduce((all, result) => ({ ...all, [result.id]: result.bytecode }), {});
  return {
    ...Object.keys(compiledBytecode).length > 0 ? { bytecode: compiledBytecode } : {},
    ...compilationData
  };
};
var compileAuthenticationTemplateScenarioValueSatoshis = (valueSatoshisDefinition = CompilerDefaults.defaultScenarioOutputValueSatoshis) => typeof valueSatoshisDefinition === "string" ? binToValueSatoshis(hexToBin(valueSatoshisDefinition)) : BigInt(valueSatoshisDefinition);
var compileAuthenticationTemplateScenarioBytecode = ({ bytecodeDefinition, compilationContext, configuration, defaultOverride, extendedScenario, generateBytecode, lockingOrUnlockingScriptIdUnderTest }) => {
  if (typeof bytecodeDefinition === "string") {
    return hexToBin(bytecodeDefinition);
  }
  const scriptId = bytecodeDefinition.script === void 0 || Array.isArray(bytecodeDefinition.script) ? lockingOrUnlockingScriptIdUnderTest : bytecodeDefinition.script;
  if (scriptId === void 0) {
    return hexToBin("");
  }
  const overrides = bytecodeDefinition.overrides ?? defaultOverride;
  const overriddenDataDefinition = extendScenarioDefinitionData(extendedScenario.data, overrides);
  const data = extendCompilationDataWithScenarioBytecode({
    compilationData: extendedScenarioDefinitionToCompilationData({
      data: overriddenDataDefinition
    }),
    configuration,
    scenarioDataBytecodeScripts: overriddenDataDefinition.bytecode ?? {}
  });
  if (typeof data === "string") {
    const error = `Could not compile scenario "data.bytecode": ${data}`;
    return { errors: [{ error }], success: false };
  }
  return generateBytecode({
    data: { ...data, compilationContext },
    debug: true,
    scriptId
  });
};
var compileScenarioOutputTokenData = (output) => output.token === void 0 ? {} : {
  token: {
    amount: BigInt(output.token.amount ?? 0),
    // TODO: doesn't verify length
    category: hexToBin(output.token.category ?? CompilerDefaults.defaultScenarioOutputTokenCategory),
    ...output.token.nft === void 0 ? {} : {
      nft: {
        capability: output.token.nft.capability ?? "none",
        commitment: hexToBin(output.token.nft.commitment ?? "")
      }
    }
  }
};
var generateScenarioBCH = ({ configuration, generateBytecode, scenarioId, unlockingScriptId, lockingScriptId: providedLockingScriptId }, debug) => {
  const { scenarioDefinition, scenarioName } = scenarioId === void 0 ? { scenarioDefinition: {}, scenarioName: `the default scenario` } : {
    scenarioDefinition: configuration.scenarios?.[scenarioId],
    scenarioName: `scenario "${scenarioId}"`
  };
  if (scenarioDefinition === void 0) {
    return `Cannot generate ${scenarioName}: a scenario definition with the identifier ${scenarioId} is not included in this compiler configuration.`;
  }
  const parentScenario = generateExtendedScenario({ configuration, scenarioId });
  if (typeof parentScenario === "string") {
    return `Cannot generate ${scenarioName}: ${parentScenario}`;
  }
  const extendedScenario = extendScenarioDefinition(parentScenario, scenarioDefinition);
  const partialCompilationData = extendedScenarioDefinitionToCompilationData(extendedScenario);
  const fullCompilationData = extendCompilationDataWithScenarioBytecode({
    compilationData: partialCompilationData,
    configuration,
    scenarioDataBytecodeScripts: extendedScenario.data.bytecode ?? {}
  });
  if (typeof fullCompilationData === "string") {
    return `Cannot generate ${scenarioName}. ${fullCompilationData}`;
  }
  if (extendedScenario.transaction.inputs.length !== extendedScenario.sourceOutputs.length) {
    return `Cannot generate ${scenarioName}: could not match source outputs with inputs - "sourceOutputs" must be the same length as "transaction.inputs".`;
  }
  const testedInputs = extendedScenario.transaction.inputs.filter((input) => Array.isArray(input.unlockingBytecode));
  if (testedInputs.length !== 1) {
    return `Cannot generate ${scenarioName}: the specific input under test in this scenario is ambiguous - "transaction.inputs" must include exactly one input that has "unlockingBytecode" set to ["slot"].`;
  }
  const testedInputIndex = extendedScenario.transaction.inputs.findIndex((input) => Array.isArray(input.unlockingBytecode));
  const testedSourceOutputs = extendedScenario.sourceOutputs.filter((output) => Array.isArray(output.lockingBytecode));
  if (testedSourceOutputs.length !== 1) {
    return `Cannot generate ${scenarioName}: the source output unlocked by the input under test in this scenario is ambiguous - "sourceOutputs" must include exactly one output that has "lockingBytecode" set to ["slot"].`;
  }
  if (!Array.isArray(extendedScenario.sourceOutputs[testedInputIndex]?.lockingBytecode)) {
    return `Cannot generate ${scenarioName}: the source output unlocked by the input under test in this scenario is ambiguous - the ["slot"] in "transaction.inputs" and "sourceOutputs" must be at the same index.`;
  }
  if (unlockingScriptId !== void 0 && providedLockingScriptId !== void 0) {
    return `Cannot generate ${scenarioName}: a scenario cannot be generated with both unlocking and locking script IDs defined. If an unlocking script is provided, the associated locking script ID must be read from the template.`;
  }
  const lockingScriptId = providedLockingScriptId === void 0 ? unlockingScriptId === void 0 ? void 0 : configuration.unlockingScripts?.[unlockingScriptId] : providedLockingScriptId;
  if (unlockingScriptId !== void 0 && lockingScriptId === void 0) {
    return `Cannot generate ${scenarioName} using unlocking script "${unlockingScriptId}": the locking script unlocked by "${unlockingScriptId}" is not provided in this compiler configuration.`;
  }
  const sourceOutputCompilations = extendedScenario.sourceOutputs.map((sourceOutput, index2) => {
    const slot = Array.isArray(sourceOutput.lockingBytecode);
    const bytecodeDefinition = slot ? lockingScriptId === void 0 ? CompilerDefaults.defaultScenarioBytecode : { script: lockingScriptId } : sourceOutput.lockingBytecode ?? {};
    const defaultOverride = {};
    return {
      compiled: {
        lockingBytecode: compileAuthenticationTemplateScenarioBytecode({
          bytecodeDefinition,
          configuration,
          defaultOverride,
          extendedScenario,
          generateBytecode,
          lockingOrUnlockingScriptIdUnderTest: lockingScriptId
        }),
        valueSatoshis: compileAuthenticationTemplateScenarioValueSatoshis(sourceOutput.valueSatoshis),
        ...compileScenarioOutputTokenData(sourceOutput)
      },
      index: index2,
      slot,
      type: "source output"
    };
  });
  const lockingCompilation = sourceOutputCompilations.find((compilation) => compilation.slot)?.compiled.lockingBytecode;
  const transactionOutputCompilations = extendedScenario.transaction.outputs.map((transactionOutput, index2) => {
    const defaultOverride = { hdKeys: { addressIndex: 1 } };
    return {
      compiled: {
        lockingBytecode: compileAuthenticationTemplateScenarioBytecode({
          bytecodeDefinition: transactionOutput.lockingBytecode ?? {},
          configuration,
          defaultOverride,
          extendedScenario,
          generateBytecode,
          lockingOrUnlockingScriptIdUnderTest: lockingScriptId
        }),
        valueSatoshis: compileAuthenticationTemplateScenarioValueSatoshis(transactionOutput.valueSatoshis),
        ...compileScenarioOutputTokenData(transactionOutput)
      },
      index: index2,
      type: "transaction output"
    };
  });
  const outputCompilationErrors = [
    ...sourceOutputCompilations,
    ...transactionOutputCompilations
  ].reduce((accumulated, result) => {
    if ("errors" in result.compiled.lockingBytecode) {
      return [
        ...accumulated,
        ...result.compiled.lockingBytecode.errors.map((errorObject) => `Failed compilation of ${result.type} at index ${result.index}: ${errorObject.error}`)
      ];
    }
    return accumulated;
  }, []);
  if (outputCompilationErrors.length > 0) {
    const error = `Cannot generate ${scenarioName}: ${outputCompilationErrors.join(" ")}`;
    if (debug === true) {
      return {
        lockingCompilation,
        scenario: error
      };
    }
    return error;
  }
  const sourceOutputCompilationsSuccess = sourceOutputCompilations;
  const transactionOutputCompilationsSuccess = transactionOutputCompilations;
  const extractOutput = (compilation) => {
    const { lockingBytecode, valueSatoshis, token } = compilation.compiled;
    return {
      lockingBytecode: "bytecode" in lockingBytecode ? lockingBytecode.bytecode : lockingBytecode,
      valueSatoshis,
      ...token === void 0 ? {} : { token }
    };
  };
  const sourceOutputs = sourceOutputCompilationsSuccess.map(extractOutput);
  const outputs = transactionOutputCompilationsSuccess.map(extractOutput);
  const inputsContext = extendedScenario.transaction.inputs.map((input, inputIndex) => ({
    outpointIndex: input.outpointIndex ?? inputIndex,
    // TODO: doesn't verify length
    outpointTransactionHash: hexToBin(input.outpointTransactionHash ?? CompilerDefaults.defaultScenarioInputOutpointTransactionHash),
    sequenceNumber: input.sequenceNumber ?? CompilerDefaults.defaultScenarioInputSequenceNumber,
    unlockingBytecode: void 0
  }));
  const transactionInputCompilations = extendedScenario.transaction.inputs.map((input, index2) => {
    const slot = Array.isArray(input.unlockingBytecode);
    const bytecodeDefinition = Array.isArray(input.unlockingBytecode) ? unlockingScriptId === void 0 ? CompilerDefaults.defaultScenarioBytecode : { script: unlockingScriptId } : input.unlockingBytecode ?? {};
    const defaultOverride = {};
    return {
      compiled: {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        outpointIndex: inputsContext[index2].outpointIndex,
        outpointTransactionHash: (
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          inputsContext[index2].outpointTransactionHash
        ),
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        sequenceNumber: inputsContext[index2].sequenceNumber,
        unlockingBytecode: compileAuthenticationTemplateScenarioBytecode({
          bytecodeDefinition,
          compilationContext: {
            inputIndex: index2,
            sourceOutputs,
            transaction: {
              inputs: inputsContext,
              locktime: extendedScenario.transaction.locktime,
              outputs,
              version: extendedScenario.transaction.version
            }
          },
          configuration,
          defaultOverride,
          extendedScenario,
          generateBytecode,
          lockingOrUnlockingScriptIdUnderTest: unlockingScriptId
        })
      },
      index: index2,
      slot
    };
  });
  const unlockingCompilation = transactionInputCompilations.find((compilation) => compilation.slot)?.compiled.unlockingBytecode;
  const inputCompilationErrors = transactionInputCompilations.reduce((accumulated, result) => {
    if ("errors" in result.compiled.unlockingBytecode) {
      return [
        ...accumulated,
        ...result.compiled.unlockingBytecode.errors.map((errorObject) => `Failed compilation of input at index ${result.index}: ${errorObject.error}`)
      ];
    }
    return accumulated;
  }, []);
  if (inputCompilationErrors.length > 0) {
    const error = `Cannot generate ${scenarioName}: ${inputCompilationErrors.join(" ")}`;
    if (debug === true) {
      return {
        lockingCompilation,
        scenario: error,
        unlockingCompilation
      };
    }
    return error;
  }
  const transactionInputCompilationsSuccess = transactionInputCompilations;
  const inputs = transactionInputCompilationsSuccess.map((compilation) => {
    const { outpointIndex, outpointTransactionHash, sequenceNumber, unlockingBytecode } = compilation.compiled;
    return {
      outpointIndex,
      outpointTransactionHash,
      sequenceNumber,
      unlockingBytecode: "bytecode" in unlockingBytecode ? unlockingBytecode.bytecode : unlockingBytecode
    };
  });
  const scenario = {
    data: fullCompilationData,
    program: {
      inputIndex: testedInputIndex,
      sourceOutputs,
      transaction: {
        inputs,
        locktime: extendedScenario.transaction.locktime,
        outputs,
        version: extendedScenario.transaction.version
      }
    }
  };
  return debug === true ? { lockingCompilation, scenario, unlockingCompilation } : scenario;
};

// node_modules/@bitauth/libauth/build/lib/compiler/compiler-utils.js
var createCompilerGenerateBytecodeFunction = (compilerConfiguration) => ({ data, debug, scriptId }) => {
  const result = compileScript(scriptId, data, compilerConfiguration);
  return debug === true ? result : result.success ? { bytecode: result.bytecode, success: true } : {
    errorType: result.errorType,
    errors: result.errors,
    success: false
  };
};
var compilerConfigurationToCompilerBCH = (configuration) => {
  const generateBytecode = createCompilerGenerateBytecodeFunction(configuration);
  return {
    configuration,
    generateBytecode,
    generateScenario: ({ lockingScriptId, unlockingScriptId, scenarioId, debug }) => generateScenarioBCH({
      configuration,
      generateBytecode,
      lockingScriptId,
      scenarioId,
      unlockingScriptId
    }, debug)
  };
};
var compilerConfigurationToCompiler = compilerConfigurationToCompilerBCH;
var nullHashLength = 32;
var createAuthenticationProgramEvaluationCommon = (evaluationBytecode) => ({
  inputIndex: 0,
  sourceOutputs: [
    {
      lockingBytecode: evaluationBytecode,
      valueSatoshis: 0n
    }
  ],
  transaction: {
    inputs: [
      {
        outpointIndex: 0,
        outpointTransactionHash: new Uint8Array(nullHashLength),
        sequenceNumber: 0,
        unlockingBytecode: Uint8Array.of()
      }
    ],
    locktime: 0,
    outputs: [
      {
        lockingBytecode: Uint8Array.of(),
        valueSatoshis: 0n
      }
    ],
    version: 0
  }
});
var createCompilerCommon = (scriptsAndOverrides) => compilerConfigurationToCompilerBCH({
  ...{
    createAuthenticationProgram: createAuthenticationProgramEvaluationCommon,
    opcodes: generateBytecodeMap(Opcodes),
    operations: compilerOperationsCommon,
    ripemd160,
    secp256k1,
    sha256,
    sha512
  },
  ...scriptsAndOverrides
});
var compileCashAssembly = (script) => {
  const result = createCompilerCommon({
    opcodes: {},
    operations: {},
    scripts: { script }
  }).generateBytecode({ data: {}, scriptId: "script" });
  if (result.success) {
    return result.bytecode;
  }
  return `CashAssembly compilation error:${result.errors.reduce((all, { error, range: range2 }) => `${all} [${range2.startLineNumber}, ${range2.startColumn}]: ${error}`, "")}`;
};
var assembleBytecode = (opcodes, disassembledBytecode) => {
  const configuration = {
    opcodes,
    scripts: { asm: disassembledBytecode }
  };
  return createCompilerCommon(configuration).generateBytecode({ data: {}, scriptId: "asm" });
};
var assembleBytecodeBCH = (disassembledBytecode) => assembleBytecode(generateBytecodeMap(OpcodesBCH), disassembledBytecode);
var cashAssemblyToBin = (cashAssemblyScript) => {
  const result = assembleBytecodeBCH(cashAssemblyScript);
  return result.success ? result.bytecode : `CashAssembly compilation ${result.errorType} error: ${result.errors.map((err) => err.error).join(" ")}`;
};
var assembleBytecodeBTC = (disassembledBytecode) => assembleBytecode(generateBytecodeMap(OpcodesBTC), disassembledBytecode);
var authenticationTemplateToCompilerConfiguration = (template) => {
  const virtualizedScripts = Object.entries(template.scripts).reduce((all, [scriptId, script]) => {
    if ("tests" in script) {
      return {
        ...all,
        ...Object.entries(script.tests).reduce((tests, [testId, test]) => {
          const pushTestedScript = script.pushed === true;
          const checkScriptId = `${scriptId}.${testId}.check`;
          const virtualizedLockingScriptId = `${scriptId}.${testId}.lock`;
          const virtualizedUnlockingScriptId = `${scriptId}.${testId}.unlock`;
          return {
            ...tests,
            [checkScriptId]: { script: test.check },
            [virtualizedLockingScriptId]: {
              script: pushTestedScript ? `<${scriptId}> ${checkScriptId}` : `${scriptId} ${checkScriptId}`
            },
            [virtualizedUnlockingScriptId]: {
              script: test.setup ?? "",
              unlocks: virtualizedLockingScriptId
            }
          };
        }, {})
      };
    }
    return all;
  }, {});
  const allScripts = {
    ...template.scripts,
    ...virtualizedScripts
  };
  const scripts = Object.entries(allScripts).reduce((all, [id, def]) => ({ ...all, [id]: def.script }), {});
  const variables = Object.values(template.entities).reduce((all, entity) => ({ ...all, ...entity.variables }), {});
  const entityOwnership = Object.entries(template.entities).reduce((all, [entityId, entity]) => ({
    ...all,
    ...Object.keys(entity.variables ?? {}).reduce((entityVariables, variableId) => ({
      ...entityVariables,
      [variableId]: entityId
    }), {})
  }), {});
  const unlockingScripts = Object.entries(allScripts).reduce((all, [id, def]) => "unlocks" in def && def.unlocks !== void 0 ? { ...all, [id]: def.unlocks } : all, {});
  const unlockingScriptTimeLockTypes = Object.entries(allScripts).reduce((all, [id, def]) => "timeLockType" in def && def.timeLockType !== void 0 ? { ...all, [id]: def.timeLockType } : all, {});
  const lockingScriptTypes = Object.entries(allScripts).reduce((all, [id, def]) => "lockingType" in def && def.lockingType !== void 0 ? { ...all, [id]: def.lockingType } : all, {});
  const scenarios = template.scenarios === void 0 ? void 0 : Object.entries(template.scenarios).reduce((all, [id, def]) => ({ ...all, [id]: def }), {});
  return {
    entityOwnership,
    lockingScriptTypes,
    ...scenarios === void 0 ? {} : { scenarios },
    scripts,
    unlockingScriptTimeLockTypes,
    unlockingScripts,
    variables
  };
};

// node_modules/@bitauth/libauth/build/lib/compiler/compiler-bch/compiler-bch.js
var SigningSerializationAlgorithmIdentifier;
(function(SigningSerializationAlgorithmIdentifier2) {
  SigningSerializationAlgorithmIdentifier2["allOutputs"] = "all_outputs";
  SigningSerializationAlgorithmIdentifier2["allOutputsAllUtxos"] = "all_outputs_all_utxos";
  SigningSerializationAlgorithmIdentifier2["allOutputsSingleInput"] = "all_outputs_single_input";
  SigningSerializationAlgorithmIdentifier2["allOutputsSingleInputInvalidAllUtxos"] = "all_outputs_single_input_INVALID_all_utxos";
  SigningSerializationAlgorithmIdentifier2["correspondingOutput"] = "corresponding_output";
  SigningSerializationAlgorithmIdentifier2["correspondingOutputAllUtxos"] = "corresponding_output_all_utxos";
  SigningSerializationAlgorithmIdentifier2["correspondingOutputSingleInput"] = "corresponding_output_single_input";
  SigningSerializationAlgorithmIdentifier2["correspondingOutputSingleInputInvalidAllUtxos"] = "corresponding_output_single_input_INVALID_all_utxos";
  SigningSerializationAlgorithmIdentifier2["default"] = "default";
  SigningSerializationAlgorithmIdentifier2["noOutputs"] = "no_outputs";
  SigningSerializationAlgorithmIdentifier2["noOutputsAllUtxos"] = "no_outputs_all_utxos";
  SigningSerializationAlgorithmIdentifier2["noOutputsSingleInput"] = "no_outputs_single_input";
  SigningSerializationAlgorithmIdentifier2["noOutputsSingleInputInvalidAllUtxos"] = "no_outputs_single_input_INVALID_all_utxos";
})(SigningSerializationAlgorithmIdentifier || (SigningSerializationAlgorithmIdentifier = {}));
var getSigningSerializationType = (algorithmIdentifier, prefix = "") => {
  switch (algorithmIdentifier) {
    case `${prefix}${SigningSerializationAlgorithmIdentifier.allOutputs}`:
      return Uint8Array.of(SigningSerializationTypeBCH.allOutputs);
    case `${prefix}${SigningSerializationAlgorithmIdentifier.allOutputsAllUtxos}`:
    case `${prefix}${SigningSerializationAlgorithmIdentifier.default}`:
      return Uint8Array.of(SigningSerializationTypeBCH.allOutputsAllUtxos);
    case `${prefix}${SigningSerializationAlgorithmIdentifier.allOutputsSingleInput}`:
      return Uint8Array.of(SigningSerializationTypeBCH.allOutputsSingleInput);
    case `${prefix}${SigningSerializationAlgorithmIdentifier.allOutputsSingleInputInvalidAllUtxos}`:
      return Uint8Array.of(
        // eslint-disable-next-line no-bitwise
        SigningSerializationFlag.allOutputs | SigningSerializationFlag.singleInput | SigningSerializationFlag.utxos | SigningSerializationFlag.forkId
      );
    case `${prefix}${SigningSerializationAlgorithmIdentifier.correspondingOutput}`:
      return Uint8Array.of(SigningSerializationTypeBCH.correspondingOutput);
    case `${prefix}${SigningSerializationAlgorithmIdentifier.correspondingOutputAllUtxos}`:
      return Uint8Array.of(SigningSerializationTypeBCH.correspondingOutputAllUtxos);
    case `${prefix}${SigningSerializationAlgorithmIdentifier.correspondingOutputSingleInput}`:
      return Uint8Array.of(SigningSerializationTypeBCH.correspondingOutputSingleInput);
    case `${prefix}${SigningSerializationAlgorithmIdentifier.correspondingOutputSingleInputInvalidAllUtxos}`:
      return Uint8Array.of(
        // eslint-disable-next-line no-bitwise
        SigningSerializationFlag.correspondingOutput | SigningSerializationFlag.singleInput | SigningSerializationFlag.utxos | SigningSerializationFlag.forkId
      );
    case `${prefix}${SigningSerializationAlgorithmIdentifier.noOutputs}`:
      return Uint8Array.of(SigningSerializationTypeBCH.noOutputs);
    case `${prefix}${SigningSerializationAlgorithmIdentifier.noOutputsAllUtxos}`:
      return Uint8Array.of(SigningSerializationTypeBCH.noOutputsAllUtxos);
    case `${prefix}${SigningSerializationAlgorithmIdentifier.noOutputsSingleInput}`:
      return Uint8Array.of(SigningSerializationTypeBCH.noOutputsSingleInput);
    case `${prefix}${SigningSerializationAlgorithmIdentifier.noOutputsSingleInputInvalidAllUtxos}`:
      return Uint8Array.of(
        // eslint-disable-next-line no-bitwise
        SigningSerializationFlag.noOutputs | SigningSerializationFlag.singleInput | SigningSerializationFlag.utxos | SigningSerializationFlag.forkId
      );
    default:
      return void 0;
  }
};
var compilerOperationHelperComputeSignatureBCH = ({ coveredBytecode, identifier, compilationContext, operationName, privateKey, sha256: sha2562, sign }) => {
  const [, , algorithm, unknown] = identifier.split(".");
  if (unknown !== void 0) {
    return {
      error: `Unknown component in "${identifier}" - the fragment "${unknown}" is not recognized.`,
      status: "error"
    };
  }
  if (algorithm === void 0) {
    return {
      error: `Invalid signature identifier. Signatures must be of the form: "[variable_id].${operationName}.[signing_serialization_type]".`,
      status: "error"
    };
  }
  const signingSerializationType = getSigningSerializationType(algorithm);
  if (signingSerializationType === void 0) {
    return {
      error: `Unknown signing serialization algorithm, "${algorithm}".`,
      status: "error"
    };
  }
  const serialization = generateSigningSerializationBCH(compilationContext, { coveredBytecode, signingSerializationType }, sha2562);
  const digest = hash256(serialization, sha2562);
  const bitcoinEncodedSignature = Uint8Array.from([
    ...sign(privateKey, digest),
    ...signingSerializationType
  ]);
  return {
    bytecode: bitcoinEncodedSignature,
    signature: { serialization },
    status: "success"
  };
};
var compilerOperationHelperHdKeySignatureBCH = ({ operationName, secp256k1Method }) => attemptCompilerOperations([compilerOperationAttemptBytecodeResolution], compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: [
    "entityOwnership",
    "ripemd160",
    "secp256k1",
    "sha256",
    "sha512",
    "variables",
    "sourceScriptIds",
    "unlockingScripts"
  ],
  dataProperties: ["hdKeys", "compilationContext"],
  operation: (identifier, data, configuration) => {
    const { hdKeys, compilationContext } = data;
    const { secp256k1: secp256k12, sha256: sha2562, sourceScriptIds, unlockingScripts } = configuration;
    const derivationResult = compilerOperationHelperDeriveHdKeyPrivate({
      configuration,
      hdKeys,
      identifier
    });
    if (derivationResult.status === "error")
      return derivationResult;
    const result = compilerOperationHelperGenerateCoveredBytecode({
      configuration,
      data,
      identifier,
      sourceScriptIds,
      unlockingScripts
    });
    if ("error" in result) {
      return result;
    }
    return compilerOperationHelperComputeSignatureBCH({
      compilationContext,
      coveredBytecode: result,
      identifier,
      operationName,
      privateKey: derivationResult.bytecode,
      sha256: sha2562,
      sign: secp256k12[secp256k1Method]
    });
  }
}));
var compilerOperationHdKeyEcdsaSignatureBCH = compilerOperationHelperHdKeySignatureBCH({
  operationName: "signature",
  secp256k1Method: "signMessageHashDER"
});
var compilerOperationHdKeySchnorrSignatureBCH = compilerOperationHelperHdKeySignatureBCH({
  operationName: "schnorr_signature",
  secp256k1Method: "signMessageHashSchnorr"
});
var compilerOperationHelperKeySignatureBCH = ({ operationName, secp256k1Method }) => attemptCompilerOperations([compilerOperationAttemptBytecodeResolution], compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: [
    "sha256",
    "secp256k1",
    "unlockingScripts",
    "sourceScriptIds"
  ],
  dataProperties: ["keys", "compilationContext"],
  operation: (identifier, data, configuration) => {
    const { keys, compilationContext } = data;
    const { secp256k1: secp256k12, sha256: sha2562, unlockingScripts, sourceScriptIds } = configuration;
    const { privateKeys } = keys;
    const [variableId] = identifier.split(".");
    const privateKey = privateKeys === void 0 ? void 0 : privateKeys[variableId];
    if (privateKey === void 0) {
      return {
        error: `Identifier "${identifier}" refers to a Key, but a private key for "${variableId}" (or an existing signature) was not provided in the compilation data.`,
        recoverable: true,
        status: "error"
      };
    }
    const result = compilerOperationHelperGenerateCoveredBytecode({
      configuration,
      data,
      identifier,
      sourceScriptIds,
      unlockingScripts
    });
    if ("error" in result) {
      return result;
    }
    return compilerOperationHelperComputeSignatureBCH({
      compilationContext,
      coveredBytecode: result,
      identifier,
      operationName,
      privateKey,
      sha256: sha2562,
      sign: secp256k12[secp256k1Method]
    });
  }
}));
var compilerOperationKeyEcdsaSignatureBCH = compilerOperationHelperKeySignatureBCH({
  operationName: "signature",
  secp256k1Method: "signMessageHashDER"
});
var compilerOperationKeySchnorrSignatureBCH = compilerOperationHelperKeySignatureBCH({
  operationName: "schnorr_signature",
  secp256k1Method: "signMessageHashSchnorr"
});
var compilerOperationHelperComputeDataSignatureBCH = ({ data, configuration, identifier, operationName, privateKey, sha256: sha2562, sign }) => {
  const [, , scriptId, unknown] = identifier.split(".");
  if (unknown !== void 0) {
    return {
      error: `Unknown component in "${identifier}" - the fragment "${unknown}" is not recognized.`,
      status: "error"
    };
  }
  if (scriptId === void 0) {
    return {
      error: `Invalid data signature identifier. Data signatures must be of the form: "[variable_id].${operationName}.[target_script_id]".`,
      status: "error"
    };
  }
  const result = compilerOperationHelperCompileScript({
    configuration,
    data,
    targetScriptId: scriptId
  });
  if (result === false) {
    return {
      error: `Data signature tried to sign an unknown target script, "${scriptId}".`,
      status: "error"
    };
  }
  if ("error" in result) {
    return result;
  }
  const digest = sha2562.hash(result);
  return {
    bytecode: sign(privateKey, digest),
    signature: { digest, message: result },
    status: "success"
  };
};
var compilerOperationHelperKeyDataSignatureBCH = ({ operationName, secp256k1Method }) => attemptCompilerOperations([compilerOperationAttemptBytecodeResolution], compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: ["sha256", "secp256k1"],
  dataProperties: ["keys"],
  operation: (identifier, data, configuration) => {
    const { keys } = data;
    const { secp256k1: secp256k12, sha256: sha2562 } = configuration;
    const { privateKeys } = keys;
    const [variableId] = identifier.split(".");
    const privateKey = privateKeys === void 0 ? void 0 : privateKeys[variableId];
    if (privateKey === void 0) {
      return {
        error: `Identifier "${identifier}" refers to a Key, but a private key for "${variableId}" (or an existing signature) was not provided in the compilation data.`,
        recoverable: true,
        status: "error"
      };
    }
    return compilerOperationHelperComputeDataSignatureBCH({
      configuration,
      data,
      identifier,
      operationName,
      privateKey,
      sha256: sha2562,
      sign: secp256k12[secp256k1Method]
    });
  }
}));
var compilerOperationKeyEcdsaDataSignatureBCH = compilerOperationHelperKeyDataSignatureBCH({
  operationName: "data_signature",
  secp256k1Method: "signMessageHashDER"
});
var compilerOperationKeySchnorrDataSignatureBCH = compilerOperationHelperKeyDataSignatureBCH({
  operationName: "schnorr_data_signature",
  secp256k1Method: "signMessageHashSchnorr"
});
var compilerOperationHelperHdKeyDataSignatureBCH = ({ operationName, secp256k1Method }) => attemptCompilerOperations([compilerOperationAttemptBytecodeResolution], compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: [
    "entityOwnership",
    "ripemd160",
    "secp256k1",
    "sha256",
    "sha512",
    "variables"
  ],
  dataProperties: ["hdKeys"],
  operation: (identifier, data, configuration) => {
    const { hdKeys } = data;
    const { secp256k1: secp256k12, sha256: sha2562 } = configuration;
    const derivationResult = compilerOperationHelperDeriveHdKeyPrivate({
      configuration,
      hdKeys,
      identifier
    });
    if (derivationResult.status === "error")
      return derivationResult;
    return compilerOperationHelperComputeDataSignatureBCH({
      configuration,
      data,
      identifier,
      operationName,
      privateKey: derivationResult.bytecode,
      sha256: sha2562,
      sign: secp256k12[secp256k1Method]
    });
  }
}));
var compilerOperationHdKeyEcdsaDataSignatureBCH = compilerOperationHelperHdKeyDataSignatureBCH({
  operationName: "data_signature",
  secp256k1Method: "signMessageHashDER"
});
var compilerOperationHdKeySchnorrDataSignatureBCH = compilerOperationHelperHdKeyDataSignatureBCH({
  operationName: "schnorr_data_signature",
  secp256k1Method: "signMessageHashSchnorr"
});
var compilerOperationSigningSerializationFullBCH = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: ["sha256", "sourceScriptIds", "unlockingScripts"],
  dataProperties: ["compilationContext"],
  operation: (identifier, data, configuration) => {
    const [, algorithmOrComponent, unknownPart] = identifier.split(".");
    if (algorithmOrComponent === void 0) {
      return {
        error: `Invalid signing serialization operation. Include the desired component or algorithm, e.g. "signing_serialization.version".`,
        status: "error"
      };
    }
    if (unknownPart !== void 0) {
      return {
        error: `Unknown component in "${identifier}" - the fragment "${unknownPart}" is not recognized.`,
        status: "error"
      };
    }
    const signingSerializationType = getSigningSerializationType(algorithmOrComponent, "full_");
    if (signingSerializationType === void 0) {
      return {
        error: `Unknown signing serialization algorithm, "${algorithmOrComponent}".`,
        status: "error"
      };
    }
    const { sha256: sha2562, sourceScriptIds, unlockingScripts } = configuration;
    const result = compilerOperationHelperGenerateCoveredBytecode({
      configuration,
      data,
      identifier,
      sourceScriptIds,
      unlockingScripts
    });
    if ("error" in result) {
      return result;
    }
    const { compilationContext } = data;
    return {
      bytecode: generateSigningSerializationBCH(compilationContext, {
        coveredBytecode: result,
        signingSerializationType
      }, sha2562),
      status: "success"
    };
  }
});
var compilerOperationsBCH = {
  ...compilerOperationsCommon,
  hdKey: {
    data_signature: compilerOperationHdKeyEcdsaDataSignatureBCH,
    public_key: compilerOperationsCommon.hdKey.public_key,
    schnorr_data_signature: compilerOperationHdKeySchnorrDataSignatureBCH,
    schnorr_signature: compilerOperationHdKeySchnorrSignatureBCH,
    signature: compilerOperationHdKeyEcdsaSignatureBCH
  },
  key: {
    data_signature: compilerOperationKeyEcdsaDataSignatureBCH,
    public_key: compilerOperationsCommon.key.public_key,
    schnorr_data_signature: compilerOperationKeySchnorrDataSignatureBCH,
    schnorr_signature: compilerOperationKeySchnorrSignatureBCH,
    signature: compilerOperationKeyEcdsaSignatureBCH
  },
  signingSerialization: {
    ...compilerOperationsCommon.signingSerialization,
    full_all_outputs: compilerOperationSigningSerializationFullBCH,
    full_all_outputs_all_utxos: compilerOperationSigningSerializationFullBCH,
    full_all_outputs_single_input: compilerOperationSigningSerializationFullBCH,
    full_all_outputs_single_input_INVALID_all_utxos: compilerOperationSigningSerializationFullBCH,
    full_corresponding_output: compilerOperationSigningSerializationFullBCH,
    full_corresponding_output_all_utxos: compilerOperationSigningSerializationFullBCH,
    full_corresponding_output_single_input: compilerOperationSigningSerializationFullBCH,
    full_corresponding_output_single_input_INVALID_all_utxos: compilerOperationSigningSerializationFullBCH,
    full_default: compilerOperationSigningSerializationFullBCH,
    full_no_outputs: compilerOperationSigningSerializationFullBCH,
    full_no_outputs_all_utxos: compilerOperationSigningSerializationFullBCH,
    full_no_outputs_single_input: compilerOperationSigningSerializationFullBCH,
    full_no_outputs_single_input_INVALID_all_utxos: compilerOperationSigningSerializationFullBCH
  }
};
var createCompilerBCH = (configuration) => compilerConfigurationToCompilerBCH({
  ...{
    createAuthenticationProgram: createAuthenticationProgramEvaluationCommon,
    opcodes: generateBytecodeMap(OpcodesBCHCHIPs),
    operations: compilerOperationsBCH,
    ripemd160,
    secp256k1,
    sha256,
    sha512,
    vm: configuration.vm === void 0 ? createVirtualMachineBCH() : configuration.vm
  },
  ...configuration
});
var createCompiler = createCompilerBCH;
var authenticationTemplateToCompilerBCH = (template, overrides) => createCompilerBCH({
  ...overrides,
  ...authenticationTemplateToCompilerConfiguration(template)
});

// node_modules/@bitauth/libauth/build/lib/compiler/compiler-types.js
var import_dist370 = __toESM(require_dist(), 1);
var import_dist371 = __toESM(require_dist2(), 1);
var import_dist372 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/compiler/p2pkh-utils.js
var import_dist379 = __toESM(require_dist(), 1);
var import_dist380 = __toESM(require_dist2(), 1);
var import_dist381 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/compiler/standard/standard.js
var import_dist376 = __toESM(require_dist(), 1);
var import_dist377 = __toESM(require_dist2(), 1);
var import_dist378 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/compiler/standard/p2pkh.js
var import_dist373 = __toESM(require_dist(), 1);
var import_dist374 = __toESM(require_dist2(), 1);
var import_dist375 = __toESM(require_dist3(), 1);
var authenticationTemplateP2pkhNonHd = {
  $schema: "https://bitauth.com/schemas/authentication-template-v0.schema.json",
  description: "A standard single-factor authentication template that uses Pay-to-Public-Key-Hash (P2PKH), the most common authentication scheme in use on the network.\n\nThis P2PKH template uses BCH Schnorr signatures, reducing the size of transactions.",
  entities: {
    owner: {
      description: "The individual who can spend from this wallet.",
      name: "Owner",
      scripts: ["lock", "unlock"],
      variables: {
        key: {
          description: "The private key that controls this wallet.",
          name: "Key",
          type: "Key"
        }
      }
    }
  },
  name: "Single Signature (P2PKH)",
  scripts: {
    lock: {
      lockingType: "standard",
      name: "P2PKH Lock",
      script: "OP_DUP\nOP_HASH160 <$(<key.public_key> OP_HASH160\n)> OP_EQUALVERIFY\nOP_CHECKSIG"
    },
    unlock: {
      name: "Unlock",
      script: "<key.schnorr_signature.all_outputs>\n<key.public_key>",
      unlocks: "lock"
    }
  },
  supported: ["BCH_2020_05", "BCH_2021_05", "BCH_2022_05"],
  version: 0
};
var authenticationTemplateP2pkh = {
  $schema: "https://bitauth.com/schemas/authentication-template-v0.schema.json",
  description: "A standard single-factor authentication template that uses Pay-to-Public-Key-Hash (P2PKH), the most common authentication scheme in use on the network.\n\nThis P2PKH template uses BCH Schnorr signatures, reducing the size of transactions. Because the template uses a Hierarchical Deterministic (HD) key, it also supports watch-only clients.",
  entities: {
    owner: {
      description: "The individual who can spend from this wallet.",
      name: "Owner",
      scripts: ["lock", "unlock"],
      variables: {
        key: {
          description: "The private key that controls this wallet.",
          name: "Key",
          type: "HdKey"
        }
      }
    }
  },
  name: "Single Signature (P2PKH)",
  scripts: {
    lock: {
      lockingType: "standard",
      name: "P2PKH Lock",
      script: "OP_DUP\nOP_HASH160 <$(<key.public_key> OP_HASH160\n)> OP_EQUALVERIFY\nOP_CHECKSIG"
    },
    unlock: {
      name: "Unlock",
      script: "<key.schnorr_signature.all_outputs>\n<key.public_key>",
      unlocks: "lock"
    }
  },
  supported: ["BCH_2020_05", "BCH_2021_05", "BCH_2022_05"],
  version: 0
};

// node_modules/@bitauth/libauth/build/lib/compiler/p2pkh-utils.js
var hdPrivateKeyToP2pkhLockingBytecode = ({ addressIndex, hdKey }) => {
  const compiler = authenticationTemplateToCompilerBCH(importAuthenticationTemplate(authenticationTemplateP2pkh));
  const lockingBytecode = compiler.generateBytecode({
    data: { hdKeys: { addressIndex, hdPrivateKeys: { owner: hdKey } } },
    scriptId: "lock"
  });
  return lockingBytecode.bytecode;
};
var hdPrivateKeyToP2pkhAddress = ({ addressIndex, hdKey, prefix = "bitcoincash" }) => lockingBytecodeToCashAddress(hdPrivateKeyToP2pkhLockingBytecode({ addressIndex, hdKey }), prefix);

// node_modules/@bitauth/libauth/build/lib/compiler/template-types.js
var import_dist382 = __toESM(require_dist(), 1);
var import_dist383 = __toESM(require_dist2(), 1);
var import_dist384 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/transaction/transaction.js
var import_dist391 = __toESM(require_dist(), 1);
var import_dist392 = __toESM(require_dist2(), 1);
var import_dist393 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/transaction/generate-transaction.js
var import_dist388 = __toESM(require_dist(), 1);
var import_dist389 = __toESM(require_dist2(), 1);
var import_dist390 = __toESM(require_dist3(), 1);
var returnFailedCompilationDirective = ({ index: index2, result, type }) => ({
  errors: result.errors.map((error) => ({
    ...error,
    error: `Failed compilation of ${type} directive at index "${index2}": ${error.error}`
  })),
  index: index2,
  ...result.errorType === "parse" ? {} : { resolved: result.resolve },
  type
});
var compileOutputTemplate = ({ outputTemplate, index: index2 }) => {
  if ("script" in outputTemplate.lockingBytecode) {
    const directive = outputTemplate.lockingBytecode;
    const data = directive.data === void 0 ? {} : directive.data;
    const result = directive.compiler.generateBytecode({
      data,
      debug: true,
      scriptId: directive.script
    });
    return result.success ? {
      lockingBytecode: result.bytecode,
      ...outputTemplate.token === void 0 ? {} : { token: outputTemplate.token },
      valueSatoshis: outputTemplate.valueSatoshis
    } : returnFailedCompilationDirective({ index: index2, result, type: "locking" });
  }
  return {
    lockingBytecode: outputTemplate.lockingBytecode.slice(),
    ...outputTemplate.token === void 0 ? {} : { token: outputTemplate.token },
    valueSatoshis: outputTemplate.valueSatoshis
  };
};
var compileInputTemplate = ({ inputTemplate, index: index2, template, outputs }) => {
  if ("script" in inputTemplate.unlockingBytecode) {
    const directive = inputTemplate.unlockingBytecode;
    const sourceOutputs = [];
    sourceOutputs[index2] = {
      lockingBytecode: Uint8Array.of(),
      ...inputTemplate.unlockingBytecode.token === void 0 ? {} : { token: inputTemplate.unlockingBytecode.token },
      valueSatoshis: inputTemplate.unlockingBytecode.valueSatoshis
    };
    const result = directive.compiler.generateBytecode({
      data: {
        ...directive.data,
        compilationContext: {
          inputIndex: index2,
          sourceOutputs,
          transaction: {
            inputs: template.inputs,
            locktime: template.locktime,
            outputs,
            version: template.version
          }
        }
      },
      debug: true,
      scriptId: directive.script
    });
    return result.success ? {
      outpointIndex: inputTemplate.outpointIndex,
      outpointTransactionHash: inputTemplate.outpointTransactionHash.slice(),
      sequenceNumber: inputTemplate.sequenceNumber,
      unlockingBytecode: result.bytecode
    } : returnFailedCompilationDirective({ index: index2, result, type: "unlocking" });
  }
  return {
    outpointIndex: inputTemplate.outpointIndex,
    outpointTransactionHash: inputTemplate.outpointTransactionHash.slice(),
    sequenceNumber: inputTemplate.sequenceNumber,
    unlockingBytecode: inputTemplate.unlockingBytecode.slice()
  };
};
var generateTransaction = (template) => {
  const outputResults = template.outputs.map((outputTemplate, index2) => compileOutputTemplate({
    index: index2,
    outputTemplate
  }));
  const outputCompilationErrors = outputResults.filter((result) => "errors" in result);
  if (outputCompilationErrors.length > 0) {
    const outputCompletions = outputResults.map((result, index2) => "lockingBytecode" in result ? { index: index2, output: result, type: "output" } : result).filter((result) => "output" in result);
    return {
      completions: outputCompletions,
      errors: outputCompilationErrors,
      stage: "outputs",
      success: false
    };
  }
  const outputs = outputResults;
  const inputResults = template.inputs.map((inputTemplate, index2) => compileInputTemplate({
    index: index2,
    inputTemplate,
    outputs,
    template
  }));
  const inputCompilationErrors = inputResults.filter((result) => "errors" in result);
  if (inputCompilationErrors.length > 0) {
    const inputCompletions = inputResults.map((result, index2) => "unlockingBytecode" in result ? { index: index2, input: result, type: "input" } : result).filter((result) => "input" in result);
    return {
      completions: inputCompletions,
      errors: inputCompilationErrors,
      stage: "inputs",
      success: false
    };
  }
  const inputs = inputResults;
  return {
    success: true,
    transaction: {
      inputs,
      locktime: template.locktime,
      outputs,
      version: template.version
    }
  };
};
var extractResolvedVariables = (transactionGenerationError) => transactionGenerationError.errors.reduce((all, error) => error.resolved === void 0 ? all : { ...all, ...extractResolvedVariableBytecodeMap(error.resolved) }, {});
var extractMissingVariables = (transactionGenerationError) => {
  const allErrors = transactionGenerationError.errors.reduce((all, error) => [...all, ...error.errors], []);
  if (!allErrorsAreRecoverable(allErrors)) {
    return false;
  }
  return allErrors.reduce((all, error) => ({
    ...all,
    [error.missingIdentifier]: error.owningEntity
  }), {});
};
var safelyExtendCompilationData = (transactionGenerationError, trustedCompilationData, untrustedResolutions) => {
  const missing = extractMissingVariables(transactionGenerationError);
  if (missing === false)
    return false;
  const selectedResolutions = Object.entries(missing).reduce((all, [identifier, entityId]) => {
    const entityResolution = untrustedResolutions[entityId];
    if (entityResolution === void 0) {
      return all;
    }
    const resolution = entityResolution[identifier];
    if (resolution === void 0) {
      return all;
    }
    return { ...all, [identifier]: resolution };
  }, {});
  return {
    ...trustedCompilationData,
    bytecode: {
      ...selectedResolutions,
      ...trustedCompilationData.bytecode
    }
  };
};

// node_modules/@bitauth/libauth/build/lib/vmb-tests/vmb-tests.js
var import_dist400 = __toESM(require_dist(), 1);
var import_dist401 = __toESM(require_dist2(), 1);
var import_dist402 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/vmb-tests/bch-vmb-test-utils.js
var import_dist397 = __toESM(require_dist(), 1);
var import_dist398 = __toESM(require_dist2(), 1);
var import_dist399 = __toESM(require_dist3(), 1);

// node_modules/@bitauth/libauth/build/lib/vmb-tests/bch-vmb-test-mixins.js
var import_dist394 = __toESM(require_dist(), 1);
var import_dist395 = __toESM(require_dist2(), 1);
var import_dist396 = __toESM(require_dist3(), 1);
var simpleP2pkhOutput = {
  lockingBytecode: { script: "lockP2pkh" },
  valueSatoshis: 1e4
};
var simpleP2pkhInput = {
  unlockingBytecode: { script: "unlockP2pkh" }
};
var vmbTestOutput = {
  lockingBytecode: { script: "vmbTestNullData" },
  valueSatoshis: 0
};
var slotOutput = {
  lockingBytecode: ["slot"],
  valueSatoshis: 1e4
};
var slotInput = {
  unlockingBytecode: ["slot"]
};
var slot1Scenario = {
  sourceOutputs: [simpleP2pkhOutput, slotOutput],
  transaction: {
    inputs: [simpleP2pkhInput, slotInput],
    outputs: [vmbTestOutput]
  }
};

// node_modules/@bitauth/libauth/build/lib/vmb-tests/bch-vmb-test-utils.js
var vmbTestDefinitionDefaultBehaviorBCH = [
  "nop2sh_nonstandard",
  "p2sh20_standard",
  "p2sh32_ignore"
];
var testSetOverrideListBCH = [
  ["chip_cashtokens_invalid"],
  ["chip_cashtokens_invalid", "2022_p2sh32_nonstandard"],
  ["default", "chip_cashtokens"],
  ["chip_cashtokens"],
  ["chip_cashtokens", "2022_p2sh32_nonstandard"],
  ["chip_loops_invalid"],
  ["chip_loops"],
  ["invalid", "2022_p2sh32_nonstandard", "chip_cashtokens"],
  ["invalid", "2022_p2sh32_nonstandard", "chip_cashtokens_invalid"],
  ["invalid", "2022_p2sh32_nonstandard", "chip_cashtokens_nonstandard"],
  ["invalid", "chip_cashtokens_invalid"],
  ["invalid", "chip_cashtokens", "nop2sh_invalid"],
  ["invalid", "chip_cashtokens"],
  [
    "invalid",
    "chip_cashtokens",
    "chip_cashtokens_p2sh20_nonstandard",
    "chip_cashtokens_p2sh32_nonstandard"
  ],
  ["invalid", "chip_cashtokens", "chip_cashtokens_p2sh32_nonstandard"],
  ["invalid", "chip_cashtokens", "p2sh_ignore"],
  ["invalid", "chip_cashtokens_invalid", "p2sh_ignore"],
  ["invalid", "nop2sh_nonstandard"],
  ["invalid", "nop2sh_nonstandard"],
  ["invalid", "p2sh_ignore"],
  ["invalid", "p2sh_nonstandard", "chip_cashtokens_invalid"],
  ["invalid", "p2sh_nonstandard", "chip_cashtokens"],
  ["invalid", "p2sh_standard"],
  ["invalid", "p2sh20_standard"],
  ["invalid"],
  ["nop2sh_invalid"],
  ["nonstandard", "chip_cashtokens_invalid"],
  ["nonstandard", "chip_cashtokens"],
  [
    "nonstandard",
    "chip_cashtokens",
    "chip_cashtokens_p2sh20_nonstandard",
    "chip_cashtokens_p2sh32_nonstandard"
  ],
  ["nonstandard", "chip_cashtokens", "chip_cashtokens_p2sh32_nonstandard"],
  ["nonstandard", "p2sh_ignore"],
  ["nonstandard", "p2sh_invalid"],
  ["nonstandard"],
  ["p2sh_ignore"],
  ["p2sh_invalid"],
  []
];
var testList = (_list) => 0;
testList(testSetOverrideListBCH);
var supportedTestSetOverridesBCH = {
  /* eslint-disable camelcase */
  "": [
    { mode: "nonP2SH", sets: ["2022_nonstandard"] },
    { mode: "P2SH20", sets: ["2022_standard"] }
  ],
  /**
   * `chip_*` values exclude the marked test from
   * {@link vmbTestDefinitionDefaultBehaviorBCH}.
   */
  chip_cashtokens: [
    {
      mode: "nonP2SH",
      sets: ["before_chip_cashtokens_invalid", "chip_cashtokens_nonstandard"]
    },
    {
      mode: "P2SH20",
      sets: ["before_chip_cashtokens_invalid", "chip_cashtokens_standard"]
    },
    {
      mode: "P2SH32",
      sets: ["before_chip_cashtokens_invalid", "chip_cashtokens_standard"]
    }
  ],
  "chip_cashtokens,2022_p2sh32_nonstandard": [
    {
      mode: "nonP2SH",
      sets: ["before_chip_cashtokens_invalid", "chip_cashtokens_nonstandard"]
    },
    {
      mode: "P2SH20",
      sets: ["before_chip_cashtokens_invalid", "chip_cashtokens_standard"]
    },
    {
      mode: "P2SH32",
      sets: ["before_chip_cashtokens_nonstandard", "chip_cashtokens_standard"]
    }
  ],
  chip_cashtokens_invalid: [
    {
      mode: "nonP2SH",
      sets: ["before_chip_cashtokens_invalid", "chip_cashtokens_invalid"]
    },
    {
      mode: "P2SH20",
      sets: ["before_chip_cashtokens_invalid", "chip_cashtokens_invalid"]
    },
    {
      mode: "P2SH32",
      sets: ["before_chip_cashtokens_invalid", "chip_cashtokens_invalid"]
    }
  ],
  "chip_cashtokens_invalid,2022_p2sh32_nonstandard": [
    {
      mode: "nonP2SH",
      sets: ["before_chip_cashtokens_invalid", "chip_cashtokens_invalid"]
    },
    {
      mode: "P2SH20",
      sets: ["before_chip_cashtokens_invalid", "chip_cashtokens_invalid"]
    },
    {
      mode: "P2SH32",
      sets: ["before_chip_cashtokens_nonstandard", "chip_cashtokens_invalid"]
    }
  ],
  chip_loops: [
    { mode: "nonP2SH", sets: ["chip_loops_nonstandard"] },
    { mode: "P2SH20", sets: ["chip_loops_standard"] }
  ],
  chip_loops_invalid: [
    { mode: "nonP2SH", sets: ["chip_loops_invalid"] },
    { mode: "P2SH20", sets: ["chip_loops_invalid"] }
  ],
  "default,chip_cashtokens": [
    {
      mode: "nonP2SH",
      sets: [
        "2022_nonstandard",
        "before_chip_cashtokens_nonstandard",
        "chip_cashtokens_nonstandard"
      ]
    },
    {
      mode: "P2SH20",
      sets: [
        "2022_standard",
        "before_chip_cashtokens_standard",
        "chip_cashtokens_standard"
      ]
    },
    {
      mode: "P2SH32",
      sets: ["chip_cashtokens_standard"]
    }
  ],
  invalid: [
    { mode: "nonP2SH", sets: ["2022_invalid"] },
    { mode: "P2SH20", sets: ["2022_invalid"] }
  ],
  "invalid,2022_p2sh32_nonstandard,chip_cashtokens": [
    {
      mode: "nonP2SH",
      sets: [
        "2022_invalid",
        "before_chip_cashtokens_invalid",
        "chip_cashtokens_nonstandard"
      ]
    },
    {
      mode: "P2SH20",
      sets: [
        "2022_invalid",
        "before_chip_cashtokens_invalid",
        "chip_cashtokens_standard"
      ]
    },
    {
      mode: "P2SH32",
      sets: [
        "2022_nonstandard",
        "before_chip_cashtokens_nonstandard",
        "chip_cashtokens_standard"
      ]
    }
  ],
  "invalid,2022_p2sh32_nonstandard,chip_cashtokens_invalid": [
    {
      mode: "nonP2SH",
      sets: [
        "2022_invalid",
        "before_chip_cashtokens_invalid",
        "chip_cashtokens_invalid"
      ]
    },
    {
      mode: "P2SH20",
      sets: [
        "2022_invalid",
        "before_chip_cashtokens_invalid",
        "chip_cashtokens_invalid"
      ]
    },
    {
      mode: "P2SH32",
      sets: [
        "2022_nonstandard",
        "before_chip_cashtokens_nonstandard",
        "chip_cashtokens_invalid"
      ]
    }
  ],
  "invalid,2022_p2sh32_nonstandard,chip_cashtokens_nonstandard": [
    {
      mode: "nonP2SH",
      sets: [
        "2022_invalid",
        "before_chip_cashtokens_invalid",
        "chip_cashtokens_nonstandard"
      ]
    },
    {
      mode: "P2SH20",
      sets: [
        "2022_invalid",
        "before_chip_cashtokens_invalid",
        "chip_cashtokens_nonstandard"
      ]
    },
    {
      mode: "P2SH32",
      sets: [
        "2022_nonstandard",
        "before_chip_cashtokens_nonstandard",
        "chip_cashtokens_nonstandard"
      ]
    }
  ],
  "invalid,chip_cashtokens": [
    {
      mode: "nonP2SH",
      sets: [
        "2022_invalid",
        "before_chip_cashtokens_invalid",
        "chip_cashtokens_nonstandard"
      ]
    },
    {
      mode: "P2SH20",
      sets: [
        "2022_invalid",
        "before_chip_cashtokens_invalid",
        "chip_cashtokens_standard"
      ]
    },
    {
      mode: "P2SH32",
      sets: [
        "2022_invalid",
        "before_chip_cashtokens_invalid",
        "chip_cashtokens_standard"
      ]
    }
  ],
  "invalid,chip_cashtokens,chip_cashtokens_p2sh20_nonstandard,chip_cashtokens_p2sh32_nonstandard": [
    {
      mode: "nonP2SH",
      sets: [
        "2022_invalid",
        "before_chip_cashtokens_invalid",
        "chip_cashtokens_nonstandard"
      ]
    },
    {
      mode: "P2SH20",
      sets: [
        "2022_invalid",
        "before_chip_cashtokens_invalid",
        "chip_cashtokens_nonstandard"
      ]
    },
    {
      mode: "P2SH32",
      sets: [
        "2022_invalid",
        "before_chip_cashtokens_invalid",
        "chip_cashtokens_nonstandard"
      ]
    }
  ],
  "invalid,chip_cashtokens,chip_cashtokens_p2sh32_nonstandard": [
    {
      mode: "nonP2SH",
      sets: [
        "2022_invalid",
        "before_chip_cashtokens_invalid",
        "chip_cashtokens_nonstandard"
      ]
    },
    {
      mode: "P2SH20",
      sets: [
        "2022_invalid",
        "before_chip_cashtokens_invalid",
        "chip_cashtokens_standard"
      ]
    },
    {
      mode: "P2SH32",
      sets: [
        "2022_invalid",
        "before_chip_cashtokens_invalid",
        "chip_cashtokens_nonstandard"
      ]
    }
  ],
  "invalid,chip_cashtokens,nop2sh_invalid": [
    {
      mode: "nonP2SH",
      sets: [
        "2022_invalid",
        "before_chip_cashtokens_invalid",
        "chip_cashtokens_invalid"
      ]
    },
    {
      mode: "P2SH20",
      sets: [
        "2022_invalid",
        "before_chip_cashtokens_invalid",
        "chip_cashtokens_standard"
      ]
    },
    {
      mode: "P2SH32",
      sets: [
        "2022_invalid",
        "before_chip_cashtokens_invalid",
        "chip_cashtokens_standard"
      ]
    }
  ],
  "invalid,chip_cashtokens,p2sh_ignore": [
    {
      mode: "nonP2SH",
      sets: [
        "2022_invalid",
        "before_chip_cashtokens_invalid",
        "chip_cashtokens_nonstandard"
      ]
    }
  ],
  "invalid,chip_cashtokens_invalid": [
    {
      mode: "nonP2SH",
      sets: [
        "2022_invalid",
        "before_chip_cashtokens_invalid",
        "chip_cashtokens_invalid"
      ]
    },
    {
      mode: "P2SH20",
      sets: [
        "2022_invalid",
        "before_chip_cashtokens_invalid",
        "chip_cashtokens_invalid"
      ]
    },
    {
      mode: "P2SH32",
      sets: [
        "2022_invalid",
        "before_chip_cashtokens_invalid",
        "chip_cashtokens_invalid"
      ]
    }
  ],
  "invalid,chip_cashtokens_invalid,p2sh_ignore": [
    {
      mode: "nonP2SH",
      sets: [
        "2022_invalid",
        "before_chip_cashtokens_invalid",
        "chip_cashtokens_invalid"
      ]
    }
  ],
  "invalid,nop2sh_nonstandard": [
    { mode: "nonP2SH", sets: ["2022_nonstandard"] },
    { mode: "P2SH20", sets: ["2022_invalid"] }
  ],
  "invalid,p2sh20_standard": [
    { mode: "nonP2SH", sets: ["2022_invalid"] },
    { mode: "P2SH20", sets: ["2022_standard"] }
  ],
  "invalid,p2sh_ignore": [{ mode: "nonP2SH", sets: ["2022_invalid"] }],
  "invalid,p2sh_nonstandard,chip_cashtokens": [
    {
      mode: "nonP2SH",
      sets: [
        "2022_invalid",
        "before_chip_cashtokens_invalid",
        "chip_cashtokens_nonstandard"
      ]
    },
    {
      mode: "P2SH20",
      sets: [
        "2022_nonstandard",
        "before_chip_cashtokens_nonstandard",
        "chip_cashtokens_standard"
      ]
    },
    {
      mode: "P2SH32",
      sets: [
        "2022_nonstandard",
        "before_chip_cashtokens_nonstandard",
        "chip_cashtokens_standard"
      ]
    }
  ],
  "invalid,p2sh_nonstandard,chip_cashtokens_invalid": [
    {
      mode: "nonP2SH",
      sets: [
        "2022_invalid",
        "before_chip_cashtokens_invalid",
        "chip_cashtokens_invalid"
      ]
    },
    {
      mode: "P2SH20",
      sets: [
        "2022_nonstandard",
        "before_chip_cashtokens_nonstandard",
        "chip_cashtokens_invalid"
      ]
    },
    {
      mode: "P2SH32",
      sets: [
        "2022_nonstandard",
        "before_chip_cashtokens_nonstandard",
        "chip_cashtokens_invalid"
      ]
    }
  ],
  "invalid,p2sh_standard": [
    { mode: "nonP2SH", sets: ["2022_invalid"] },
    { mode: "P2SH20", sets: ["2022_standard"] }
  ],
  nonstandard: [
    { mode: "nonP2SH", sets: ["2022_nonstandard"] },
    { mode: "P2SH20", sets: ["2022_nonstandard"] }
  ],
  "nonstandard,chip_cashtokens": [
    {
      mode: "nonP2SH",
      sets: [
        "2022_nonstandard",
        "before_chip_cashtokens_nonstandard",
        "chip_cashtokens_nonstandard"
      ]
    },
    {
      mode: "P2SH20",
      sets: [
        "2022_nonstandard",
        "before_chip_cashtokens_nonstandard",
        "chip_cashtokens_standard"
      ]
    },
    {
      mode: "P2SH32",
      sets: [
        "2022_nonstandard",
        "before_chip_cashtokens_nonstandard",
        "chip_cashtokens_standard"
      ]
    }
  ],
  "nonstandard,chip_cashtokens,chip_cashtokens_p2sh20_nonstandard,chip_cashtokens_p2sh32_nonstandard": [
    {
      mode: "nonP2SH",
      sets: [
        "2022_nonstandard",
        "before_chip_cashtokens_nonstandard",
        "chip_cashtokens_nonstandard"
      ]
    },
    {
      mode: "P2SH20",
      sets: [
        "2022_nonstandard",
        "before_chip_cashtokens_nonstandard",
        "chip_cashtokens_nonstandard"
      ]
    },
    {
      mode: "P2SH32",
      sets: [
        "2022_nonstandard",
        "before_chip_cashtokens_nonstandard",
        "chip_cashtokens_nonstandard"
      ]
    }
  ],
  "nonstandard,chip_cashtokens,chip_cashtokens_p2sh32_nonstandard": [
    {
      mode: "nonP2SH",
      sets: [
        "2022_nonstandard",
        "before_chip_cashtokens_nonstandard",
        "chip_cashtokens_nonstandard"
      ]
    },
    {
      mode: "P2SH20",
      sets: [
        "2022_nonstandard",
        "before_chip_cashtokens_nonstandard",
        "chip_cashtokens_standard"
      ]
    },
    {
      mode: "P2SH32",
      sets: [
        "2022_nonstandard",
        "before_chip_cashtokens_nonstandard",
        "chip_cashtokens_nonstandard"
      ]
    }
  ],
  "nonstandard,chip_cashtokens_invalid": [
    {
      mode: "nonP2SH",
      sets: [
        "2022_nonstandard",
        "before_chip_cashtokens_nonstandard",
        "chip_cashtokens_invalid"
      ]
    },
    {
      mode: "P2SH20",
      sets: [
        "2022_nonstandard",
        "before_chip_cashtokens_nonstandard",
        "chip_cashtokens_invalid"
      ]
    },
    {
      mode: "P2SH32",
      sets: [
        "2022_nonstandard",
        "before_chip_cashtokens_nonstandard",
        "chip_cashtokens_invalid"
      ]
    }
  ],
  "nonstandard,p2sh_ignore": [{ mode: "nonP2SH", sets: ["2022_nonstandard"] }],
  "nonstandard,p2sh_invalid": [
    { mode: "nonP2SH", sets: ["2022_nonstandard"] },
    { mode: "P2SH20", sets: ["2022_invalid"] }
  ],
  nop2sh_invalid: [
    { mode: "nonP2SH", sets: ["2022_invalid"] },
    { mode: "P2SH20", sets: ["2022_standard"] }
  ],
  p2sh_ignore: [{ mode: "nonP2SH", sets: ["2022_nonstandard"] }],
  p2sh_invalid: [
    { mode: "nonP2SH", sets: ["2022_nonstandard"] },
    { mode: "P2SH20", sets: ["2022_invalid"] }
  ]
  /* eslint-enable camelcase */
};
var defaultShortIdLength = 5;
var planTestsBCH = (labels) => supportedTestSetOverridesBCH[(labels ?? []).join(",")];
var vmbTestDefinitionToVmbTests = (testDefinition, groupName = "", shortIdLength = defaultShortIdLength) => {
  const [unlockingScript, redeemOrLockingScript, testDescription, testSetOverrideLabels, scenarioOverride, additionalScripts] = testDefinition;
  const scenarioId = "test";
  const testGenerationPlan = planTestsBCH(testSetOverrideLabels);
  const scenarioDefinition = { extends: "vmb_default", ...scenarioOverride };
  const configuration = authenticationTemplateToCompilerConfiguration({
    entities: { tester: { variables: { key1: { type: "HdKey" } } } },
    scenarios: {
      [scenarioId]: scenarioDefinition,
      // eslint-disable-next-line @typescript-eslint/naming-convention, camelcase
      vmb_default: slot1Scenario
    },
    scripts: {
      ...additionalScripts,
      lockEmptyP2sh20: { lockingType: "p2sh20", script: "" },
      lockP2pkh: {
        lockingType: "standard",
        script: "OP_DUP OP_HASH160 <$(<key1.public_key> OP_HASH160)> OP_EQUALVERIFY OP_CHECKSIG"
      },
      lockP2sh20: { lockingType: "p2sh20", script: redeemOrLockingScript },
      lockP2sh32: { lockingType: "p2sh32", script: redeemOrLockingScript },
      lockStandard: { lockingType: "standard", script: redeemOrLockingScript },
      unlockEmptyP2sh20: { script: "<1>", unlocks: "lockEmptyP2sh20" },
      unlockP2pkh: {
        /**
         * Uses `corresponding_output_single_input` to reuse the same signature
         * as much as possible (making VMB test files more compressible).
         */
        script: "<key1.schnorr_signature.corresponding_output_single_input> <key1.public_key>",
        unlocks: "lockP2pkh"
      },
      unlockP2sh20: { script: unlockingScript, unlocks: "lockP2sh20" },
      unlockP2sh32: { script: unlockingScript, unlocks: "lockP2sh32" },
      unlockStandard: { script: unlockingScript, unlocks: "lockStandard" },
      vmbTestNullData: {
        lockingType: "standard",
        script: 'OP_RETURN <"vmb_test">'
      }
    },
    supported: ["BCH_2022_05"],
    version: 0
  });
  const compiler = createCompilerBCH(configuration);
  const tests = testGenerationPlan.map((planItem) => {
    const description = `${groupName}: ${testDescription} (${planItem.mode})`;
    const result = compiler.generateScenario({
      debug: true,
      scenarioId,
      unlockingScriptId: {
        // eslint-disable-next-line @typescript-eslint/naming-convention
        P2SH20: "unlockP2sh20",
        // eslint-disable-next-line @typescript-eslint/naming-convention
        P2SH32: "unlockP2sh32",
        nonP2SH: "unlockStandard"
      }[planItem.mode]
    });
    if (typeof result === "string") {
      throw new Error(`Error while generating "${description}" - ${result}`);
    }
    if (typeof result.scenario === "string") {
      throw new Error(`Error while generating "${description}" - ${result.scenario}`);
    }
    const encodedTx = encodeTransaction(result.scenario.program.transaction);
    const encodedSourceOutputs = encodeTransactionOutputs(result.scenario.program.sourceOutputs);
    const shortId = encodeBech32(regroupBits({
      bin: sha256.hash(flattenBinArray([encodedTx, encodedSourceOutputs])),
      resultWordLength: 5,
      sourceWordLength: 8
    })).slice(0, shortIdLength);
    const testCase = [
      shortId,
      description,
      unlockingScript,
      redeemOrLockingScript,
      binToHex(encodedTx),
      binToHex(encodedSourceOutputs),
      planItem.sets
    ];
    return result.scenario.program.inputIndex === 0 ? testCase : [...testCase, result.scenario.program.inputIndex];
  });
  return tests;
};
var vmbTestGroupToVmbTests = (testGroup) => testGroup[1].map((testDefinition) => vmbTestDefinitionToVmbTests(testDefinition, testGroup[0]));
var vmbTestPartitionMasterTestList = (masterTestList) => masterTestList.reduce((accumulatedTestSets, testCase) => {
  const [shortId, testDescription, unlockingScriptAsm, redeemOrLockingScriptAsm, testTransactionHex, sourceOutputsHex, testSets, inputIndex] = testCase;
  const withoutSets = [
    shortId,
    testDescription,
    unlockingScriptAsm,
    redeemOrLockingScriptAsm,
    testTransactionHex,
    sourceOutputsHex,
    ...inputIndex === void 0 ? [] : [inputIndex]
  ];
  testSets.forEach((testSet) => {
    accumulatedTestSets[testSet] = [
      ...accumulatedTestSets[testSet] ?? [],
      withoutSets
    ];
  });
  return accumulatedTestSets;
}, {});
export {
  AuthenticationErrorBCH,
  AuthenticationErrorBCH2022,
  AuthenticationErrorBCH2023,
  AuthenticationErrorBCHCHIPs,
  AuthenticationErrorCommon,
  Base58AddressError,
  Base58AddressFormatVersion,
  BaseConversionError,
  Bech32DecodingError,
  BitRegroupingError,
  BuiltInVariables,
  CashAddressCorrectionError,
  CashAddressDecodingError,
  CashAddressEncodingError,
  CashAddressNetworkPrefix,
  CashAddressType,
  CashAddressTypeBits,
  CashAddressVersionByte,
  CashAddressVersionByteDecodingError,
  CashTokenDecodingError,
  CompactSizeError,
  CompactSizePrefixedBinError,
  CompilerDefaults,
  CompressionFlag,
  ConsensusBCH,
  ConsensusBCH2023,
  ConsensusBCHCHIPs,
  ConsensusCommon,
  ConsensusXEC,
  ContextFlag,
  HdKeyDecodingError,
  HdKeyVersion,
  HdNodeCrackingError,
  HdNodeDerivationError,
  IdentifierResolutionErrorType,
  IdentifierResolutionType,
  LockingBytecodeGenerationError,
  LockingBytecodeType,
  LocktimeError,
  NonFungibleTokenCapability,
  OpcodeDescriptions,
  OpcodeDescriptionsBCH,
  OpcodeDescriptionsBCH2022,
  OpcodeDescriptionsBCH2023,
  OpcodeDescriptionsBCHCHIPs,
  OpcodeDescriptionsBTC,
  OpcodeDescriptionsXEC,
  Opcodes,
  OpcodesBCH,
  OpcodesBCH2022,
  OpcodesBCH2023,
  OpcodesBCHCHIPs,
  OpcodesBTC,
  OpcodesXEC,
  ReadBytesError,
  ReadItemCountError,
  ReadUint32LEError,
  ReadUint64LEError,
  Secp256k1Error,
  SigningSerializationAlgorithmIdentifier,
  SigningSerializationFlag,
  SigningSerializationType,
  SigningSerializationTypeBCH,
  SigningSerializationTypesBCH,
  SigningSerializationTypesBCH2023,
  SigningSerializationTypesCommon,
  TransactionDecodingError,
  VmNumberError,
  WalletImportFormatError,
  addressContentsToLockingBytecode,
  allErrorsAreRecoverable,
  applyError,
  assembleBitcoinSatoshiScript,
  assembleBytecode,
  assembleBytecodeBCH,
  assembleBytecodeBTC,
  attemptCashAddressFormatErrorCorrection,
  attemptCompilerOperations,
  authenticationInstructionIsMalformed,
  authenticationInstructionsAreMalformed,
  authenticationInstructionsArePushInstructions,
  authenticationTemplateP2pkh,
  authenticationTemplateP2pkhNonHd,
  authenticationTemplateToCompilerBCH,
  authenticationTemplateToCompilerConfiguration,
  base58AddressToLockingBytecode,
  base58ToBin,
  base64ToBin,
  bech32CharacterSet,
  bech32CharacterSetIndex,
  bech32PaddedToBin,
  bigIntToBinUint256BEClamped,
  bigIntToBinUint64LE,
  bigIntToBinUint64LEClamped,
  bigIntToBinUintLE,
  bigIntToCompactSize,
  bigIntToVmNumber,
  binStringToBin,
  binToBase58,
  binToBase64,
  binToBech32Padded,
  binToBigIntUint256BE,
  binToBigIntUint64LE,
  binToBigIntUintBE,
  binToBigIntUintLE,
  binToBinString,
  binToFixedLength,
  binToHex,
  binToNumberInt16LE,
  binToNumberInt32LE,
  binToNumberUint16LE,
  binToNumberUint32LE,
  binToNumberUintLE,
  binToUtf8,
  binToValueSatoshis,
  binsAreEqual,
  bitcoinBase58Alphabet,
  bitcoinSatoshiOpcodes,
  bitwiseOperation,
  booleanToVmNumber,
  cashAddressChecksumToUint5Array,
  cashAddressLengthToSizeBits,
  cashAddressPolynomialModulo,
  cashAddressPolynomialToCashAddress,
  cashAddressSizeBitsToLength,
  cashAddressToLockingBytecode,
  cashAddressTypeBitsToType,
  cashAddressTypeToTypeBits,
  cashAssemblyToBin,
  checkLimitsCommon,
  cloneAuthenticationInstruction,
  cloneAuthenticationProgramCommon,
  cloneAuthenticationProgramState,
  cloneAuthenticationProgramStateBCH,
  cloneAuthenticationProgramStateBCHCHIPs,
  cloneAuthenticationProgramStateCommon,
  cloneStack,
  cloneTransactionCommon,
  cloneTransactionInputsCommon,
  cloneTransactionOutputsCommon,
  combineOperations,
  compactSizePrefixToSize,
  compactSizeToBigInt,
  compileAuthenticationTemplateScenarioBytecode,
  compileAuthenticationTemplateScenarioValueSatoshis,
  compileCashAssembly,
  compileInputTemplate,
  compileOutputTemplate,
  compileScenarioOutputTokenData,
  compileScript,
  compileScriptContents,
  compileScriptRaw,
  compilerConfigurationToCompiler,
  compilerConfigurationToCompilerBCH,
  compilerOperationAddressData,
  compilerOperationAttemptBytecodeResolution,
  compilerOperationCurrentBlockHeight,
  compilerOperationCurrentBlockTime,
  compilerOperationHdKeyEcdsaDataSignatureBCH,
  compilerOperationHdKeyEcdsaSignatureBCH,
  compilerOperationHdKeyPublicKeyCommon,
  compilerOperationHdKeySchnorrDataSignatureBCH,
  compilerOperationHdKeySchnorrSignatureBCH,
  compilerOperationHelperAddressIndex,
  compilerOperationHelperCompileScript,
  compilerOperationHelperComputeDataSignatureBCH,
  compilerOperationHelperComputeSignatureBCH,
  compilerOperationHelperDeriveHdKeyPrivate,
  compilerOperationHelperDeriveHdPrivateNode,
  compilerOperationHelperGenerateCoveredBytecode,
  compilerOperationHelperHdKeyDataSignatureBCH,
  compilerOperationHelperHdKeySignatureBCH,
  compilerOperationHelperKeyDataSignatureBCH,
  compilerOperationHelperKeySignatureBCH,
  compilerOperationHelperUnknownEntity,
  compilerOperationKeyEcdsaDataSignatureBCH,
  compilerOperationKeyEcdsaSignatureBCH,
  compilerOperationKeyPublicKeyCommon,
  compilerOperationKeySchnorrDataSignatureBCH,
  compilerOperationKeySchnorrSignatureBCH,
  compilerOperationRequires,
  compilerOperationSigningSerializationCorrespondingOutput,
  compilerOperationSigningSerializationCorrespondingOutputHash,
  compilerOperationSigningSerializationCoveredBytecode,
  compilerOperationSigningSerializationCoveredBytecodeLength,
  compilerOperationSigningSerializationFullBCH,
  compilerOperationSigningSerializationLocktime,
  compilerOperationSigningSerializationOutpointIndex,
  compilerOperationSigningSerializationOutpointTransactionHash,
  compilerOperationSigningSerializationOutputValue,
  compilerOperationSigningSerializationSequenceNumber,
  compilerOperationSigningSerializationTransactionOutpoints,
  compilerOperationSigningSerializationTransactionOutpointsHash,
  compilerOperationSigningSerializationTransactionOutputs,
  compilerOperationSigningSerializationTransactionOutputsHash,
  compilerOperationSigningSerializationTransactionSequenceNumbers,
  compilerOperationSigningSerializationTransactionSequenceNumbersHash,
  compilerOperationSigningSerializationVersion,
  compilerOperationWalletData,
  compilerOperationsBCH,
  compilerOperationsCommon,
  conditionallyEvaluate,
  conditionallyEvaluateChipLoops,
  containsRange,
  crackHdPrivateNodeFromHdPublicNodeAndChildPrivateNode,
  createAuthenticationProgramEvaluationCommon,
  createAuthenticationProgramStateBCHCHIPs,
  createAuthenticationProgramStateCommon,
  createAuthenticationVirtualMachine,
  createBaseConverter,
  createCompilationContextCommonTesting,
  createCompiler,
  createCompilerBCH,
  createCompilerCommon,
  createCompilerGenerateBytecodeFunction,
  createEmptyRange,
  createIdentifierResolver,
  createInstructionSetBCH,
  createInstructionSetBCH2022,
  createInstructionSetBCH2023,
  createInstructionSetBCHCHIPs,
  createInstructionSetXEC,
  createTestAuthenticationProgramBCH,
  createVirtualMachineBCH,
  createVirtualMachineBCH2022,
  createVirtualMachineBCH2023,
  createVirtualMachineBCHCHIPs,
  createVirtualMachineXEC,
  dateToLocktime,
  dateToLocktimeBin,
  decodeAuthenticationInstruction,
  decodeAuthenticationInstructions,
  decodeBase58Address,
  decodeBase58AddressFormat,
  decodeBech32,
  decodeBitcoinSignature,
  decodeCashAddress,
  decodeCashAddressFormat,
  decodeCashAddressFormatWithoutPrefix,
  decodeCashAddressNonStandard,
  decodeCashAddressVersionByte,
  decodeHdKey,
  decodeHdPrivateKey,
  decodeHdPublicKey,
  decodeLittleEndianNumber,
  decodeLocktime,
  decodePrivateKeyWif,
  decodeTransaction,
  decodeTransactionBCH,
  decodeTransactionCommon,
  decodeTransactionUnsafe,
  decodeTransactionUnsafeBCH,
  decodeTransactionUnsafeCommon,
  deriveHdPath,
  deriveHdPrivateNodeChild,
  deriveHdPrivateNodeFromSeed,
  deriveHdPrivateNodeIdentifier,
  deriveHdPublicNode,
  deriveHdPublicNodeChild,
  deriveHdPublicNodeIdentifier,
  describeExpectedInput,
  disabledOperation,
  disassembleAuthenticationInstruction,
  disassembleAuthenticationInstructionMalformed,
  disassembleAuthenticationInstructionMaybeMalformed,
  disassembleAuthenticationInstructionsMaybeMalformed,
  disassembleBytecode,
  disassembleBytecodeBCH,
  disassembleBytecodeBTC,
  encodeAuthenticationInstruction,
  encodeAuthenticationInstructionMalformed,
  encodeAuthenticationInstructionMaybeMalformed,
  encodeAuthenticationInstructions,
  encodeAuthenticationInstructionsMaybeMalformed,
  encodeBase58Address,
  encodeBase58AddressFormat,
  encodeBech32,
  encodeCashAddress,
  encodeCashAddressFormat,
  encodeCashAddressNonStandard,
  encodeCashAddressVersionByte,
  encodeDataPush,
  encodeHdPrivateKey,
  encodeHdPublicKey,
  encodeLockingBytecodeP2pk,
  encodeLockingBytecodeP2pkh,
  encodeLockingBytecodeP2sh20,
  encodeLockingBytecodeP2sh32,
  encodePrivateKeyWif,
  encodeSigningSerializationBCH,
  encodeTokenPrefix,
  encodeTransaction,
  encodeTransactionBCH,
  encodeTransactionCommon,
  encodeTransactionInput,
  encodeTransactionInputSequenceNumbersForSigning,
  encodeTransactionInputs,
  encodeTransactionOutpoints,
  encodeTransactionOutput,
  encodeTransactionOutputs,
  encodeTransactionOutputsForSigning,
  excessiveSatoshis,
  extendCompilationDataWithScenarioBytecode,
  extendScenarioDefinition,
  extendScenarioDefinitionData,
  extendedScenarioDefinitionToCompilationData,
  extractBytecodeResolutions,
  extractEvaluationSamples,
  extractEvaluationSamplesRecursive,
  extractGenesisCategories,
  extractMissingVariables,
  extractResolvedVariableBytecodeMap,
  extractResolvedVariables,
  extractSourceOutputTokenData,
  extractTransactionOutputTokenData,
  extractUnexecutedRanges,
  flattenBinArray,
  formatError,
  generateBytecodeMap,
  generateDefaultScenarioDefinition,
  generateExtendedScenario,
  generatePrivateKey,
  generateScenarioBCH,
  generateSigningSerializationBCH,
  generateSigningSerializationComponentsBCH,
  generateTransaction,
  getDustThreshold,
  getEmbeddedRipemd160Binary,
  getEmbeddedSecp256k1Binary,
  getEmbeddedSha1Binary,
  getEmbeddedSha256Binary,
  getEmbeddedSha512Binary,
  getMinimumFee,
  getResolutionErrors,
  hash160,
  hash256,
  hashDigestIterations,
  hashOutputs,
  hashPrevouts,
  hashSequence,
  hashTransaction,
  hashTransactionP2pOrder,
  hashTransactionUiOrder,
  hashUtxos,
  hdPrivateKeyToIdentifier,
  hdPrivateKeyToP2pkhAddress,
  hdPrivateKeyToP2pkhLockingBytecode,
  hdPublicKeyToIdentifier,
  hexToBin,
  hmacSha256,
  hmacSha512,
  importAuthenticationTemplate,
  incrementHashDigestIterations,
  incrementOperationCount,
  instantiateHmacFunction,
  instantiateRipemd160,
  instantiateRipemd160Bytes,
  instantiateRustWasm,
  instantiateSecp256k1,
  instantiateSecp256k1Bytes,
  instantiateSecp256k1Wasm,
  instantiateSecp256k1WasmBytes,
  instantiateSha1,
  instantiateSha1Bytes,
  instantiateSha256,
  instantiateSha256Bytes,
  instantiateSha512,
  instantiateSha512Bytes,
  int32SignedToUnsigned,
  int32UnsignedToSigned,
  isArbitraryDataOutput,
  isBase64,
  isBech32CharacterSet,
  isBinString,
  isDustOutput,
  isHex,
  isLegacySigningSerialization,
  isMinimalDataPush,
  isPayToPublicKey,
  isPayToPublicKeyCompressed,
  isPayToPublicKeyHash,
  isPayToPublicKeyUncompressed,
  isPayToScriptHash20,
  isPayToScriptHash32,
  isPushOnly,
  isPushOnlyAccurate,
  isPushOperation,
  isSimpleMultisig,
  isStandardMultisig,
  isStandardOutputBytecode,
  isStandardOutputBytecode2023,
  isValidCashAddressPayloadLength,
  isValidCompressedPublicKeyEncoding,
  isValidPublicKeyEncoding,
  isValidSignatureEncodingBCHRaw,
  isValidSignatureEncodingBCHTransaction,
  isValidSignatureEncodingDER,
  isValidUncompressedPublicKeyEncoding,
  isVmNumberError,
  isWitnessProgram,
  lockingBytecodeToAddressContents,
  lockingBytecodeToBase58Address,
  lockingBytecodeToCashAddress,
  locktimeToDate,
  mapOverOperations,
  maskCashAddressPrefix,
  maximumLocktimeDate,
  maximumLocktimeTimestamp,
  mergeRanges,
  minimumLocktimeDate,
  minimumLocktimeTimestamp,
  nftCapabilityLabelToNumber,
  nftCapabilityNumberToLabel,
  numberToBinInt16LE,
  numberToBinInt32LE,
  numberToBinInt32TwosCompliment,
  numberToBinUint16BE,
  numberToBinUint16LE,
  numberToBinUint16LEClamped,
  numberToBinUint32BE,
  numberToBinUint32LE,
  numberToBinUint32LEClamped,
  numberToBinUintLE,
  op0NotEqual,
  op1Add,
  op1Sub,
  op2Drop,
  op2Dup,
  op2Over,
  op2Rot,
  op2Swap,
  op3Dup,
  opAbs,
  opActiveBytecode,
  opAdd,
  opAnd,
  opBegin,
  opBin2Num,
  opBoolAnd,
  opBoolOr,
  opCat,
  opCheckDataSig,
  opCheckDataSigChipLimits,
  opCheckDataSigVerify,
  opCheckDataSigVerifyChipLimits,
  opCheckLockTimeVerify,
  opCheckMultiSig,
  opCheckMultiSigBCH2023,
  opCheckMultiSigChipLimits,
  opCheckMultiSigVerify,
  opCheckMultiSigVerifyBCH2023,
  opCheckMultiSigVerifyChipLimits,
  opCheckSequenceVerify,
  opCheckSig,
  opCheckSigBCH2023,
  opCheckSigChipLimits,
  opCheckSigVerify,
  opCheckSigVerifyBCH2023,
  opCheckSigVerifyChipLimits,
  opCodeSeparator,
  opDepth,
  opDiv,
  opDrop,
  opDup,
  opElse,
  opElseChipLoops,
  opEndIf,
  opEndIfChipLoops,
  opEqual,
  opEqualVerify,
  opFromAltStack,
  opGreaterThan,
  opGreaterThanOrEqual,
  opHash160,
  opHash160ChipLimits,
  opHash256,
  opHash256ChipLimits,
  opIf,
  opIfChipLoops,
  opIfDup,
  opInputBytecode,
  opInputIndex,
  opInputSequenceNumber,
  opLessThan,
  opLessThanOrEqual,
  opMax,
  opMin,
  opMod,
  opMul,
  opNegate,
  opNip,
  opNop,
  opNopDisallowed,
  opNot,
  opNotIf,
  opNotIfChipLoops,
  opNum2Bin,
  opNumEqual,
  opNumEqualVerify,
  opNumNotEqual,
  opOr,
  opOutpointIndex,
  opOutpointTxHash,
  opOutputBytecode,
  opOutputTokenAmount,
  opOutputTokenCategory,
  opOutputTokenCommitment,
  opOutputValue,
  opOver,
  opPick,
  opReturn,
  opReverseBytes,
  opRipemd160,
  opRipemd160ChipLimits,
  opRoll,
  opRot,
  opSha1,
  opSha1ChipLimits,
  opSha256,
  opSha256ChipLimits,
  opSize,
  opSplit,
  opSub,
  opSwap,
  opToAltStack,
  opTuck,
  opTxInputCount,
  opTxLocktime,
  opTxOutputCount,
  opTxVersion,
  opUntil,
  opUtxoBytecode,
  opUtxoTokenAmount,
  opUtxoTokenCategory,
  opUtxoTokenCommitment,
  opUtxoValue,
  opVerify,
  opWithin,
  opXor,
  opcodeToPushLength,
  padMinimallyEncodedVmNumber,
  parseScript,
  pushNumberOpcodeToNumber,
  pushNumberOperation,
  pushOperation,
  pushOperationChipLoops,
  pushToControlStackChipLoops,
  pushToStack,
  pushToStackChecked,
  pushToStackVmNumber,
  pushToStackVmNumberChecked,
  pushTokenAmount,
  pushTokenCommitment,
  pushTokenExtendedCategory,
  range,
  readBytes,
  readCompactSize,
  readCompactSizeMinimal,
  readCompactSizePrefixedBin,
  readItemCount,
  readLockingBytecodeWithPrefix,
  readMultiple,
  readRemainingBytes,
  readTokenAmount,
  readTokenPrefix,
  readTransaction,
  readTransactionCommon,
  readTransactionInput,
  readTransactionInputs,
  readTransactionNonTokenAware,
  readTransactionOutput,
  readTransactionOutputNonTokenAware,
  readTransactionOutputs,
  readTransactionOutputsNonTokenAware,
  readUint32LE,
  readUint64LE,
  reduceScript,
  regroupBits,
  reservedOperation,
  resolveScriptIdentifier,
  resolveScriptSegment,
  resolveVariableIdentifier,
  ripemd160,
  ripemd160Base64Bytes,
  safelyExtendCompilationData,
  secp256k1,
  sha1,
  sha1Base64Bytes,
  sha256,
  sha256Base64Bytes,
  sha512,
  sha512Base64Bytes,
  sortObjectKeys,
  splitEvery,
  stackItemIsTruthy,
  stringify,
  stringifyDebugTraceSummary,
  stringifyErrors,
  stringifyTestVector,
  summarizeDebugTrace,
  summarizeStack,
  supportedTestSetOverridesBCH,
  swapEndianness,
  undefinedOperation,
  undefinedOperationChipLoops,
  unknownValue,
  useFourStackItems,
  useLocktime,
  useOneStackItem,
  useOneVmNumber,
  useSixStackItems,
  useThreeStackItems,
  useThreeVmNumbers,
  useTransactionInput,
  useTransactionOutput,
  useTransactionUtxo,
  useTwoStackItems,
  useTwoVmNumbers,
  utf8ToBin,
  validateSecp256k1PrivateKey,
  valueSatoshisToBin,
  verifyCashAssemblyEvaluationState,
  verifyTransactionTokens,
  vmNumberToBigInt,
  vmbTestDefinitionDefaultBehaviorBCH,
  vmbTestDefinitionToVmbTests,
  vmbTestGroupToVmbTests,
  vmbTestPartitionMasterTestList
};
//# sourceMappingURL=@bitauth_libauth.js.map
