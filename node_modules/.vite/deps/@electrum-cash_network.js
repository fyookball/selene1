import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'

globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
globalThis.global = globalThis.global || __global_polyfill
globalThis.process = globalThis.process || __process_polyfill

import {
  __commonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-UN4YHSTI.js";

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var import_dist49 = __toESM(require_dist());
    var import_dist50 = __toESM(require_dist2());
    var import_dist51 = __toESM(require_dist3());
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/@electrum-cash/debug-logs/node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/@electrum-cash/debug-logs/node_modules/debug/src/common.js"(exports, module) {
    var import_dist49 = __toESM(require_dist());
    var import_dist50 = __toESM(require_dist2());
    var import_dist51 = __toESM(require_dist3());
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/@electrum-cash/debug-logs/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/@electrum-cash/debug-logs/node_modules/debug/src/browser.js"(exports, module) {
    var import_dist49 = __toESM(require_dist());
    var import_dist50 = __toESM(require_dist2());
    var import_dist51 = __toESM(require_dist3());
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var import_dist49 = __toESM(require_dist());
    var import_dist50 = __toESM(require_dist2());
    var import_dist51 = __toESM(require_dist3());
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// node_modules/@electrum-cash/network/dist/index.mjs
var import_dist46 = __toESM(require_dist(), 1);
var import_dist47 = __toESM(require_dist2(), 1);
var import_dist48 = __toESM(require_dist3(), 1);

// node_modules/@electrum-cash/debug-logs/dist/index.mjs
var import_dist = __toESM(require_dist(), 1);
var import_dist2 = __toESM(require_dist2(), 1);
var import_dist3 = __toESM(require_dist3(), 1);
var import_debug = __toESM(require_browser(), 1);
var $9de8c596df24b669$var$debug = {
  client: (0, import_debug.default)("electrum-cash:client "),
  errors: (0, import_debug.default)("electrum-cash:error  "),
  warning: (0, import_debug.default)("electrum-cash:warning"),
  network: (0, import_debug.default)("electrum-cash:network"),
  ping: (0, import_debug.default)("electrum-cash:pulses ")
};
$9de8c596df24b669$var$debug.client.color = "2";
$9de8c596df24b669$var$debug.errors.color = "9";
$9de8c596df24b669$var$debug.warning.color = "13";
$9de8c596df24b669$var$debug.network.color = "4";
$9de8c596df24b669$var$debug.ping.color = "8";
var $9de8c596df24b669$export$2e2bcd8739ae039 = $9de8c596df24b669$var$debug;

// node_modules/eventemitter3/index.mjs
var import_dist4 = __toESM(require_dist(), 1);
var import_dist5 = __toESM(require_dist2(), 1);
var import_dist6 = __toESM(require_dist3(), 1);
var import_index = __toESM(require_eventemitter3(), 1);

// node_modules/async-mutex/index.mjs
var import_dist7 = __toESM(require_dist(), 1);
var import_dist8 = __toESM(require_dist2(), 1);
var import_dist9 = __toESM(require_dist3(), 1);
var E_TIMEOUT = new Error("timeout while waiting for mutex to become available");
var E_ALREADY_LOCKED = new Error("mutex already locked");
var E_CANCELED = new Error("request for lock canceled");
var __awaiter$2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Semaphore = class {
  constructor(_value, _cancelError = E_CANCELED) {
    this._value = _value;
    this._cancelError = _cancelError;
    this._queue = [];
    this._weightedWaiters = [];
  }
  acquire(weight = 1, priority = 0) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    return new Promise((resolve, reject) => {
      const task = { resolve, reject, weight, priority };
      const i = findIndexFromEnd(this._queue, (other) => priority <= other.priority);
      if (i === -1 && weight <= this._value) {
        this._dispatchItem(task);
      } else {
        this._queue.splice(i + 1, 0, task);
      }
    });
  }
  runExclusive(callback_1) {
    return __awaiter$2(this, arguments, void 0, function* (callback, weight = 1, priority = 0) {
      const [value, release] = yield this.acquire(weight, priority);
      try {
        return yield callback(value);
      } finally {
        release();
      }
    });
  }
  waitForUnlock(weight = 1, priority = 0) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    if (this._couldLockImmediately(weight, priority)) {
      return Promise.resolve();
    } else {
      return new Promise((resolve) => {
        if (!this._weightedWaiters[weight - 1])
          this._weightedWaiters[weight - 1] = [];
        insertSorted(this._weightedWaiters[weight - 1], { resolve, priority });
      });
    }
  }
  isLocked() {
    return this._value <= 0;
  }
  getValue() {
    return this._value;
  }
  setValue(value) {
    this._value = value;
    this._dispatchQueue();
  }
  release(weight = 1) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    this._value += weight;
    this._dispatchQueue();
  }
  cancel() {
    this._queue.forEach((entry) => entry.reject(this._cancelError));
    this._queue = [];
  }
  _dispatchQueue() {
    this._drainUnlockWaiters();
    while (this._queue.length > 0 && this._queue[0].weight <= this._value) {
      this._dispatchItem(this._queue.shift());
      this._drainUnlockWaiters();
    }
  }
  _dispatchItem(item) {
    const previousValue = this._value;
    this._value -= item.weight;
    item.resolve([previousValue, this._newReleaser(item.weight)]);
  }
  _newReleaser(weight) {
    let called = false;
    return () => {
      if (called)
        return;
      called = true;
      this.release(weight);
    };
  }
  _drainUnlockWaiters() {
    if (this._queue.length === 0) {
      for (let weight = this._value; weight > 0; weight--) {
        const waiters = this._weightedWaiters[weight - 1];
        if (!waiters)
          continue;
        waiters.forEach((waiter) => waiter.resolve());
        this._weightedWaiters[weight - 1] = [];
      }
    } else {
      const queuedPriority = this._queue[0].priority;
      for (let weight = this._value; weight > 0; weight--) {
        const waiters = this._weightedWaiters[weight - 1];
        if (!waiters)
          continue;
        const i = waiters.findIndex((waiter) => waiter.priority <= queuedPriority);
        (i === -1 ? waiters : waiters.splice(0, i)).forEach((waiter) => waiter.resolve());
      }
    }
  }
  _couldLockImmediately(weight, priority) {
    return (this._queue.length === 0 || this._queue[0].priority < priority) && weight <= this._value;
  }
};
function insertSorted(a, v) {
  const i = findIndexFromEnd(a, (other) => v.priority <= other.priority);
  a.splice(i + 1, 0, v);
}
function findIndexFromEnd(a, predicate) {
  for (let i = a.length - 1; i >= 0; i--) {
    if (predicate(a[i])) {
      return i;
    }
  }
  return -1;
}
var __awaiter$1 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Mutex = class {
  constructor(cancelError) {
    this._semaphore = new Semaphore(1, cancelError);
  }
  acquire() {
    return __awaiter$1(this, arguments, void 0, function* (priority = 0) {
      const [, releaser] = yield this._semaphore.acquire(1, priority);
      return releaser;
    });
  }
  runExclusive(callback, priority = 0) {
    return this._semaphore.runExclusive(() => callback(), 1, priority);
  }
  isLocked() {
    return this._semaphore.isLocked();
  }
  waitForUnlock(priority = 0) {
    return this._semaphore.waitForUnlock(1, priority);
  }
  release() {
    if (this._semaphore.isLocked())
      this._semaphore.release();
  }
  cancel() {
    return this._semaphore.cancel();
  }
};

// node_modules/@electrum-cash/web-socket/dist/index.mjs
var import_dist13 = __toESM(require_dist(), 1);
var import_dist14 = __toESM(require_dist2(), 1);
var import_dist15 = __toESM(require_dist3(), 1);

// node_modules/@monsterbitar/isomorphic-ws/browser.mjs
var import_dist10 = __toESM(require_dist(), 1);
var import_dist11 = __toESM(require_dist2(), 1);
var import_dist12 = __toESM(require_dist3(), 1);
var ws = null;
if (typeof WebSocket !== "undefined") {
  ws = WebSocket;
} else if (typeof MozWebSocket !== "undefined") {
  ws = MozWebSocket;
} else if (typeof global !== "undefined") {
  ws = global.WebSocket || global.MozWebSocket;
} else if (typeof window !== "undefined") {
  ws = window.WebSocket || window.MozWebSocket;
} else if (typeof self !== "undefined") {
  ws = self.WebSocket || self.MozWebSocket;
}

// node_modules/@electrum-cash/web-socket/dist/index.mjs
function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, { get: v, set: s, enumerable: true, configurable: true });
}
var $05743633fea447d4$exports = {};
$parcel$export($05743633fea447d4$exports, "ElectrumWebSocket", () => $05743633fea447d4$export$25b4633f61498e1);
var $d801b1f9b7fc3074$export$1bddf2b96e25d075 = 3e4;
var $05743633fea447d4$export$25b4633f61498e1 = class extends (0, import_index.default) {
  host;
  port;
  encrypted;
  timeout;
  // Declare an empty WebSocket.
  webSocket;
  // Used to disconnect after some time if initial connection is too slow.
  disconnectTimer;
  // Initialize boolean that indicates whether the onConnect function has run (initialize to false).
  onConnectHasRun;
  // Initialize event forwarding functions.
  eventForwarders;
  /**
  * Creates a socket configured with connection information for a given Electrum server.
  *
  * @param host        Fully qualified domain name or IP address of the host
  * @param port        Network port for the host to connect to, defaults to the standard TLS port
  * @param encrypted   If false, uses an unencrypted connection instead of the default on TLS
  * @param timeout     If no connection is established after `timeout` ms, the connection is terminated
  */
  constructor(host, port = 50004, encrypted = true, timeout = (0, $d801b1f9b7fc3074$export$1bddf2b96e25d075)) {
    super();
    this.host = host;
    this.port = port;
    this.encrypted = encrypted;
    this.timeout = timeout;
    this.onConnectHasRun = false;
    this.eventForwarders = {
      disconnect: () => this.emit("disconnected"),
      wsData: (event) => this.emit("data", `${event.data}
`),
      wsError: (event) => this.emit("error", new Error(event.error))
    };
  }
  /**
  * Returns a string for the host identifier for usage in debug messages.
  */
  get hostIdentifier() {
    return `${this.host}:${this.port}`;
  }
  /**
  * Connect to host:port using the specified transport
  */
  connect() {
    if (this.webSocket)
      throw new Error("Cannot initiate a new socket connection when an existing connection exists");
    this.disconnectTimer = setTimeout(() => this.disconnectOnTimeout(), this.timeout);
    this.once("connected", this.clearDisconnectTimerOnTimeout);
    const connectionType = this.encrypted ? "an encrypted WebSocket" : "a WebSocket";
    (0, $9de8c596df24b669$export$2e2bcd8739ae039).network(`Initiating ${connectionType} connection to '${this.host}:${this.port}'.`);
    if (this.encrypted)
      this.webSocket = new (0, ws)(`wss://${this.host}:${this.port}`);
    else
      this.webSocket = new (0, ws)(`ws://${this.host}:${this.port}`);
    this.webSocket.addEventListener("open", this.onConnect.bind(this));
    this.webSocket.addEventListener("error", this.eventForwarders.wsError);
  }
  /**
  * Sets up forwarding of events related to the connection.
  */
  onConnect() {
    if (this.onConnectHasRun)
      return;
    const connectionType = this.encrypted ? "an encrypted WebSocket" : "a WebSocket";
    (0, $9de8c596df24b669$export$2e2bcd8739ae039).network(`Established ${connectionType} connection with '${this.host}:${this.port}'.`);
    this.webSocket.addEventListener("close", this.eventForwarders.disconnect);
    this.webSocket.addEventListener("message", this.eventForwarders.wsData);
    this.onConnectHasRun = true;
    this.emit("connected");
  }
  /**
  * Clears the disconnect timer if it is still active.
  */
  clearDisconnectTimerOnTimeout() {
    if (this.disconnectTimer)
      clearTimeout(this.disconnectTimer);
  }
  /**
  * Forcibly terminate the connection.
  *
  * @throws {Error} if no connection was found
  */
  disconnect() {
    this.clearDisconnectTimerOnTimeout();
    try {
      this.webSocket.removeEventListener("close", this.eventForwarders.disconnect);
      this.webSocket.removeEventListener("message", this.eventForwarders.wsData);
      this.webSocket.removeEventListener("error", this.eventForwarders.wsError);
      this.webSocket.close();
    } catch (ignored) {
    } finally {
      this.webSocket = void 0;
    }
    this.onConnectHasRun = false;
    this.emit("disconnected");
  }
  /**
  * Write data to the socket
  *
  * @param data       Data to be written to the socket
  * @param callback   Callback function to be called when the write has completed
  *
  * @throws {Error} if no connection was found
  * @returns true if the message was fully flushed to the socket, false if part of the message
  * is queued in the user memory
  */
  write(data, callback) {
    if (!this.webSocket)
      throw new Error("Cannot write to socket when there is no active connection");
    this.webSocket.send(data, callback);
    return true;
  }
  /**
  * Force a disconnection if no connection is established after `timeout` milliseconds.
  */
  disconnectOnTimeout() {
    this.removeListener("connected", this.clearDisconnectTimerOnTimeout);
    this.emit("error", new Error(`Connection to '${this.host}:${this.port}' timed out after ${this.timeout} milliseconds`));
    this.disconnect();
  }
  // Add magic glue that makes typedoc happy so that we can have the events listed on the class.
  connected;
  disconnected;
  data;
  error;
};

// node_modules/lossless-json/lib/esm/index.js
var import_dist43 = __toESM(require_dist());
var import_dist44 = __toESM(require_dist2());
var import_dist45 = __toESM(require_dist3());

// node_modules/lossless-json/lib/esm/config.js
var import_dist16 = __toESM(require_dist(), 1);
var import_dist17 = __toESM(require_dist2(), 1);
var import_dist18 = __toESM(require_dist3(), 1);

// node_modules/lossless-json/lib/esm/parse.js
var import_dist31 = __toESM(require_dist(), 1);
var import_dist32 = __toESM(require_dist2(), 1);
var import_dist33 = __toESM(require_dist3(), 1);

// node_modules/lossless-json/lib/esm/numberParsers.js
var import_dist25 = __toESM(require_dist(), 1);
var import_dist26 = __toESM(require_dist2(), 1);
var import_dist27 = __toESM(require_dist3(), 1);

// node_modules/lossless-json/lib/esm/LosslessNumber.js
var import_dist22 = __toESM(require_dist(), 1);
var import_dist23 = __toESM(require_dist2(), 1);
var import_dist24 = __toESM(require_dist3(), 1);

// node_modules/lossless-json/lib/esm/utils.js
var import_dist19 = __toESM(require_dist(), 1);
var import_dist20 = __toESM(require_dist2(), 1);
var import_dist21 = __toESM(require_dist3(), 1);
function isInteger(value) {
  return INTEGER_REGEX.test(value);
}
var INTEGER_REGEX = /^-?[0-9]+$/;
function isNumber(value) {
  return NUMBER_REGEX.test(value);
}
var NUMBER_REGEX = /^-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?$/;
function isSafeNumber(value, config2) {
  const num = Number.parseFloat(value);
  const str = String(num);
  const v = extractSignificantDigits(value);
  const s = extractSignificantDigits(str);
  if (v === s) {
    return true;
  }
  if (config2?.approx === true) {
    const requiredDigits = 14;
    if (!isInteger(value) && s.length >= requiredDigits && v.startsWith(s.substring(0, requiredDigits))) {
      return true;
    }
  }
  return false;
}
var UnsafeNumberReason = function(UnsafeNumberReason2) {
  UnsafeNumberReason2["underflow"] = "underflow";
  UnsafeNumberReason2["overflow"] = "overflow";
  UnsafeNumberReason2["truncate_integer"] = "truncate_integer";
  UnsafeNumberReason2["truncate_float"] = "truncate_float";
  return UnsafeNumberReason2;
}({});
function getUnsafeNumberReason(value) {
  if (isSafeNumber(value, {
    approx: false
  })) {
    return void 0;
  }
  if (isInteger(value)) {
    return UnsafeNumberReason.truncate_integer;
  }
  const num = Number.parseFloat(value);
  if (!Number.isFinite(num)) {
    return UnsafeNumberReason.overflow;
  }
  if (num === 0) {
    return UnsafeNumberReason.underflow;
  }
  return UnsafeNumberReason.truncate_float;
}
function extractSignificantDigits(value) {
  return value.replace(EXPONENTIAL_PART_REGEX, "").replace(DOT_REGEX, "").replace(TRAILING_ZEROS_REGEX, "").replace(LEADING_MINUS_AND_ZEROS_REGEX, "");
}
var EXPONENTIAL_PART_REGEX = /[eE][+-]?\d+$/;
var LEADING_MINUS_AND_ZEROS_REGEX = /^-?(0*)?/;
var DOT_REGEX = /\./;
var TRAILING_ZEROS_REGEX = /0+$/;

// node_modules/lossless-json/lib/esm/LosslessNumber.js
var LosslessNumber = class {
  // numeric value as string
  // type information
  isLosslessNumber = true;
  constructor(value) {
    if (!isNumber(value)) {
      throw new Error(`Invalid number (value: "${value}")`);
    }
    this.value = value;
  }
  /**
   * Get the value of the LosslessNumber as number or bigint.
   *
   * - a number is returned for safe numbers and decimal values that only lose some insignificant digits
   * - a bigint is returned for big integer numbers
   * - an Error is thrown for values that will overflow or underflow
   *
   * Note that you can implement your own strategy for conversion by just getting the value as string
   * via .toString(), and using util functions like isInteger, isSafeNumber, getUnsafeNumberReason,
   * and toSafeNumberOrThrow to convert it to a numeric value.
   */
  valueOf() {
    const unsafeReason = getUnsafeNumberReason(this.value);
    if (unsafeReason === void 0 || unsafeReason === UnsafeNumberReason.truncate_float) {
      return Number.parseFloat(this.value);
    }
    if (isInteger(this.value)) {
      return BigInt(this.value);
    }
    throw new Error(`Cannot safely convert to number: the value '${this.value}' would ${unsafeReason} and become ${Number.parseFloat(this.value)}`);
  }
  /**
   * Get the value of the LosslessNumber as string.
   */
  toString() {
    return this.value;
  }
  // Note: we do NOT implement a .toJSON() method, and you should not implement
  // or use that, it cannot safely turn the numeric value in the string into
  // stringified JSON since it has to be parsed into a number first.
};
function isLosslessNumber(value) {
  return value && typeof value === "object" && value.isLosslessNumber === true || false;
}

// node_modules/lossless-json/lib/esm/numberParsers.js
function parseLosslessNumber(value) {
  return new LosslessNumber(value);
}
function parseNumberAndBigInt(value) {
  return isInteger(value) ? BigInt(value) : Number.parseFloat(value);
}

// node_modules/lossless-json/lib/esm/revive.js
var import_dist28 = __toESM(require_dist(), 1);
var import_dist29 = __toESM(require_dist2(), 1);
var import_dist30 = __toESM(require_dist3(), 1);
function revive(json, reviver) {
  return reviveValue({
    "": json
  }, "", json, reviver);
}
function reviveValue(context, key, value, reviver) {
  if (Array.isArray(value)) {
    return reviver.call(context, key, reviveArray(value, reviver));
  }
  if (value && typeof value === "object" && !isLosslessNumber(value)) {
    return reviver.call(context, key, reviveObject(value, reviver));
  }
  return reviver.call(context, key, value);
}
function reviveObject(object, reviver) {
  for (const key of Object.keys(object)) {
    const value = reviveValue(object, key, object[key], reviver);
    if (value !== void 0) {
      object[key] = value;
    } else {
      delete object[key];
    }
  }
  return object;
}
function reviveArray(array, reviver) {
  for (let i = 0; i < array.length; i++) {
    array[i] = reviveValue(array, String(i), array[i], reviver);
  }
  return array;
}

// node_modules/lossless-json/lib/esm/parse.js
function parse(text, reviver) {
  let parseNumber = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : parseLosslessNumber;
  let i = 0;
  const value = parseValue();
  expectValue(value);
  expectEndOfInput();
  return reviver ? revive(value, reviver) : value;
  function parseObject() {
    if (text.charCodeAt(i) === codeOpeningBrace) {
      i++;
      skipWhitespace();
      const object = {};
      let initial = true;
      while (i < text.length && text.charCodeAt(i) !== codeClosingBrace) {
        if (!initial) {
          eatComma();
          skipWhitespace();
        } else {
          initial = false;
        }
        const start = i;
        const key = parseString();
        if (key === void 0) {
          throwObjectKeyExpected();
          return;
        }
        skipWhitespace();
        eatColon();
        const value2 = parseValue();
        if (value2 === void 0) {
          throwObjectValueExpected();
          return;
        }
        if (Object.prototype.hasOwnProperty.call(object, key) && !isDeepEqual(value2, object[key])) {
          throwDuplicateKey(key, start + 1);
        }
        object[key] = value2;
      }
      if (text.charCodeAt(i) !== codeClosingBrace) {
        throwObjectKeyOrEndExpected();
      }
      i++;
      return object;
    }
  }
  function parseArray() {
    if (text.charCodeAt(i) === codeOpeningBracket) {
      i++;
      skipWhitespace();
      const array = [];
      let initial = true;
      while (i < text.length && text.charCodeAt(i) !== codeClosingBracket) {
        if (!initial) {
          eatComma();
        } else {
          initial = false;
        }
        const value2 = parseValue();
        expectArrayItem(value2);
        array.push(value2);
      }
      if (text.charCodeAt(i) !== codeClosingBracket) {
        throwArrayItemOrEndExpected();
      }
      i++;
      return array;
    }
  }
  function parseValue() {
    skipWhitespace();
    const value2 = parseString() ?? parseNumeric() ?? parseObject() ?? parseArray() ?? parseKeyword("true", true) ?? parseKeyword("false", false) ?? parseKeyword("null", null);
    skipWhitespace();
    return value2;
  }
  function parseKeyword(name, value2) {
    if (text.slice(i, i + name.length) === name) {
      i += name.length;
      return value2;
    }
  }
  function skipWhitespace() {
    while (isWhitespace(text.charCodeAt(i))) {
      i++;
    }
  }
  function parseString() {
    if (text.charCodeAt(i) === codeDoubleQuote) {
      i++;
      let result = "";
      while (i < text.length && text.charCodeAt(i) !== codeDoubleQuote) {
        if (text.charCodeAt(i) === codeBackslash) {
          const char = text[i + 1];
          const escapeChar = escapeCharacters[char];
          if (escapeChar !== void 0) {
            result += escapeChar;
            i++;
          } else if (char === "u") {
            if (isHex(text.charCodeAt(i + 2)) && isHex(text.charCodeAt(i + 3)) && isHex(text.charCodeAt(i + 4)) && isHex(text.charCodeAt(i + 5))) {
              result += String.fromCharCode(Number.parseInt(text.slice(i + 2, i + 6), 16));
              i += 5;
            } else {
              throwInvalidUnicodeCharacter(i);
            }
          } else {
            throwInvalidEscapeCharacter(i);
          }
        } else {
          if (isValidStringCharacter(text.charCodeAt(i))) {
            result += text[i];
          } else {
            throwInvalidCharacter(text[i]);
          }
        }
        i++;
      }
      expectEndOfString();
      i++;
      return result;
    }
  }
  function parseNumeric() {
    const start = i;
    if (text.charCodeAt(i) === codeMinus) {
      i++;
      expectDigit(start);
    }
    if (text.charCodeAt(i) === codeZero) {
      i++;
    } else if (isNonZeroDigit(text.charCodeAt(i))) {
      i++;
      while (isDigit(text.charCodeAt(i))) {
        i++;
      }
    }
    if (text.charCodeAt(i) === codeDot) {
      i++;
      expectDigit(start);
      while (isDigit(text.charCodeAt(i))) {
        i++;
      }
    }
    if (text.charCodeAt(i) === codeLowercaseE || text.charCodeAt(i) === codeUppercaseE) {
      i++;
      if (text.charCodeAt(i) === codeMinus || text.charCodeAt(i) === codePlus) {
        i++;
      }
      expectDigit(start);
      while (isDigit(text.charCodeAt(i))) {
        i++;
      }
    }
    if (i > start) {
      return parseNumber(text.slice(start, i));
    }
  }
  function eatComma() {
    if (text.charCodeAt(i) !== codeComma) {
      throw new SyntaxError(`Comma ',' expected after value ${gotAt()}`);
    }
    i++;
  }
  function eatColon() {
    if (text.charCodeAt(i) !== codeColon) {
      throw new SyntaxError(`Colon ':' expected after property name ${gotAt()}`);
    }
    i++;
  }
  function expectValue(value2) {
    if (value2 === void 0) {
      throw new SyntaxError(`JSON value expected ${gotAt()}`);
    }
  }
  function expectArrayItem(value2) {
    if (value2 === void 0) {
      throw new SyntaxError(`Array item expected ${gotAt()}`);
    }
  }
  function expectEndOfInput() {
    if (i < text.length) {
      throw new SyntaxError(`Expected end of input ${gotAt()}`);
    }
  }
  function expectDigit(start) {
    if (!isDigit(text.charCodeAt(i))) {
      const numSoFar = text.slice(start, i);
      throw new SyntaxError(`Invalid number '${numSoFar}', expecting a digit ${gotAt()}`);
    }
  }
  function expectEndOfString() {
    if (text.charCodeAt(i) !== codeDoubleQuote) {
      throw new SyntaxError(`End of string '"' expected ${gotAt()}`);
    }
  }
  function throwObjectKeyExpected() {
    throw new SyntaxError(`Quoted object key expected ${gotAt()}`);
  }
  function throwDuplicateKey(key, pos2) {
    throw new SyntaxError(`Duplicate key '${key}' encountered at position ${pos2}`);
  }
  function throwObjectKeyOrEndExpected() {
    throw new SyntaxError(`Quoted object key or end of object '}' expected ${gotAt()}`);
  }
  function throwArrayItemOrEndExpected() {
    throw new SyntaxError(`Array item or end of array ']' expected ${gotAt()}`);
  }
  function throwInvalidCharacter(char) {
    throw new SyntaxError(`Invalid character '${char}' ${pos()}`);
  }
  function throwInvalidEscapeCharacter(start) {
    const chars = text.slice(start, start + 2);
    throw new SyntaxError(`Invalid escape character '${chars}' ${pos()}`);
  }
  function throwObjectValueExpected() {
    throw new SyntaxError(`Object value expected after ':' ${pos()}`);
  }
  function throwInvalidUnicodeCharacter(start) {
    const chars = text.slice(start, start + 6);
    throw new SyntaxError(`Invalid unicode character '${chars}' ${pos()}`);
  }
  function pos() {
    return `at position ${i}`;
  }
  function got() {
    return i < text.length ? `but got '${text[i]}'` : "but reached end of input";
  }
  function gotAt() {
    return `${got()} ${pos()}`;
  }
}
function isWhitespace(code) {
  return code === codeSpace || code === codeNewline || code === codeTab || code === codeReturn;
}
function isHex(code) {
  return code >= codeZero && code <= codeNine || code >= codeUppercaseA && code <= codeUppercaseF || code >= codeLowercaseA && code <= codeLowercaseF;
}
function isDigit(code) {
  return code >= codeZero && code <= codeNine;
}
function isNonZeroDigit(code) {
  return code >= codeOne && code <= codeNine;
}
function isValidStringCharacter(code) {
  return code >= 32 && code <= 1114111;
}
function isDeepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    return a.length === b.length && a.every((item, index) => isDeepEqual(item, b[index]));
  }
  if (isObject(a) && isObject(b)) {
    const keys = [.../* @__PURE__ */ new Set([...Object.keys(a), ...Object.keys(b)])];
    return keys.every((key) => isDeepEqual(a[key], b[key]));
  }
  return false;
}
function isObject(value) {
  return typeof value === "object" && value !== null;
}
var escapeCharacters = {
  '"': '"',
  "\\": "\\",
  "/": "/",
  b: "\b",
  f: "\f",
  n: "\n",
  r: "\r",
  t: "	"
  // note that \u is handled separately in parseString()
};
var codeBackslash = 92;
var codeOpeningBrace = 123;
var codeClosingBrace = 125;
var codeOpeningBracket = 91;
var codeClosingBracket = 93;
var codeSpace = 32;
var codeNewline = 10;
var codeTab = 9;
var codeReturn = 13;
var codeDoubleQuote = 34;
var codePlus = 43;
var codeMinus = 45;
var codeZero = 48;
var codeOne = 49;
var codeNine = 57;
var codeComma = 44;
var codeDot = 46;
var codeColon = 58;
var codeUppercaseA = 65;
var codeLowercaseA = 97;
var codeUppercaseE = 69;
var codeLowercaseE = 101;
var codeUppercaseF = 70;
var codeLowercaseF = 102;

// node_modules/lossless-json/lib/esm/stringify.js
var import_dist34 = __toESM(require_dist(), 1);
var import_dist35 = __toESM(require_dist2(), 1);
var import_dist36 = __toESM(require_dist3(), 1);

// node_modules/lossless-json/lib/esm/reviveDate.js
var import_dist37 = __toESM(require_dist(), 1);
var import_dist38 = __toESM(require_dist2(), 1);
var import_dist39 = __toESM(require_dist3(), 1);

// node_modules/lossless-json/lib/esm/types.js
var import_dist40 = __toESM(require_dist(), 1);
var import_dist41 = __toESM(require_dist2(), 1);
var import_dist42 = __toESM(require_dist3(), 1);

// node_modules/@electrum-cash/network/dist/index.mjs
function $parcel$export2(e, n, v, s) {
  Object.defineProperty(e, n, { get: v, set: s, enumerable: true, configurable: true });
}
var $24139611f53a54b8$export$5d955335434540c6 = class {
  /**
  * Helper function that builds an Electrum request object.
  *
  * @param method     - method to call.
  * @param parameters - method parameters for the call.
  * @param requestId  - unique string or number referencing this request.
  *
  * @returns a properly formatted Electrum request string.
  */
  static buildRequestObject(method, parameters, requestId) {
    return JSON.stringify({
      method,
      params: parameters,
      id: requestId
    });
  }
  /**
  * Constant used to verify if a provided string is a valid version number.
  *
  * @returns a regular expression that matches valid version numbers.
  */
  static get versionRegexp() {
    return /^\d+(\.\d+)+$/;
  }
  /**
  * Constant used to separate statements/messages in a stream of data.
  *
  * @returns the delimiter used by Electrum to separate statements.
  */
  static get statementDelimiter() {
    return "\n";
  }
};
var $e83d2e7688025acd$exports = {};
$parcel$export2($e83d2e7688025acd$exports, "isVersionRejected", () => $e83d2e7688025acd$export$e1f38ab2b4ebdde6);
$parcel$export2($e83d2e7688025acd$exports, "isVersionNegotiated", () => $e83d2e7688025acd$export$9598f0c76aa41d73);
var $e83d2e7688025acd$export$e1f38ab2b4ebdde6 = function(object) {
  return "error" in object;
};
var $e83d2e7688025acd$export$9598f0c76aa41d73 = function(object) {
  return "software" in object && "protocol" in object;
};
var $abcb763a48577a1e$export$d73a2e87a509880 = function(message) {
  return "id" in message && "error" in message;
};
var $abcb763a48577a1e$export$280de919a0cf6928 = function(message) {
  return !("id" in message) && "method" in message;
};
var $db7c797e63383364$exports = {};
$parcel$export2($db7c797e63383364$exports, "ConnectionStatus", () => $db7c797e63383364$export$7516420eb880ab68);
var $db7c797e63383364$export$7516420eb880ab68;
(function(ConnectionStatus) {
  ConnectionStatus[ConnectionStatus["DISCONNECTED"] = 0] = "DISCONNECTED";
  ConnectionStatus[ConnectionStatus["CONNECTED"] = 1] = "CONNECTED";
  ConnectionStatus[ConnectionStatus["DISCONNECTING"] = 2] = "DISCONNECTING";
  ConnectionStatus[ConnectionStatus["CONNECTING"] = 3] = "CONNECTING";
  ConnectionStatus[ConnectionStatus["RECONNECTING"] = 4] = "RECONNECTING";
})($db7c797e63383364$export$7516420eb880ab68 || ($db7c797e63383364$export$7516420eb880ab68 = {}));
var $ff134c9a9e1f7361$export$de0f57fc22079b5e = class extends (0, import_index.default) {
  /**
  * Sets up network configuration for an Electrum client connection.
  *
  * @param application       - your application name, used to identify to the electrum host.
  * @param version           - protocol version to use with the host.
  * @param socketOrHostname  - pre-configured electrum socket or fully qualified domain name or IP number of the host
  * @param options           - ...
  *
  * @throws {Error} if `version` is not a valid version string.
  */
  constructor(application, version, socketOrHostname, options) {
    super();
    this.application = application;
    this.version = version;
    this.socketOrHostname = socketOrHostname;
    this.options = options;
    this.status = (0, $db7c797e63383364$export$7516420eb880ab68).DISCONNECTED;
    this.verifications = [];
    this.messageBuffer = "";
    if (!(0, $24139611f53a54b8$export$5d955335434540c6).versionRegexp.test(version))
      throw new Error(`Provided version string (${version}) is not a valid protocol version number.`);
    if (typeof socketOrHostname === "string")
      this.socket = new (0, $05743633fea447d4$export$25b4633f61498e1)(socketOrHostname);
    else
      this.socket = socketOrHostname;
    this.socket.on("connected", this.onSocketConnect.bind(this));
    this.socket.on("disconnected", this.onSocketDisconnect.bind(this));
    this.socket.on("data", this.parseMessageChunk.bind(this));
    if (typeof document !== "undefined")
      document.addEventListener("visibilitychange", this.handleVisibilityChange.bind(this));
    if (typeof window !== "undefined") {
      window.addEventListener("online", this.handleNetworkChange.bind(this));
      window.addEventListener("offline", this.handleNetworkChange.bind(this));
    }
  }
  // Expose hostIdentifier from the socket.
  get hostIdentifier() {
    return this.socket.hostIdentifier;
  }
  // Expose port from the socket.
  get encrypted() {
    return this.socket.encrypted;
  }
  /**
  * Assembles incoming data into statements and hands them off to the message parser.
  *
  * @param data - data to append to the current message buffer, as a string.
  *
  * @throws {SyntaxError} if the passed statement parts are not valid JSON.
  */
  parseMessageChunk(data) {
    this.lastReceivedTimestamp = Date.now();
    this.emit("received");
    this.verifications.forEach((timer) => clearTimeout(timer));
    this.verifications.length = 0;
    this.messageBuffer += data;
    while (this.messageBuffer.includes((0, $24139611f53a54b8$export$5d955335434540c6).statementDelimiter)) {
      const statementParts = this.messageBuffer.split((0, $24139611f53a54b8$export$5d955335434540c6).statementDelimiter);
      while (statementParts.length > 1) {
        const currentStatementList = String(statementParts.shift());
        let statementList = (0, parse)(currentStatementList, null, this.options.useBigInt ? (0, parseNumberAndBigInt) : parseFloat);
        if (!Array.isArray(statementList))
          statementList = [
            statementList
          ];
        while (statementList.length > 0) {
          const currentStatement = statementList.shift();
          if ((0, $abcb763a48577a1e$export$280de919a0cf6928)(currentStatement)) {
            this.emit("response", currentStatement);
            continue;
          }
          if (currentStatement.id === "versionNegotiation") {
            if ((0, $abcb763a48577a1e$export$d73a2e87a509880)(currentStatement))
              this.emit("version", {
                error: currentStatement.error
              });
            else {
              const [software, protocol] = currentStatement.result;
              this.emit("version", {
                software,
                protocol
              });
            }
            continue;
          }
          if (currentStatement.id === "keepAlive")
            continue;
          this.emit("response", currentStatement);
        }
      }
      this.messageBuffer = statementParts.shift() || "";
    }
  }
  /**
  * Sends a keep-alive message to the host.
  *
  * @returns true if the ping message was fully flushed to the socket, false if
  * part of the message is queued in the user memory
  */
  ping() {
    (0, $9de8c596df24b669$export$2e2bcd8739ae039).ping(`Sending keep-alive ping to '${this.hostIdentifier}'`);
    const message = (0, $24139611f53a54b8$export$5d955335434540c6).buildRequestObject("server.ping", [], "keepAlive");
    const status = this.send(message);
    return status;
  }
  /**
  * Initiates the network connection negotiates a protocol version. Also emits the 'connect' signal if successful.
  *
  * @throws {Error} if the socket connection fails.
  * @returns a promise resolving when the connection is established
  */
  async connect() {
    if (this.status === (0, $db7c797e63383364$export$7516420eb880ab68).CONNECTED)
      return;
    this.status = (0, $db7c797e63383364$export$7516420eb880ab68).CONNECTING;
    this.emit("connecting");
    const connectionResolver = (resolve, reject) => {
      const rejector = (error) => {
        this.status = (0, $db7c797e63383364$export$7516420eb880ab68).DISCONNECTED;
        this.emit("disconnected");
        reject(error);
      };
      this.socket.removeAllListeners("error");
      this.socket.once("error", rejector);
      const versionNegotiator = () => {
        (0, $9de8c596df24b669$export$2e2bcd8739ae039).network(`Requesting protocol version ${this.version} with '${this.hostIdentifier}'.`);
        this.socket.removeListener("error", rejector);
        const versionMessage = (0, $24139611f53a54b8$export$5d955335434540c6).buildRequestObject("server.version", [
          this.application,
          this.version
        ], "versionNegotiation");
        const versionValidator = (version) => {
          if ((0, $e83d2e7688025acd$export$e1f38ab2b4ebdde6)(version)) {
            this.disconnect(true);
            const errorMessage = "unsupported protocol version.";
            (0, $9de8c596df24b669$export$2e2bcd8739ae039).errors(`Failed to connect with ${this.hostIdentifier} due to ${errorMessage}`);
            reject(errorMessage);
          } else if (version.protocol !== this.version && `${version.protocol}.0` !== this.version && `${version.protocol}.0.0` !== this.version) {
            this.disconnect(true);
            const errorMessage = `incompatible protocol version negotiated (${version.protocol} !== ${this.version}).`;
            (0, $9de8c596df24b669$export$2e2bcd8739ae039).errors(`Failed to connect with ${this.hostIdentifier} due to ${errorMessage}`);
            reject(errorMessage);
          } else {
            (0, $9de8c596df24b669$export$2e2bcd8739ae039).network(`Negotiated protocol version ${version.protocol} with '${this.hostIdentifier}', powered by ${version.software}.`);
            this.status = (0, $db7c797e63383364$export$7516420eb880ab68).CONNECTED;
            this.emit("connected");
            resolve();
          }
        };
        this.once("version", versionValidator);
        this.send(versionMessage);
      };
      this.socket.once("connected", versionNegotiator);
      this.socket.on("error", this.onSocketError.bind(this));
      this.socket.connect();
    };
    await new Promise(connectionResolver);
  }
  /**
  * Restores the network connection.
  */
  async reconnect() {
    await this.clearReconnectTimer();
    (0, $9de8c596df24b669$export$2e2bcd8739ae039).network(`Trying to reconnect to '${this.hostIdentifier}'..`);
    this.status = (0, $db7c797e63383364$export$7516420eb880ab68).RECONNECTING;
    this.emit("reconnecting");
    this.socket.disconnect();
    try {
      await this.connect();
    } catch (error) {
    }
  }
  /**
  * Removes the current reconnect timer.
  */
  clearReconnectTimer() {
    if (this.reconnectTimer)
      clearTimeout(this.reconnectTimer);
    this.reconnectTimer = void 0;
  }
  /**
  * Removes the current keep-alive timer.
  */
  clearKeepAliveTimer() {
    if (this.keepAliveTimer)
      clearTimeout(this.keepAliveTimer);
    this.keepAliveTimer = void 0;
  }
  /**
  * Initializes the keep alive timer loop.
  */
  setupKeepAliveTimer() {
    if (!this.keepAliveTimer)
      this.keepAliveTimer = setTimeout(this.ping.bind(this), this.options.sendKeepAliveIntervalInMilliSeconds);
  }
  /**
  * Tears down the current connection and removes all event listeners on disconnect.
  *
  * @param force       - disconnect even if the connection has not been fully established yet.
  * @param intentional - update connection state if disconnect is intentional.
  *
  * @returns true if successfully disconnected, or false if there was no connection.
  */
  async disconnect(force = false, intentional = true) {
    if (this.status === (0, $db7c797e63383364$export$7516420eb880ab68).DISCONNECTED && !force)
      return false;
    if (intentional)
      this.status = (0, $db7c797e63383364$export$7516420eb880ab68).DISCONNECTING;
    this.emit("disconnecting");
    await this.clearKeepAliveTimer();
    await this.clearReconnectTimer();
    const disconnectResolver = (resolve) => {
      this.once("disconnected", () => resolve(true));
      this.socket.disconnect();
    };
    return new Promise(disconnectResolver);
  }
  /**
  * Updates the connection state based on browser reported connectivity.
  *
  * Most modern browsers are able to provide information on the connection state
  * which allows for significantly faster response times to network changes compared
  * to waiting for network requests to fail.
  *
  * When available, we make use of this to fail early to provide a better user experience.
  */
  async handleNetworkChange() {
    if (typeof window.navigator === "undefined")
      return;
    if (window.navigator.onLine === true)
      this.reconnect();
    if (window.navigator.onLine !== true) {
      const forceDisconnect = true;
      const isUnintended = false;
      this.disconnect(forceDisconnect, isUnintended);
    }
  }
  /**
  * Updates connection state based on application visibility.
  *
  * Some browsers will disconnect network connections when the browser is out of focus,
  * which would normally cause our reconnect-on-timeout routines to trigger, but that
  * results in a poor user experience since the events are not handled consistently
  * and sometimes it can take some time after restoring focus to the browser.
  *
  * By manually disconnecting when this happens we prevent the default reconnection routines
  * and make the behavior consistent across browsers.
  */
  async handleVisibilityChange() {
    if (document.visibilityState === "hidden") {
      const forceDisconnect = true;
      const isUnintended = false;
      this.disconnect(forceDisconnect, isUnintended);
    }
    if (document.visibilityState === "visible")
      this.reconnect();
  }
  /**
  * Sends an arbitrary message to the server.
  *
  * @param message - json encoded request object to send to the server, as a string.
  *
  * @returns true if the message was fully flushed to the socket, false if part of the message
  * is queued in the user memory
  */
  send(message) {
    this.clearKeepAliveTimer();
    const currentTime = Date.now();
    const verificationTimer = setTimeout(this.verifySend.bind(this, currentTime), this.socket.timeout);
    this.verifications.push(verificationTimer);
    this.setupKeepAliveTimer();
    return this.socket.write(message + (0, $24139611f53a54b8$export$5d955335434540c6).statementDelimiter);
  }
  // --- Event managers. --- //
  /**
  * Marks the connection as timed out and schedules reconnection if we have not
  * received data within the expected time frame.
  */
  verifySend(sentTimestamp) {
    if (Number(this.lastReceivedTimestamp) < sentTimestamp) {
      if (this.status === (0, $db7c797e63383364$export$7516420eb880ab68).DISCONNECTED || this.status === (0, $db7c797e63383364$export$7516420eb880ab68).DISCONNECTING)
        return;
      this.clearKeepAliveTimer();
      (0, $9de8c596df24b669$export$2e2bcd8739ae039).network(`Connection to '${this.hostIdentifier}' timed out.`);
      this.socket.disconnect();
    }
  }
  /**
  * Updates the connection status when a connection is confirmed.
  */
  onSocketConnect() {
    this.clearReconnectTimer();
    this.lastReceivedTimestamp = Date.now();
    this.setupKeepAliveTimer();
    this.socket.removeAllListeners("error");
    this.socket.on("error", this.onSocketError.bind(this));
  }
  /**
  * Updates the connection status when a connection is ended.
  */
  onSocketDisconnect() {
    this.clearKeepAliveTimer();
    if (this.status === (0, $db7c797e63383364$export$7516420eb880ab68).DISCONNECTING) {
      this.status = (0, $db7c797e63383364$export$7516420eb880ab68).DISCONNECTED;
      this.emit("disconnected");
      this.clearReconnectTimer();
      this.removeAllListeners();
      (0, $9de8c596df24b669$export$2e2bcd8739ae039).network(`Disconnected from '${this.hostIdentifier}'.`);
    } else {
      if (this.status === (0, $db7c797e63383364$export$7516420eb880ab68).CONNECTED)
        (0, $9de8c596df24b669$export$2e2bcd8739ae039).errors(`Connection with '${this.hostIdentifier}' was closed, trying to reconnect in ${this.options.reconnectAfterMilliSeconds / 1e3} seconds.`);
      this.status = (0, $db7c797e63383364$export$7516420eb880ab68).DISCONNECTED;
      this.emit("disconnected");
      if (!this.reconnectTimer)
        this.reconnectTimer = setTimeout(this.reconnect.bind(this), this.options.reconnectAfterMilliSeconds);
    }
  }
  /**
  * Notify administrator of any unexpected errors.
  */
  onSocketError(error) {
    if (typeof error === "undefined")
      return;
    (0, $9de8c596df24b669$export$2e2bcd8739ae039).errors(`Network error ('${this.hostIdentifier}'): `, error);
  }
};
var $d801b1f9b7fc3074$var$MILLI_SECONDS_PER_SECOND = 1e3;
var $d801b1f9b7fc3074$export$5ba3a4134d0d751d = {
  // By default, all numbers including integers are parsed as regular JavaScript numbers.
  useBigInt: false,
  // Send a ping message every seconds, to detect network problem as early as possible.
  sendKeepAliveIntervalInMilliSeconds: 1 * $d801b1f9b7fc3074$var$MILLI_SECONDS_PER_SECOND,
  // Try to reconnect 5 seconds after unintentional disconnects.
  reconnectAfterMilliSeconds: 5 * $d801b1f9b7fc3074$var$MILLI_SECONDS_PER_SECOND,
  // Try to detect stale connections 5 seconds after every send.
  verifyConnectionTimeoutInMilliSeconds: 5 * $d801b1f9b7fc3074$var$MILLI_SECONDS_PER_SECOND
};
var $558b46d3f899ced5$var$ElectrumClient = class extends (0, import_index.default) {
  /**
  * Number corresponding to the underlying connection status.
  */
  get status() {
    return this.connection.status;
  }
  /**
  * Initializes an Electrum client.
  *
  * @param application       - your application name, used to identify to the electrum host.
  * @param version           - protocol version to use with the host.
  * @param socketOrHostname  - pre-configured electrum socket or fully qualified domain name or IP number of the host
  * @param options           - ...
  *
  * @throws {Error} if `version` is not a valid version string.
  */
  constructor(application, version, socketOrHostname, options = {}) {
    super();
    this.application = application;
    this.version = version;
    this.socketOrHostname = socketOrHostname;
    this.options = options;
    this.subscriptionMethods = {};
    this.requestId = 0;
    this.requestResolvers = {};
    this.connectionLock = new (0, Mutex)();
    const networkOptions = {
      ...(0, $d801b1f9b7fc3074$export$5ba3a4134d0d751d),
      ...options
    };
    this.connection = new (0, $ff134c9a9e1f7361$export$de0f57fc22079b5e)(application, version, socketOrHostname, networkOptions);
  }
  // Expose hostIdentifier from the connection.
  get hostIdentifier() {
    return this.connection.hostIdentifier;
  }
  // Expose port from the connection.
  get encrypted() {
    return this.connection.encrypted;
  }
  /**
  * Connects to the remote server.
  *
  * @throws {Error} if the socket connection fails.
  * @returns a promise resolving when the connection is established.
  */
  async connect() {
    const unlock = await this.connectionLock.acquire();
    try {
      if (this.connection.status === (0, $db7c797e63383364$export$7516420eb880ab68).CONNECTED)
        return;
      this.connection.on("response", this.response.bind(this));
      this.connection.on("connected", this.resubscribeOnConnect.bind(this));
      this.connection.on("disconnected", this.onConnectionDisconnect.bind(this));
      this.connection.on("connecting", this.handleConnectionStatusChanges.bind(this, "connecting"));
      this.connection.on("disconnecting", this.handleConnectionStatusChanges.bind(this, "disconnecting"));
      this.connection.on("reconnecting", this.handleConnectionStatusChanges.bind(this, "reconnecting"));
      this.connection.on("version", this.storeSoftwareVersion.bind(this));
      this.connection.on("received", this.updateLastReceivedTimestamp.bind(this));
      this.connection.on("error", this.emit.bind(this, "error"));
      await this.connection.connect();
    } finally {
      unlock();
    }
  }
  /**
  * Disconnects from the remote server and removes all event listeners/subscriptions and open requests.
  *
  * @param force               - disconnect even if the connection has not been fully established yet.
  * @param retainSubscriptions - retain subscription data so they will be restored on reconnection.
  *
  * @returns true if successfully disconnected, or false if there was no connection.
  */
  async disconnect(force = false, retainSubscriptions = false) {
    if (!retainSubscriptions) {
      this.removeAllListeners();
      this.subscriptionMethods = {};
    }
    return this.connection.disconnect(force);
  }
  /**
  * Calls a method on the remote server with the supplied parameters.
  *
  * @param method     - name of the method to call.
  * @param parameters - one or more parameters for the method.
  *
  * @throws {Error} if the client is disconnected.
  * @returns a promise that resolves with the result of the method or an Error.
  */
  async request(method, ...parameters) {
    if (this.connection.status !== (0, $db7c797e63383364$export$7516420eb880ab68).CONNECTED)
      throw new Error(`Unable to send request to a disconnected server '${this.hostIdentifier}'.`);
    this.requestId += 1;
    const id = this.requestId;
    const message = (0, $24139611f53a54b8$export$5d955335434540c6).buildRequestObject(method, parameters, id);
    const requestResolver = (resolve) => {
      this.requestResolvers[id] = (error, data) => {
        if (error)
          resolve(error);
        else
          resolve(data);
      };
      this.connection.send(message);
    };
    (0, $9de8c596df24b669$export$2e2bcd8739ae039).network(`Sending request '${method}' to '${this.hostIdentifier}'`);
    return new Promise(requestResolver);
  }
  /**
  * Subscribes to the method and payload at the server.
  *
  * @remarks the response for the subscription request is issued as a notification event.
  *
  * @param method     - one of the subscribable methods the server supports.
  * @param parameters - one or more parameters for the method.
  *
  * @throws {Error} if the client is disconnected.
  * @returns a promise resolving when the subscription is established.
  */
  async subscribe(method, ...parameters) {
    if (!this.subscriptionMethods[method])
      this.subscriptionMethods[method] = /* @__PURE__ */ new Set();
    this.subscriptionMethods[method].add(JSON.stringify(parameters));
    const requestData = await this.request(method, ...parameters);
    if (requestData instanceof Error)
      throw requestData;
    if (Array.isArray(requestData))
      throw new Error("Subscription request returned an more than one data point.");
    const notification = {
      jsonrpc: "2.0",
      method,
      params: [
        ...parameters,
        requestData
      ]
    };
    this.emit("notification", notification);
    this.updateChainHeightFromHeadersNotifications(notification);
  }
  /**
  * Unsubscribes to the method at the server and removes any callback functions
  * when there are no more subscriptions for the method.
  *
  * @param method     - a previously subscribed to method.
  * @param parameters - one or more parameters for the method.
  *
  * @throws {Error} if no subscriptions exist for the combination of the provided `method` and `parameters.
  * @throws {Error} if the client is disconnected.
  * @returns a promise resolving when the subscription is removed.
  */
  async unsubscribe(method, ...parameters) {
    if (this.connection.status !== (0, $db7c797e63383364$export$7516420eb880ab68).CONNECTED)
      throw new Error(`Unable to send unsubscribe request to a disconnected server '${this.hostIdentifier}'.`);
    if (!this.subscriptionMethods[method])
      throw new Error(`Cannot unsubscribe from '${method}' since the method has no subscriptions.`);
    const subscriptionParameters = JSON.stringify(parameters);
    if (!this.subscriptionMethods[method].has(subscriptionParameters))
      throw new Error(`Cannot unsubscribe from '${method}' since it has no subscription with the given parameters.`);
    this.subscriptionMethods[method].delete(subscriptionParameters);
    await this.request(method.replace(".subscribe", ".unsubscribe"), ...parameters);
    (0, $9de8c596df24b669$export$2e2bcd8739ae039).client(`Unsubscribed from '${String(method)}' for the '${subscriptionParameters}' parameters.`);
  }
  /**
  * Restores existing subscriptions without updating status or triggering manual callbacks.
  *
  * @throws {Error} if subscription data cannot be found for all stored event names.
  * @throws {Error} if the client is disconnected.
  * @returns a promise resolving to true when the subscriptions are restored.
  *
  * @ignore
  */
  async resubscribeOnConnect() {
    (0, $9de8c596df24b669$export$2e2bcd8739ae039).client(`Connected to '${this.hostIdentifier}'.`);
    this.handleConnectionStatusChanges("connected");
    const resubscriptionPromises = [];
    for (const method in this.subscriptionMethods) {
      for (const parameterJSON of this.subscriptionMethods[method].values()) {
        const parameters = JSON.parse(parameterJSON);
        resubscriptionPromises.push(this.subscribe(method, ...parameters));
      }
      await Promise.all(resubscriptionPromises);
    }
    if (resubscriptionPromises.length > 0)
      (0, $9de8c596df24b669$export$2e2bcd8739ae039).client(`Restored ${resubscriptionPromises.length} previous subscriptions for '${this.hostIdentifier}'`);
  }
  /**
  * Parser messages from the remote server to resolve request promises and emit subscription events.
  *
  * @param message - the response message
  *
  * @throws {Error} if the message ID does not match an existing request.
  * @ignore
  */
  response(message) {
    if ((0, $abcb763a48577a1e$export$280de919a0cf6928)(message)) {
      (0, $9de8c596df24b669$export$2e2bcd8739ae039).client(`Received notification for '${message.method}' from '${this.hostIdentifier}'`);
      this.emit("notification", message);
      this.updateChainHeightFromHeadersNotifications(message);
      return;
    }
    if (message.id === null)
      throw new Error("Internal error: Received an RPC response with ID null.");
    const requestResolver = this.requestResolvers[message.id];
    if (!requestResolver) {
      (0, $9de8c596df24b669$export$2e2bcd8739ae039).warning(`Ignoring response #${message.id} as the request has already been rejected.`);
      return;
    }
    delete this.requestResolvers[message.id];
    if ((0, $abcb763a48577a1e$export$d73a2e87a509880)(message))
      requestResolver(new Error(message.error.message));
    else {
      requestResolver(void 0, message.result);
      this.storeGenesisHashFromFeaturesResponse(message);
    }
  }
  /**
  * Callback function that is called when connection to the Electrum server is lost.
  * Aborts all active requests with an error message indicating that connection was lost.
  *
  * @ignore
  */
  async onConnectionDisconnect() {
    for (const resolverId in this.requestResolvers) {
      const requestResolver = this.requestResolvers[resolverId];
      requestResolver(new Error("Connection lost"));
      delete this.requestResolvers[resolverId];
    }
    this.handleConnectionStatusChanges("disconnected");
  }
  /**
  * Stores the server provider software version field on successful version negotiation.
  *
  * @ignore
  */
  async storeSoftwareVersion(versionStatement) {
    if (versionStatement.error)
      return;
    this.software = versionStatement.software;
  }
  /**
  * Updates the last received timestamp.
  *
  * @ignore
  */
  async updateLastReceivedTimestamp() {
    this.lastReceivedTimestamp = Date.now();
  }
  /**
  * Checks if the provided message is a response to a headers subscription,
  * and if so updates the locally stored chain height value for this client.
  *
  * @ignore
  */
  async updateChainHeightFromHeadersNotifications(message) {
    if (message.method === "blockchain.headers.subscribe")
      this.chainHeight = message.params[0].height;
  }
  /**
  * Checks if the provided message is a response to a server.features request,
  * and if so stores the genesis hash for this client locally.
  *
  * @ignore
  */
  async storeGenesisHashFromFeaturesResponse(message) {
    try {
      if (typeof message.result.genesis_hash !== "undefined")
        this.genesisHash = message.result.genesis_hash;
    } catch (error) {
    }
  }
  /**
  * Helper function to synchronize state and events with the underlying connection.
  */
  async handleConnectionStatusChanges(eventName) {
    this.emit(eventName);
  }
};
var $558b46d3f899ced5$export$2e2bcd8739ae039 = $558b46d3f899ced5$var$ElectrumClient;
export {
  $db7c797e63383364$export$7516420eb880ab68 as ConnectionStatus,
  $558b46d3f899ced5$export$2e2bcd8739ae039 as ElectrumClient,
  $e83d2e7688025acd$export$9598f0c76aa41d73 as isVersionNegotiated,
  $e83d2e7688025acd$export$e1f38ab2b4ebdde6 as isVersionRejected
};
//# sourceMappingURL=@electrum-cash_network.js.map
